Description: Update gnulib to include unistr/u8-check
 Thanks to the wonderful way gnulib works and the fact libidn imports
 from it twice, this updates basically everything rather than only
 adding unistr/u8-check and its dependencies.
Author: Ben Hutchings <ben@decadent.org.uk>
Forwarded: not-needed

---
--- a/GNUmakefile
+++ b/GNUmakefile
@@ -5,7 +5,7 @@
 # It is necessary if you want to build targets usually of interest
 # only to the maintainer.
 
-# Copyright (C) 2001, 2003, 2006-2009 Free Software Foundation, Inc.
+# Copyright (C) 2001, 2003, 2006-2010 Free Software Foundation, Inc.
 
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -49,7 +49,7 @@ include $(srcdir)/maint.mk
 
 # Allow cfg.mk to override these.
 _build-aux ?= build-aux
-_autoreconf ?= autoreconf
+_autoreconf ?= autoreconf -v
 
 # Ensure that $(VERSION) is up to date for dist-related targets, but not
 # for others: rerunning autoreconf and recompiling everything isn't cheap.
@@ -60,8 +60,10 @@ ifeq ($(_have-git-version-gen)0,yes$(MAK
     $(filter maintainer-% dist% alpha beta major,$(MAKECMDGOALS)))
   _is-install-target ?= $(filter-out %check, $(filter install%,$(MAKECMDGOALS)))
   ifneq (,$(_is-dist-target)$(_is-install-target))
-    _curr-ver := $(shell cd $(srcdir) \
-                   && $(_build-aux)/git-version-gen .tarball-version)
+    _curr-ver := $(shell cd $(srcdir)				\
+                   && $(_build-aux)/git-version-gen		\
+                         .tarball-version			\
+                         $(git-version-gen-tag-sed-script))
     ifneq ($(_curr-ver),$(VERSION))
       ifeq ($(_curr-ver),UNKNOWN)
         $(info WARNING: unable to verify if $(VERSION) is the correct version)
@@ -78,7 +80,8 @@ ifeq ($(_have-git-version-gen)0,yes$(MAK
           $(info run '$(MAKE) _version' to fix it)
         else
           $(info INFO: running autoreconf for new version string: $(_curr-ver))
-          _dummy := $(shell $(MAKE) $(AM_MAKEFLAGS) _version)
+GNUmakefile: _version
+	touch GNUmakefile
         endif
       endif
     endif
@@ -88,6 +91,7 @@ endif
 .PHONY: _version
 _version:
 	cd $(srcdir) && rm -rf autom4te.cache .version && $(_autoreconf)
+	$(MAKE) $(AM_MAKEFLAGS) Makefile
 
 else
 
--- /dev/null
+++ b/build-aux/arg-nonnull.h
@@ -0,0 +1,26 @@
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || __GNUC__ > 3
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
--- /dev/null
+++ b/build-aux/c++defs.h
@@ -0,0 +1,271 @@
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      rettype (*const func) parameters = ::rpl_func;          \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      rettype (*const func) parameters =                           \
+        reinterpret_cast<rettype(*)parameters>(::rpl_func);        \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+ */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* If we were to write
+       rettype (*const func) parameters = ::func;
+     like above in _GL_CXXALIAS_RPL_1, the compiler could optimize calls
+     better (remove an indirection through a 'static' pointer variable),
+     but then the _GL_CXXALIASWARN macro below would cause a warning not only
+     for uses of ::func but also for uses of GNULIB_NAMESPACE::func.  */
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                     \
+    {                                              \
+      static rettype (*func) parameters = ::func;  \
+    }                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static rettype (*func) parameters =               \
+        reinterpret_cast<rettype(*)parameters>(::func); \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static rettype (*func) parameters =                                     \
+        reinterpret_cast<rettype(*)parameters>(                               \
+          (rettype2(*)parameters2)(::func));                                  \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
--- a/build-aux/config.rpath
+++ b/build-aux/config.rpath
@@ -2,7 +2,7 @@
 # Output a system dependent set of variables, describing how to set the
 # run time search path of shared libraries in an executable.
 #
-#   Copyright 1996-2008 Free Software Foundation, Inc.
+#   Copyright 1996-2010 Free Software Foundation, Inc.
 #   Taken from GNU libtool, 2001
 #   Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
 #
--- a/build-aux/csharpcomp.sh.in
+++ b/build-aux/csharpcomp.sh.in
@@ -1,7 +1,7 @@
 #!/bin/sh
 # Compile a C# program.
 
-# Copyright (C) 2003-2006 Free Software Foundation, Inc.
+# Copyright (C) 2003-2006, 2009-2010 Free Software Foundation, Inc.
 # Written by Bruno Haible <bruno@clisp.org>, 2003.
 #
 # This program is free software: you can redistribute it and/or modify
--- a/build-aux/gendocs.sh
+++ b/build-aux/gendocs.sh
@@ -1,16 +1,16 @@
-#!/bin/sh
+#!/bin/sh -e
 # gendocs.sh -- generate a GNU manual in many formats.  This script is
 #   mentioned in maintain.texi.  See the help message below for usage details.
 
-scriptversion=2009-04-08.09
+scriptversion=2010-06-21.10
 
-# Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009
+# Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
 # Free Software Foundation, Inc.
 #
-# This program is free software; you can redistribute it and/or modify
+# This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3 of the License,
-# or (at your option) any later version.
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -44,7 +44,7 @@ unset use_texi2html
 
 version="gendocs.sh $scriptversion
 
-Copyright 2009 Free Software Foundation, Inc.
+Copyright 2010 Free Software Foundation, Inc.
 There is NO warranty.  You may redistribute this software
 under the terms of the GNU General Public License.
 For more information about these matters, see the files named COPYING."
@@ -56,6 +56,7 @@ See the GNU Maintainers document for a m
   http://www.gnu.org/prep/maintain_toc.html
 
 Options:
+  -s SRCFILE  read Texinfo from SRCFILE, instead of PACKAGE.{texinfo|texi|txi}
   -o OUTDIR   write files into OUTDIR, instead of manual/.
   --email ADR use ADR as contact in generated web pages.
   --docbook   convert to DocBook too (xml, txt, html, pdf and ps).
@@ -94,11 +95,11 @@ If a manual's Texinfo sources are spread
 first copy or symlink all Texinfo sources into a single directory.
 (Part of the script's work is to make a tar.gz of the sources.)
 
-You can set the environment variables MAKEINFO, TEXI2DVI, and DVIPS to
-control the programs that get executed, and GENDOCS_TEMPLATE_DIR to
-control where the gendocs_template file is looked for.  (With --docbook,
-the environment variables DOCBOOK2HTML, DOCBOOK2PDF, DOCBOOK2PS, and
-DOCBOOK2TXT are also respected.)
+You can set the environment variables MAKEINFO, TEXI2DVI, TEXI2HTML, and
+DVIPS to control the programs that get executed, and
+GENDOCS_TEMPLATE_DIR to control where the gendocs_template file is
+looked for.  With --docbook, the environment variables DOCBOOK2HTML,
+DOCBOOK2PDF, DOCBOOK2PS, and DOCBOOK2TXT are also respected.
 
 By default, makeinfo is run in the default (English) locale, since
 that's the language of most Texinfo manuals.  If you happen to have a
@@ -119,12 +120,14 @@ PACKAGE=
 EMAIL=webmasters@gnu.org  # please override with --email
 htmlarg=
 outdir=manual
+srcfile=
 
 while test $# -gt 0; do
   case $1 in
     --email) shift; EMAIL=$1;;
     --help) echo "$usage"; exit 0;;
     --version) echo "$version"; exit 0;;
+    -s) shift; srcfile=$1;;
     -o) shift; outdir=$1;;
     --docbook) docbook=yes;;
     --html) shift; htmlarg=$1;;
@@ -146,7 +149,17 @@ while test $# -gt 0; do
   shift
 done
 
-if test -s "$srcdir/$PACKAGE.texinfo"; then
+# For most of the following, the base name is just $PACKAGE
+base=$PACKAGE
+
+if test -n "$srcfile"; then
+  # but here, we use the basename of $srcfile
+  base=`basename "$srcfile"`
+  case $base in
+    *.txi|*.texi|*.texinfo) base=`echo "$base"|sed 's/\.[texinfo]*$//'`;;
+  esac
+  PACKAGE=$base
+elif test -s "$srcdir/$PACKAGE.texinfo"; then
   srcfile=$srcdir/$PACKAGE.texinfo
 elif test -s "$srcdir/$PACKAGE.texi"; then
   srcfile=$srcdir/$PACKAGE.texi
@@ -268,13 +281,14 @@ else
 fi
 
 echo Making .tar.gz for sources...
-srcfiles=`ls *.texinfo *.texi *.txi *.eps 2>/dev/null`
+d=`dirname $srcfile`
+srcfiles=`ls $d/*.texinfo $d/*.texi $d/*.txi $d/*.eps 2>/dev/null` || true
 tar cvzfh $outdir/$PACKAGE.texi.tar.gz $srcfiles
 texi_tgz_size=`calcsize $outdir/$PACKAGE.texi.tar.gz`
 
 if test -n "$docbook"; then
   cmd="$SETLANG $MAKEINFO -o - --docbook \"$srcfile\" > ${srcdir}/$PACKAGE-db.xml"
-  echo "Generating docbook XML... $(cmd)"
+  echo "Generating docbook XML... ($cmd)"
   eval "$cmd"
   docbook_xml_size=`calcsize $PACKAGE-db.xml`
   gzip -f -9 -c $PACKAGE-db.xml >$outdir/$PACKAGE-db.xml.gz
@@ -302,7 +316,7 @@ if test -n "$docbook"; then
   mv $PACKAGE-db.txt $outdir/
 
   cmd="${DOCBOOK2PS} ${outdir}/$PACKAGE-db.xml"
-  echo "Generating docbook PS... $(cmd)"
+  echo "Generating docbook PS... ($cmd)"
   eval "$cmd"
   gzip -f -9 -c $PACKAGE-db.ps >$outdir/$PACKAGE-db.ps.gz
   docbook_ps_gz_size=`calcsize $outdir/$PACKAGE-db.ps.gz`
--- a/build-aux/gnupload
+++ b/build-aux/gnupload
@@ -1,9 +1,10 @@
 #!/bin/sh
 # Sign files and upload them.
 
-scriptversion=2009-04-28.21; # UTC
+scriptversion=2010-05-23.15; # UTC
 
-# Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation
+# Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
+# Foundation, Inc.
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -31,11 +32,14 @@ delete_files=
 delete_symlinks=
 collect_var=
 dbg=
+nl='
+'
 
-usage="Usage: $0 [OPTIONS]... [COMMAND] FILES... [[COMMAND] FILES...]
+usage="Usage: $0 [OPTION]... [CMD] FILE... [[CMD] FILE...]
 
-Sign all FILES, and upload them to selected destinations, according to
-<http://www.gnu.org/prep/maintain/html_node/Automated-FTP-Uploads.html>.
+Sign all FILES, and process them at selected destinations according to CMD.
+<http://www.gnu.org/prep/maintain/html_node/Automated-FTP-Uploads.html>
+explains further.
 
 Commands:
   --delete                 delete FILES from destination
@@ -73,34 +77,33 @@ actual command line options.  Use this t
 (#) and empty lines in $conffile are allowed.
 
 Examples:
-1. Upload automake-1.8.2b.tar.gz and automake-1.8.2b.tar.bz2 to two sites:
-  gnupload --to sources.redhat.com:~ftp/pub/automake \\
-           --to alpha.gnu.org:automake \\
-           automake-1.8.2b.tar.gz automake-1.8.2b.tar.bz2
-
-2. Same as above, but also create symbolic links to automake-latest.tar.*:
-  gnupload --to sources.redhat.com:~ftp/pub/automake \\
-           --to alpha.gnu.org:automake \\
-           --symlink-regex \\
-           automake-1.8.2b.tar.gz automake-1.8.2b.tar.bz2
+1. Upload foobar-1.0.tar.gz to ftp.gnu.org:
+  gnupload --to ftp.gnu.org:foobar foobar-1.0.tar.gz
+
+2. Upload foobar-1.0.tar.gz and foobar-1.0.tar.xz to ftp.gnu.org:
+  gnupload --to ftp.gnu.org:foobar foobar-1.0.tar.gz foobar-1.0.tar.xz
 
-3. Symlink automake-1.8.2b.tar.gz to automake-latest.tar.gz and
-automake-1.8.2b.tar.bz2 to automake-latest.tar.bz2 on both sites:
+3. Same as above, and also create symbolic links to foobar-latest.tar.*:
+  gnupload --to ftp.gnu.org:foobar \\
+           --symlink-regex \\
+           foobar-1.0.tar.gz foobar-1.0.tar.xz
 
-  gnupload --to sources.redhat.com:~ftp/pub/automake \\
-           --to alpha.gnu.org:automake \\
-           --symlink automake-1.8.2b.tar.gz automake-latest.tar.gz \\
-                     automake-1.8.2b.tar.bz2 automake-latest.tar.bz2
-
-4. Delete automake-1.8.2a.tar.gz and .bz2, remove symlink
-automake-latest.tar.gz and upload automake-1.8.2b.tar.gz:
-
-  gnupload --to sources.redhat.com:~ftp/pub/automake \\
-           --to alpha.gnu.org:automake \\
-           --delete automake-1.8.2a.tar.gz automake-1.8.2a.tar.bz2 \\
-           --rmsymlink automake-latest.tar.gz \\
-           -- \\
-           automake-1.8.2b.tar.gz automake-1.8.2b.tar.bz2
+4. Upload foobar-0.9.90.tar.gz to two sites:
+  gnupload --to alpha.gnu.org:foobar \\
+           --to sources.redhat.com:~ftp/pub/foobar \\
+           foobar-0.9.90.tar.gz
+
+5. Delete oopsbar-0.9.91.tar.gz and upload foobar-0.9.91.tar.gz
+   (the -- terminates the list of files to delete):
+  gnupload --to alpha.gnu.org:foobar \\
+           --to sources.redhat.com:~ftp/pub/foobar \\
+           --delete oopsbar-0.9.91.tar.gz \\
+           -- foobar-0.9.91.tar.gz
+
+gnupload uses the ncftpput program to do the transfers; if you don't
+happen to have an ncftp package installed, the ncftpput-ftp script in
+the build-aux/ directory of the gnulib package
+(http://savannah.gnu.org/projects/gnulib) may serve as a replacement.
 
 Report bugs to <bug-automake@gnu.org>.
 Send patches to <automake-patches@gnu.org>."
@@ -108,7 +111,8 @@ Send patches to <automake-patches@gnu.or
 # Read local configuration file
 if test -r "$conffile"; then
   echo "$0: Reading configuration file $conffile"
-  eval set x "`sed 's/#.*$//;/^$/d' \"$conffile\" | tr '\012\015' '  '` \"\$@\""
+  conf=`sed 's/#.*$//;/^$/d' "$conffile" | tr "\015$nl" '  '`
+  eval set x "$conf \"\$@\""
   shift
 fi
 
@@ -184,7 +188,7 @@ done
 
 dprint()
 {
-  echo "Running $*..."
+  echo "Running $* ..."
 }
 
 if $dry_run; then
@@ -248,7 +252,7 @@ echo
 if test $# -ne 0; then
   for file
   do
-    echo "Signing $file..."
+    echo "Signing $file ..."
     rm -f $file.sig
     echo "$passphrase" | $dbg $GPG --passphrase-fd 0 -ba -o $file.sig $file
   done
@@ -387,7 +391,7 @@ for dest in $to
 do
   for file
   do
-    echo "Uploading $file to $dest..."
+    echo "Uploading $file to $dest ..."
     stmt=
     files="$file $file.sig"
     destdir=`echo $dest | sed 's/[^:]*://'`
--- a/build-aux/link-warning.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/* GL_LINK_WARNING("literal string") arranges to emit the literal string as
-   a linker warning on most glibc systems.
-   We use a linker warning rather than a preprocessor warning, because
-   #warning cannot be used inside macros.  */
-#ifndef GL_LINK_WARNING
-  /* This works on platforms with GNU ld and ELF object format.
-     Testing __GLIBC__ is sufficient for asserting that GNU ld is in use.
-     Testing __ELF__ guarantees the ELF object format.
-     Testing __GNUC__ is necessary for the compound expression syntax.  */
-# if defined __GLIBC__ && defined __ELF__ && defined __GNUC__
-#  define GL_LINK_WARNING(message) \
-     GL_LINK_WARNING1 (__FILE__, __LINE__, message)
-#  define GL_LINK_WARNING1(file, line, message) \
-     GL_LINK_WARNING2 (file, line, message)  /* macroexpand file and line */
-#  define GL_LINK_WARNING2(file, line, message) \
-     GL_LINK_WARNING3 (file ":" #line ": warning: " message)
-#  define GL_LINK_WARNING3(message) \
-     ({ static const char warning[sizeof (message)]		\
-          __attribute__ ((__unused__,				\
-                          __section__ (".gnu.warning"),		\
-                          __aligned__ (1)))			\
-          = message "\n";					\
-        (void)0;						\
-     })
-# else
-#  define GL_LINK_WARNING(message) ((void) 0)
-# endif
-#endif
--- a/build-aux/pmccabe2html
+++ b/build-aux/pmccabe2html
@@ -1,7 +1,6 @@
-#!/usr/bin/awk -f
-# pmccabe2html - pmccabe to html converter
+# pmccabe2html - AWK script to convert pmccabe output to html
 
-# Copyright (C) 2007, 2008 Free Software Foundation, Inc.
+# Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
 
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -22,16 +21,16 @@
 
 # Typical Invocation is from a Makefile.am:
 #
-# cyclo-libidn.html:
+# cyclo-$(PACKAGE).html:
 #	$(PMCCABE) ${top_srcdir}/lib/*.[ch] \
 #		| sort -nr \
 #		| $(AWK) -f ${top_srcdir}/build-aux/pmccabe2html \
 #			-v lang=html -v name="$(PACKAGE_NAME)" \
-#			-v vcurl="http://git.savannah.gnu.org/gitweb/?p=libidn.git;a=blob;f=%FILENAME%;hb=HEAD" \
-#			-v url="http://www.gnu.org/software/libidn/" \
-#                       -v css=../../build-aux/pmccabe.css \
-#			> tmp
-#	mv tmp $@
+#			-v vcurl="http://git.savannah.gnu.org/gitweb/?p=$(PACKAGE).git;a=blob;f=%FILENAME%;hb=HEAD" \
+#			-v url="http://www.gnu.org/software/$(PACKAGE)/" \
+#                       -v css=${top_srcdir}/build-aux/pmccabe.css \
+#			> $@-tmp
+#	mv $@-tmp $@
 #
 # The variables available are:
 #   lang     output language, either 'html' or 'wiki'
@@ -65,7 +64,7 @@ BEGIN {
 	html_prolog = "<a href=\"" url "\">Back to " package_name " Homepage</a><br/><br/>"
     }
     html_epilog = "<hr color=\"black\" size=\"2\"/> \
-Copyright (c) 2007, 2008 Free Software Foundation Inc."
+Copyright (c) 2007, 2008 Free Software Foundation, Inc."
     html_doctype = "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \
 \"http://www.w3.org/TR/html401/loose.dtd\">"
     html_comment = "<!-- Generated by gnulib's pmccabe2html at " systime() " -->"
@@ -136,22 +135,22 @@ function html_fnc_table (caption,
     {
         print "<caption class=\"function_table_caption\">" caption "</caption>"
     }
-    html_fnc_header(fname_p, 
-                    mcyclo_p, 
-                    cyclo_p, 
-                    num_statements_p, 
-                    num_lines_p, 
-                    first_line_p, 
+    html_fnc_header(fname_p,
+                    mcyclo_p,
+                    cyclo_p,
+                    num_statements_p,
+                    num_lines_p,
+                    first_line_p,
                     file_p)
     for (nfnc = 1; nfnc < nfuncs; nfnc++)
     {
         html_fnc(nfnc,
-                 fname_p, 
-                 mcyclo_p, 
-                 cyclo_p, 
-                 num_statements_p, 
-                 num_lines_p, 
-                 first_line_p, 
+                 fname_p,
+                 mcyclo_p,
+                 cyclo_p,
+                 num_statements_p,
+                 num_lines_p,
+                 first_line_p,
                  file_p)
     }
     print "</table>"
@@ -308,7 +307,7 @@ function html_fnc (nfun,
     if (mcyclo[nfun] > cyclo_high_max)
     {
         trclass="function_entry_untestable"
-    }   
+    }
     else if (mcyclo[nfun] > cyclo_moderate_max)
     {
         trclass="function_entry_high"
@@ -392,7 +391,7 @@ function html_fnc (nfun,
         {
             print file[nfun]
         }
- 
+
         print "</td>"
 
 
@@ -410,7 +409,7 @@ function html_fnc (nfun,
             if (num_lines_p) { num_columns++ }
             if (first_line_p) { num_columns++ }
             if (file_p) { num_columns++ }
-            
+
             print "<td colspan=\"" num_columns "\" height=\"0\">"
             print "<div id=\"" fname "_src\" class=\"function_src\" style=\"position: relative; display: none;\">"
             print "<pre class=\"function_src\">"
@@ -420,7 +419,7 @@ function html_fnc (nfun,
                 sub(/\\</, "&lt;", codeline)
                 sub(/\\>/, "&gt;", codeline)
                 sub(/&/, "&amp;", codeline)
-                
+
                 print codeline
             }
             close(fname nfun "_fn.txt")
@@ -518,7 +517,7 @@ function html_function_cyclo ()
     print "Simple module, without much risk"
     print "</td>"
     print "</tr>"
-    # Moderate 
+    # Moderate
     print "<tr>"
     print "<td class=\"ranges_entry_moderate\">"
     print "&nbsp;"
@@ -590,7 +589,7 @@ function wiki_function_cyclo ()
     print "==Details for all functions=="
 
     print "Used ranges:"
-    
+
     print "{| class =\"cyclo_ranges_table\""
     print "|-"
     print "| class=\"cyclo_ranges_header_entry\" | "
@@ -647,22 +646,22 @@ function wiki_fnc_table (caption,
     {
         print "|+" caption
     }
-    wiki_fnc_header(fname_p, 
-                    mcyclo_p, 
-                    cyclo_p, 
-                    num_statements_p, 
-                    num_lines_p, 
-                    first_line_p, 
+    wiki_fnc_header(fname_p,
+                    mcyclo_p,
+                    cyclo_p,
+                    num_statements_p,
+                    num_lines_p,
+                    first_line_p,
                     file_p)
     for (nfnc = 1; nfnc < nfuncs; nfnc++)
     {
         wiki_fnc(nfnc,
-                 fname_p, 
-                 mcyclo_p, 
-                 cyclo_p, 
-                 num_statements_p, 
-                 num_lines_p, 
-                 first_line_p, 
+                 fname_p,
+                 mcyclo_p,
+                 cyclo_p,
+                 num_statements_p,
+                 num_lines_p,
+                 first_line_p,
                  file_p)
     }
     print "|}"
@@ -725,7 +724,7 @@ function wiki_fnc (nfnc,
     if (mcyclo[nfnc] > cyclo_high_max)
     {
         trclass="cyclo_function_entry_untestable"
-    }   
+    }
     else if (mcyclo[nfnc] > cyclo_moderate_max)
     {
         trclass="cyclo_function_entry_high"
@@ -774,7 +773,7 @@ function wiki_fnc (nfnc,
             href = source_file_link_tmpl
             sub(/%FILENAME%/, file[nfnc], href)
         }
-        
+
         # Source file
         print "| class=\"cyclo_function_entry_filename\" |" \
             ((href != "") ? "[" href " " file[nfnc] "]" : "[" file[nfnc] "]")
@@ -839,7 +838,7 @@ END {
     }
 
     # Print prolog
-    if ((output_lang == "html") && 
+    if ((output_lang == "html") &&
         (html_prolog != ""))
     {
         print html_prolog
@@ -885,9 +884,9 @@ END {
             wiki_function_cyclo()
         }
     }
-    
+
     # Print epilog
-    if ((output_lang == "html") && 
+    if ((output_lang == "html") &&
         (html_epilog != ""))
     {
         print html_epilog
--- /dev/null
+++ b/build-aux/unused-parameter.h
@@ -0,0 +1,36 @@
+/* A C macro for declaring that specific function parameters are not used.
+   Copyright (C) 2008-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* _GL_UNUSED_PARAMETER is a marker that can be appended to function parameter
+   declarations for parameters that are not used.  This helps to reduce
+   warnings, such as from GCC -Wunused-parameter.  The syntax is as follows:
+       type param _GL_UNUSED_PARAMETER
+   or more generally
+       param_decl _GL_UNUSED_PARAMETER
+   For example:
+       int param _GL_UNUSED_PARAMETER
+       int *(*param)(void) _GL_UNUSED_PARAMETER
+   Other possible, but obscure and discouraged syntaxes:
+       int _GL_UNUSED_PARAMETER *(*param)(void)
+       _GL_UNUSED_PARAMETER int *(*param)(void)
+ */
+#ifndef _GL_UNUSED_PARAMETER
+# if __GNUC__ >= 3 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)
+#  define _GL_UNUSED_PARAMETER __attribute__ ((__unused__))
+# else
+#  define _GL_UNUSED_PARAMETER
+# endif
+#endif
--- a/build-aux/useless-if-before-free
+++ b/build-aux/useless-if-before-free
@@ -1,4 +1,6 @@
-#!/usr/bin/perl -T
+eval '(exit $?0)' && eval 'exec perl -wST "$0" ${1+"$@"}'
+  & eval 'exec perl -wST "$0" $argv:q'
+    if 0;
 # Detect instances of "if (p) free (p);".
 # Likewise for "if (p != NULL) free (p);".  And with braces.
 # Also detect "if (NULL != p) free (p);".
@@ -10,7 +12,7 @@ my $VERSION = '2009-04-16 15:57'; # UTC
 # If you change this file with Emacs, please let the write hook
 # do its job.  Otherwise, update this string manually.
 
-# Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+# Copyright (C) 2008-2010 Free Software Foundation, Inc.
 
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -197,6 +199,7 @@ When modifying files, refuse to process
 EOF
 
 ## Local Variables:
+## mode: perl
 ## indent-tabs-mode: nil
 ## eval: (add-hook 'write-file-hooks 'time-stamp)
 ## time-stamp-start: "my $VERSION = '"
--- a/build-aux/vc-list-files
+++ b/build-aux/vc-list-files
@@ -2,9 +2,9 @@
 # List version-controlled file names.
 
 # Print a version string.
-scriptversion=2009-04-25.13; # UTC
+scriptversion=2010-04-23.22; # UTC
 
-# Copyright (C) 2006-2009 Free Software Foundation, Inc.
+# Copyright (C) 2006-2010 Free Software Foundation, Inc.
 
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -74,7 +74,7 @@ test "x$dir" = x && dir=.
 if test -d .git; then
   test "x$dir" = x. \
     && dir= sed_esc= \
-    || dir="$dir/" sed_esc=`echo "$dir"|sed 's,\([\\/]\),\\\\\1,g'`
+    || { dir="$dir/"; sed_esc=`echo "$dir"|env sed 's,\([\\/]\),\\\\\1,g'`; }
   # Ignore git symlinks - either they point into the tree, in which case
   # we don't need to visit the target twice, or they point somewhere
   # else (often into a submodule), in which case the content does not
@@ -85,7 +85,7 @@ elif test -d .hg; then
   eval exec hg locate '"$dir/*"' $postprocess
 elif test -d .bzr; then
   test "$postprocess" = '' && postprocess="| sed 's|^\./||'"
-  eval exec bzr ls --versioned '"$dir"' $postprocess
+  eval exec bzr ls -R --versioned '"$dir"' $postprocess
 elif test -d CVS; then
   test "$postprocess" = '' && postprocess="| sed 's|^\./||'"
   if test -x build-aux/cvsu; then
@@ -102,6 +102,8 @@ elif test -d CVS; then
 	}}'\''				\
       `find "$dir" -name Entries -print` /dev/null' $postprocess
   fi
+elif test -d .svn; then
+  eval exec svn list -R '"$dir"' $postprocess
 else
   echo "$0: Failed to determine type of version control used in `pwd`" 1>&2
   exit 1
--- /dev/null
+++ b/build-aux/warn-on-use.h
@@ -0,0 +1,109 @@
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   This macro is useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.  However, one of the reasons that a function is a
+   portability trap is if it has the wrong signature.  Declaring
+   FUNCTION with a different signature in C is a compilation error, so
+   this macro must use the same type as any existing declaration so
+   that programs that avoid the problematic FUNCTION do not fail to
+   compile merely because they included a header that poisoned the
+   function.  But this implies that _GL_WARN_ON_USE is only safe to
+   use if FUNCTION is known to already have a declaration.  Use of
+   this macro implies that there must not be any other macro hiding
+   the declaration of FUNCTION; but undefining FUNCTION first is part
+   of the poisoning process anyway (although for symbols that are
+   provided only via a macro, the result is a compilation error rather
+   than a warning containing "literal string").  Also note that in
+   C++, it is only safe to use if FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+   #if HAVE_RAW_DECL_ENVIRON
+   static inline char ***rpl_environ (void) { return &environ; }
+   _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+   # undef environ
+   # define environ (*rpl_environ ())
+   #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
--- a/doc/fdl-1.3.texi
+++ b/doc/fdl-1.3.texi
@@ -92,16 +92,16 @@ An image format is not Transparent if us
 of text.  A copy that is not ``Transparent'' is called ``Opaque''.
 
 Examples of suitable formats for Transparent copies include plain
-@sc{ascii} without markup, Texinfo input format, La@TeX{} input
-format, @acronym{SGML} or @acronym{XML} using a publicly available
-@acronym{DTD}, and standard-conforming simple @acronym{HTML},
-PostScript or @acronym{PDF} designed for human modification.  Examples
-of transparent image formats include @acronym{PNG}, @acronym{XCF} and
-@acronym{JPG}.  Opaque formats include proprietary formats that can be
-read and edited only by proprietary word processors, @acronym{SGML} or
-@acronym{XML} for which the @acronym{DTD} and/or processing tools are
-not generally available, and the machine-generated @acronym{HTML},
-PostScript or @acronym{PDF} produced by some word processors for
+ASCII without markup, Texinfo input format, La@TeX{} input
+format, SGML or XML using a publicly available
+DTD, and standard-conforming simple HTML,
+PostScript or PDF designed for human modification.  Examples
+of transparent image formats include PNG, XCF and
+JPG.  Opaque formats include proprietary formats that can be
+read and edited only by proprietary word processors, SGML or
+XML for which the DTD and/or processing tools are
+not generally available, and the machine-generated HTML,
+PostScript or PDF produced by some word processors for
 output purposes only.
 
 The ``Title Page'' means, for a printed book, the title page itself,
--- /dev/null
+++ b/doc/gendocs_template
@@ -0,0 +1,96 @@
+<!--#include virtual="/server/header.html" -->
+<title>%%TITLE%% - GNU Project - Free Software Foundation (FSF)</title>
+<!--#include virtual="/server/banner.html" -->
+<h2>%%TITLE%%</h2>
+
+<!-- This document is in XML, and xhtml 1.0 -->
+<!-- Please make sure to properly nest your tags -->
+<!-- and ensure that your final document validates -->
+<!-- consistent with W3C xhtml 1.0 and CSS standards -->
+<!-- See validator.w3.org -->
+
+<address>Free Software Foundation</address>
+<address>last updated %%DATE%%</address>
+
+<p>This manual (%%PACKAGE%%) is available in the following formats:</p>
+
+<ul>
+<li><a href="%%PACKAGE%%.html">HTML
+    (%%HTML_MONO_SIZE%%K bytes)</a> - entirely on one web page.</li>
+<li><a href="html_node/index.html">HTML</a> - with one web page per
+    node.</li>
+%%IF HTML_SECTION%%
+<li><a href="html_section/index.html">HTML</a> - with one web page per
+    section.</li>
+%%ENDIF HTML_SECTION%%
+%%IF HTML_CHAPTER%%
+<li><a href="html_chapter/index.html">HTML</a> - with one web page per
+    chapter.</li>
+%%ENDIF HTML_CHAPTER%%
+<li><a href="%%PACKAGE%%.html.gz">HTML compressed
+    (%%HTML_MONO_GZ_SIZE%%K gzipped characters)</a> - entirely on
+    one web page.</li>
+<li><a href="%%PACKAGE%%.html_node.tar.gz">HTML compressed
+    (%%HTML_NODE_TGZ_SIZE%%K gzipped tar file)</a> -
+    with one web page per node.</li>
+%%IF HTML_SECTION%%
+<li><a href="%%PACKAGE%%.html_section.tar.gz">HTML compressed
+    (%%HTML_SECTION_TGZ_SIZE%%K gzipped tar file)</a> -
+    with one web page per section.</li>
+%%ENDIF HTML_SECTION%%
+%%IF HTML_CHAPTER%%
+<li><a href="%%PACKAGE%%.html_chapter.tar.gz">HTML compressed
+    (%%HTML_CHAPTER_TGZ_SIZE%%K gzipped tar file)</a> -
+    with one web page per chapter.</li>
+%%ENDIF HTML_CHAPTER%%
+<li><a href="%%PACKAGE%%.info.tar.gz">Info document
+    (%%INFO_TGZ_SIZE%%K bytes gzipped tar file)</a>.</li>
+<li><a href="%%PACKAGE%%.txt">ASCII text
+    (%%ASCII_SIZE%%K bytes)</a>.</li>
+<li><a href="%%PACKAGE%%.txt.gz">ASCII text compressed
+    (%%ASCII_GZ_SIZE%%K bytes gzipped)</a>.</li>
+<li><a href="%%PACKAGE%%.dvi.gz">TeX dvi file
+    (%%DVI_GZ_SIZE%%K bytes gzipped)</a>.</li>
+<li><a href="%%PACKAGE%%.ps.gz">PostScript file
+    (%%PS_GZ_SIZE%%K bytes gzipped)</a>.</li>
+<li><a href="%%PACKAGE%%.pdf">PDF file
+    (%%PDF_SIZE%%K bytes)</a>.</li>
+<li><a href="%%PACKAGE%%.texi.tar.gz">Texinfo source
+    (%%TEXI_TGZ_SIZE%%K bytes gzipped tar file).</a></li>
+</ul>
+
+<p>You can <a href="http://shop.fsf.org/">buy printed copies of
+some manuals</a> (among other items) from the Free Software Foundation;
+this helps support FSF activities.</p>
+
+<p>(This page generated by the <a href="%%SCRIPTURL%%">%%SCRIPTNAME%%
+script</a>.)</p>
+
+<!-- If needed, change the copyright block at the bottom. In general, -->
+<!-- all pages on the GNU web server should have the section about    -->
+<!-- verbatim copying.  Please do NOT remove this without talking     -->
+<!-- with the webmasters first. -->
+<!-- Please make sure the copyright date is consistent with the document -->
+<!-- and that it is like this "2001, 2002" not this "2001-2002." -->
+</div><!-- for id="content", starts in the include above -->
+<!--#include virtual="/server/footer.html" -->
+<div id="footer">
+
+<p>
+Please send FSF &amp; GNU inquiries to
+<a href="mailto:gnu@gnu.org">&lt;gnu@gnu.org&gt;</a>.
+There are also <a href="/contact/">other ways to contact</a>
+the FSF.<br />
+Please send broken links and other corrections or suggestions to
+<a href="mailto:%%EMAIL%%">&lt;%%EMAIL%%&gt;</a>.
+</p>
+
+<p>Copyright &copy; 2010 Free Software Foundation, Inc.</p>
+
+<p>Verbatim copying and distribution of this entire article is
+permitted in any medium, provided this notice is preserved.</p>
+
+</div>
+</div>
+</body>
+</html>
--- a/gl/Makefile.am
+++ b/gl/Makefile.am
@@ -1,6 +1,6 @@
 ## DO NOT EDIT! GENERATED AUTOMATICALLY!
 ## Process this file with automake to produce Makefile.in.
-# Copyright (C) 2002-2009 Free Software Foundation, Inc.
+# Copyright (C) 2002-2010 Free Software Foundation, Inc.
 #
 # This file is free software, distributed under the terms of the GNU
 # General Public License.  As a special exception to the GNU General
@@ -38,6 +38,54 @@ libgnu_la_DEPENDENCIES = $(gl_LTLIBOBJS)
 EXTRA_libgnu_la_SOURCES =
 libgnu_la_LDFLAGS = $(AM_LDFLAGS)
 
+## begin gnulib module arg-nonnull
+
+# The BUILT_SOURCES created by this Makefile snippet are not used via #include
+# statements but through direct file reference. Therefore this snippet must be
+# present in all Makefile.am that need it. This is ensured by the applicability
+# 'all' defined above.
+
+BUILT_SOURCES += arg-nonnull.h
+# The arg-nonnull.h that gets inserted into generated .h files is the same as
+# build-aux/arg-nonnull.h, except that it has the copyright header cut off.
+arg-nonnull.h: $(top_srcdir)/build-aux/arg-nonnull.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	sed -n -e '/GL_ARG_NONNULL/,$$p' \
+	  < $(top_srcdir)/build-aux/arg-nonnull.h \
+	  > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += arg-nonnull.h arg-nonnull.h-t
+
+ARG_NONNULL_H=arg-nonnull.h
+
+EXTRA_DIST += $(top_srcdir)/build-aux/arg-nonnull.h
+
+## end   gnulib module arg-nonnull
+
+## begin gnulib module c++defs
+
+# The BUILT_SOURCES created by this Makefile snippet are not used via #include
+# statements but through direct file reference. Therefore this snippet must be
+# present in all Makefile.am that need it. This is ensured by the applicability
+# 'all' defined above.
+
+BUILT_SOURCES += c++defs.h
+# The c++defs.h that gets inserted into generated .h files is the same as
+# build-aux/c++defs.h, except that it has the copyright header cut off.
+c++defs.h: $(top_srcdir)/build-aux/c++defs.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	sed -n -e '/_GL_CXXDEFS/,$$p' \
+	  < $(top_srcdir)/build-aux/c++defs.h \
+	  > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += c++defs.h c++defs.h-t
+
+CXXDEFS_H=c++defs.h
+
+EXTRA_DIST += $(top_srcdir)/build-aux/c++defs.h
+
+## end   gnulib module c++defs
+
 ## begin gnulib module csharpcomp-script
 
 
@@ -52,7 +100,7 @@ BUILT_SOURCES += $(ERRNO_H)
 # We need the following in order to create <errno.h> when the system
 # doesn't have one that is POSIX compliant.
 errno.h: errno.in.h
-	rm -f $@-t $@
+	$(AM_V_GEN)rm -f $@-t $@ && \
 	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
 	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
 	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
@@ -64,7 +112,7 @@ errno.h: errno.in.h
 	      -e 's|@''EOVERFLOW_HIDDEN''@|$(EOVERFLOW_HIDDEN)|g' \
 	      -e 's|@''EOVERFLOW_VALUE''@|$(EOVERFLOW_VALUE)|g' \
 	      < $(srcdir)/errno.in.h; \
-	} > $@-t
+	} > $@-t && \
 	mv $@-t $@
 MOSTLYCLEANFILES += errno.h errno.h-t
 
@@ -88,16 +136,22 @@ EXTRA_DIST += $(top_srcdir)/build-aux/ge
 
 ## end   gnulib module gendocs
 
-## begin gnulib module getopt
+## begin gnulib module getopt-posix
 
 BUILT_SOURCES += $(GETOPT_H)
 
 # We need the following in order to create <getopt.h> when the system
 # doesn't have one that works with the given compiler.
-getopt.h: getopt.in.h
+getopt.h: getopt.in.h $(ARG_NONNULL_H)
+	$(AM_V_GEN)rm -f $@-t $@ && \
 	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  cat $(srcdir)/getopt.in.h; \
-	} > $@-t
+	  sed -e 's|@''HAVE_GETOPT_H''@|$(HAVE_GETOPT_H)|g' \
+	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_GETOPT_H''@|$(NEXT_GETOPT_H)|g' \
+	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
+	      < $(srcdir)/getopt.in.h; \
+	} > $@-t && \
 	mv -f $@-t $@
 MOSTLYCLEANFILES += getopt.h getopt.h-t
 
@@ -105,7 +159,7 @@ EXTRA_DIST += getopt.c getopt.in.h getop
 
 EXTRA_libgnu_la_SOURCES += getopt.c getopt1.c
 
-## end   gnulib module getopt
+## end   gnulib module getopt-posix
 
 ## begin gnulib module gettext-h
 
@@ -137,14 +191,6 @@ EXTRA_DIST += intprops.h
 
 ## end   gnulib module intprops
 
-## begin gnulib module link-warning
-
-LINK_WARNING_H=$(top_srcdir)/build-aux/link-warning.h
-
-EXTRA_DIST += $(top_srcdir)/build-aux/link-warning.h
-
-## end   gnulib module link-warning
-
 ## begin gnulib module maintainer-makefile
 
 EXTRA_DIST += $(top_srcdir)/maint.mk
@@ -171,13 +217,13 @@ BUILT_SOURCES += $(STDARG_H)
 # We need the following in order to create <stdarg.h> when the system
 # doesn't have one that works with the given compiler.
 stdarg.h: stdarg.in.h
-	rm -f $@-t $@
+	$(AM_V_GEN)rm -f $@-t $@ && \
 	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
 	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
 	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
 	      -e 's|@''NEXT_STDARG_H''@|$(NEXT_STDARG_H)|g' \
 	      < $(srcdir)/stdarg.in.h; \
-	} > $@-t
+	} > $@-t && \
 	mv $@-t $@
 MOSTLYCLEANFILES += stdarg.h stdarg.h-t
 
@@ -185,6 +231,29 @@ EXTRA_DIST += stdarg.in.h
 
 ## end   gnulib module stdarg
 
+## begin gnulib module stddef
+
+BUILT_SOURCES += $(STDDEF_H)
+
+# We need the following in order to create <stddef.h> when the system
+# doesn't have one that works with the given compiler.
+stddef.h: stddef.in.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
+	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_STDDEF_H''@|$(NEXT_STDDEF_H)|g' \
+	      -e 's|@''HAVE_WCHAR_T''@|$(HAVE_WCHAR_T)|g' \
+	      -e 's|@''REPLACE_NULL''@|$(REPLACE_NULL)|g' \
+	      < $(srcdir)/stddef.in.h; \
+	} > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += stddef.h stddef.h-t
+
+EXTRA_DIST += stddef.in.h
+
+## end   gnulib module stddef
+
 ## begin gnulib module strerror
 
 
@@ -200,8 +269,8 @@ BUILT_SOURCES += string.h
 
 # We need the following in order to create <string.h> when the system
 # doesn't have one that works with the given compiler.
-string.h: string.in.h
-	rm -f $@-t $@
+string.h: string.in.h $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
+	$(AM_V_GEN)rm -f $@-t $@ && \
 	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
 	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
 	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
@@ -220,6 +289,7 @@ string.h: string.in.h
 	      -e 's|@''GNULIB_MBSSPN''@|$(GNULIB_MBSSPN)|g' \
 	      -e 's|@''GNULIB_MBSSEP''@|$(GNULIB_MBSSEP)|g' \
 	      -e 's|@''GNULIB_MBSTOK_R''@|$(GNULIB_MBSTOK_R)|g' \
+	      -e 's|@''GNULIB_MEMCHR''@|$(GNULIB_MEMCHR)|g' \
 	      -e 's|@''GNULIB_MEMMEM''@|$(GNULIB_MEMMEM)|g' \
 	      -e 's|@''GNULIB_MEMPCPY''@|$(GNULIB_MEMPCPY)|g' \
 	      -e 's|@''GNULIB_MEMRCHR''@|$(GNULIB_MEMRCHR)|g' \
@@ -228,6 +298,7 @@ string.h: string.in.h
 	      -e 's|@''GNULIB_STPNCPY''@|$(GNULIB_STPNCPY)|g' \
 	      -e 's|@''GNULIB_STRCHRNUL''@|$(GNULIB_STRCHRNUL)|g' \
 	      -e 's|@''GNULIB_STRDUP''@|$(GNULIB_STRDUP)|g' \
+	      -e 's|@''GNULIB_STRNCAT''@|$(GNULIB_STRNCAT)|g' \
 	      -e 's|@''GNULIB_STRNDUP''@|$(GNULIB_STRNDUP)|g' \
 	      -e 's|@''GNULIB_STRNLEN''@|$(GNULIB_STRNLEN)|g' \
 	      -e 's|@''GNULIB_STRPBRK''@|$(GNULIB_STRPBRK)|g' \
@@ -238,6 +309,9 @@ string.h: string.in.h
 	      -e 's|@''GNULIB_STRERROR''@|$(GNULIB_STRERROR)|g' \
 	      -e 's|@''GNULIB_STRSIGNAL''@|$(GNULIB_STRSIGNAL)|g' \
 	      -e 's|@''GNULIB_STRVERSCMP''@|$(GNULIB_STRVERSCMP)|g' \
+	      < $(srcdir)/string.in.h | \
+	  sed -e 's|@''HAVE_MBSLEN''@|$(HAVE_MBSLEN)|g' \
+	      -e 's|@''HAVE_MEMCHR''@|$(HAVE_MEMCHR)|g' \
 	      -e 's|@''HAVE_DECL_MEMMEM''@|$(HAVE_DECL_MEMMEM)|g' \
 	      -e 's|@''HAVE_MEMPCPY''@|$(HAVE_MEMPCPY)|g' \
 	      -e 's|@''HAVE_DECL_MEMRCHR''@|$(HAVE_DECL_MEMRCHR)|g' \
@@ -246,25 +320,32 @@ string.h: string.in.h
 	      -e 's|@''HAVE_STPNCPY''@|$(HAVE_STPNCPY)|g' \
 	      -e 's|@''HAVE_STRCHRNUL''@|$(HAVE_STRCHRNUL)|g' \
 	      -e 's|@''HAVE_DECL_STRDUP''@|$(HAVE_DECL_STRDUP)|g' \
-	      -e 's|@''HAVE_STRNDUP''@|$(HAVE_STRNDUP)|g' \
 	      -e 's|@''HAVE_DECL_STRNDUP''@|$(HAVE_DECL_STRNDUP)|g' \
 	      -e 's|@''HAVE_DECL_STRNLEN''@|$(HAVE_DECL_STRNLEN)|g' \
 	      -e 's|@''HAVE_STRPBRK''@|$(HAVE_STRPBRK)|g' \
 	      -e 's|@''HAVE_STRSEP''@|$(HAVE_STRSEP)|g' \
 	      -e 's|@''HAVE_STRCASESTR''@|$(HAVE_STRCASESTR)|g' \
 	      -e 's|@''HAVE_DECL_STRTOK_R''@|$(HAVE_DECL_STRTOK_R)|g' \
-	      -e 's|@''HAVE_DECL_STRERROR''@|$(HAVE_DECL_STRERROR)|g' \
 	      -e 's|@''HAVE_DECL_STRSIGNAL''@|$(HAVE_DECL_STRSIGNAL)|g' \
 	      -e 's|@''HAVE_STRVERSCMP''@|$(HAVE_STRVERSCMP)|g' \
+	      -e 's|@''REPLACE_STPNCPY''@|$(REPLACE_STPNCPY)|g' \
+	      -e 's|@''REPLACE_MEMCHR''@|$(REPLACE_MEMCHR)|g' \
 	      -e 's|@''REPLACE_MEMMEM''@|$(REPLACE_MEMMEM)|g' \
 	      -e 's|@''REPLACE_STRCASESTR''@|$(REPLACE_STRCASESTR)|g' \
 	      -e 's|@''REPLACE_STRDUP''@|$(REPLACE_STRDUP)|g' \
 	      -e 's|@''REPLACE_STRSTR''@|$(REPLACE_STRSTR)|g' \
 	      -e 's|@''REPLACE_STRERROR''@|$(REPLACE_STRERROR)|g' \
+	      -e 's|@''REPLACE_STRNCAT''@|$(REPLACE_STRNCAT)|g' \
+	      -e 's|@''REPLACE_STRNDUP''@|$(REPLACE_STRNDUP)|g' \
+	      -e 's|@''REPLACE_STRNLEN''@|$(REPLACE_STRNLEN)|g' \
 	      -e 's|@''REPLACE_STRSIGNAL''@|$(REPLACE_STRSIGNAL)|g' \
-	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
+	      -e 's|@''REPLACE_STRTOK_R''@|$(REPLACE_STRTOK_R)|g' \
+	      -e 's|@''UNDEFINE_STRTOK_R''@|$(UNDEFINE_STRTOK_R)|g' \
+	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
+	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
+	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)'; \
 	      < $(srcdir)/string.in.h; \
-	} > $@-t
+	} > $@-t && \
 	mv $@-t $@
 MOSTLYCLEANFILES += string.h string.h-t
 
@@ -278,8 +359,8 @@ BUILT_SOURCES += unistd.h
 
 # We need the following in order to create an empty placeholder for
 # <unistd.h> when the system doesn't have one.
-unistd.h: unistd.in.h
-	rm -f $@-t $@
+unistd.h: unistd.in.h $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
+	$(AM_V_GEN)rm -f $@-t $@ && \
 	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
 	  sed -e 's|@''HAVE_UNISTD_H''@|$(HAVE_UNISTD_H)|g' \
 	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
@@ -288,53 +369,108 @@ unistd.h: unistd.in.h
 	      -e 's|@''GNULIB_CHOWN''@|$(GNULIB_CHOWN)|g' \
 	      -e 's|@''GNULIB_CLOSE''@|$(GNULIB_CLOSE)|g' \
 	      -e 's|@''GNULIB_DUP2''@|$(GNULIB_DUP2)|g' \
+	      -e 's|@''GNULIB_DUP3''@|$(GNULIB_DUP3)|g' \
 	      -e 's|@''GNULIB_ENVIRON''@|$(GNULIB_ENVIRON)|g' \
 	      -e 's|@''GNULIB_EUIDACCESS''@|$(GNULIB_EUIDACCESS)|g' \
+	      -e 's|@''GNULIB_FACCESSAT''@|$(GNULIB_FACCESSAT)|g' \
 	      -e 's|@''GNULIB_FCHDIR''@|$(GNULIB_FCHDIR)|g' \
+	      -e 's|@''GNULIB_FCHOWNAT''@|$(GNULIB_FCHOWNAT)|g' \
 	      -e 's|@''GNULIB_FSYNC''@|$(GNULIB_FSYNC)|g' \
 	      -e 's|@''GNULIB_FTRUNCATE''@|$(GNULIB_FTRUNCATE)|g' \
 	      -e 's|@''GNULIB_GETCWD''@|$(GNULIB_GETCWD)|g' \
 	      -e 's|@''GNULIB_GETDOMAINNAME''@|$(GNULIB_GETDOMAINNAME)|g' \
 	      -e 's|@''GNULIB_GETDTABLESIZE''@|$(GNULIB_GETDTABLESIZE)|g' \
+	      -e 's|@''GNULIB_GETGROUPS''@|$(GNULIB_GETGROUPS)|g' \
 	      -e 's|@''GNULIB_GETHOSTNAME''@|$(GNULIB_GETHOSTNAME)|g' \
+	      -e 's|@''GNULIB_GETLOGIN''@|$(GNULIB_GETLOGIN)|g' \
 	      -e 's|@''GNULIB_GETLOGIN_R''@|$(GNULIB_GETLOGIN_R)|g' \
 	      -e 's|@''GNULIB_GETPAGESIZE''@|$(GNULIB_GETPAGESIZE)|g' \
 	      -e 's|@''GNULIB_GETUSERSHELL''@|$(GNULIB_GETUSERSHELL)|g' \
 	      -e 's|@''GNULIB_LCHOWN''@|$(GNULIB_LCHOWN)|g' \
 	      -e 's|@''GNULIB_LINK''@|$(GNULIB_LINK)|g' \
+	      -e 's|@''GNULIB_LINKAT''@|$(GNULIB_LINKAT)|g' \
 	      -e 's|@''GNULIB_LSEEK''@|$(GNULIB_LSEEK)|g' \
+	      -e 's|@''GNULIB_PIPE2''@|$(GNULIB_PIPE2)|g' \
+	      -e 's|@''GNULIB_PREAD''@|$(GNULIB_PREAD)|g' \
+	      -e 's|@''GNULIB_PWRITE''@|$(GNULIB_PWRITE)|g' \
 	      -e 's|@''GNULIB_READLINK''@|$(GNULIB_READLINK)|g' \
+	      -e 's|@''GNULIB_READLINKAT''@|$(GNULIB_READLINKAT)|g' \
+	      -e 's|@''GNULIB_RMDIR''@|$(GNULIB_RMDIR)|g' \
 	      -e 's|@''GNULIB_SLEEP''@|$(GNULIB_SLEEP)|g' \
+	      -e 's|@''GNULIB_SYMLINK''@|$(GNULIB_SYMLINK)|g' \
+	      -e 's|@''GNULIB_SYMLINKAT''@|$(GNULIB_SYMLINKAT)|g' \
+	      -e 's|@''GNULIB_TTYNAME_R''@|$(GNULIB_TTYNAME_R)|g' \
+	      -e 's|@''GNULIB_UNISTD_H_GETOPT''@|$(GNULIB_UNISTD_H_GETOPT)|g' \
 	      -e 's|@''GNULIB_UNISTD_H_SIGPIPE''@|$(GNULIB_UNISTD_H_SIGPIPE)|g' \
+	      -e 's|@''GNULIB_UNLINK''@|$(GNULIB_UNLINK)|g' \
+	      -e 's|@''GNULIB_UNLINKAT''@|$(GNULIB_UNLINKAT)|g' \
+	      -e 's|@''GNULIB_USLEEP''@|$(GNULIB_USLEEP)|g' \
 	      -e 's|@''GNULIB_WRITE''@|$(GNULIB_WRITE)|g' \
+	      < $(srcdir)/unistd.in.h | \
+	  sed -e 's|@''HAVE_CHOWN''@|$(HAVE_CHOWN)|g' \
 	      -e 's|@''HAVE_DUP2''@|$(HAVE_DUP2)|g' \
+	      -e 's|@''HAVE_DUP3''@|$(HAVE_DUP3)|g' \
 	      -e 's|@''HAVE_EUIDACCESS''@|$(HAVE_EUIDACCESS)|g' \
+	      -e 's|@''HAVE_FACCESSAT''@|$(HAVE_FACCESSAT)|g' \
+	      -e 's|@''HAVE_FCHDIR''@|$(HAVE_FCHDIR)|g' \
+	      -e 's|@''HAVE_FCHOWNAT''@|$(HAVE_FCHOWNAT)|g' \
 	      -e 's|@''HAVE_FSYNC''@|$(HAVE_FSYNC)|g' \
 	      -e 's|@''HAVE_FTRUNCATE''@|$(HAVE_FTRUNCATE)|g' \
 	      -e 's|@''HAVE_GETDOMAINNAME''@|$(HAVE_GETDOMAINNAME)|g' \
 	      -e 's|@''HAVE_GETDTABLESIZE''@|$(HAVE_GETDTABLESIZE)|g' \
+	      -e 's|@''HAVE_GETGROUPS''@|$(HAVE_GETGROUPS)|g' \
 	      -e 's|@''HAVE_GETHOSTNAME''@|$(HAVE_GETHOSTNAME)|g' \
+	      -e 's|@''HAVE_GETLOGIN''@|$(HAVE_GETLOGIN)|g' \
 	      -e 's|@''HAVE_GETPAGESIZE''@|$(HAVE_GETPAGESIZE)|g' \
-	      -e 's|@''HAVE_GETUSERSHELL''@|$(HAVE_GETUSERSHELL)|g' \
+	      -e 's|@''HAVE_LCHOWN''@|$(HAVE_LCHOWN)|g' \
 	      -e 's|@''HAVE_LINK''@|$(HAVE_LINK)|g' \
+	      -e 's|@''HAVE_LINKAT''@|$(HAVE_LINKAT)|g' \
+	      -e 's|@''HAVE_PIPE2''@|$(HAVE_PIPE2)|g' \
+	      -e 's|@''HAVE_PREAD''@|$(HAVE_PREAD)|g' \
+	      -e 's|@''HAVE_PWRITE''@|$(HAVE_PWRITE)|g' \
 	      -e 's|@''HAVE_READLINK''@|$(HAVE_READLINK)|g' \
+	      -e 's|@''HAVE_READLINKAT''@|$(HAVE_READLINKAT)|g' \
 	      -e 's|@''HAVE_SLEEP''@|$(HAVE_SLEEP)|g' \
+	      -e 's|@''HAVE_SYMLINK''@|$(HAVE_SYMLINK)|g' \
+	      -e 's|@''HAVE_SYMLINKAT''@|$(HAVE_SYMLINKAT)|g' \
+	      -e 's|@''HAVE_TTYNAME_R''@|$(HAVE_TTYNAME_R)|g' \
+	      -e 's|@''HAVE_UNLINKAT''@|$(HAVE_UNLINKAT)|g' \
+	      -e 's|@''HAVE_USLEEP''@|$(HAVE_USLEEP)|g' \
 	      -e 's|@''HAVE_DECL_ENVIRON''@|$(HAVE_DECL_ENVIRON)|g' \
 	      -e 's|@''HAVE_DECL_GETLOGIN_R''@|$(HAVE_DECL_GETLOGIN_R)|g' \
+	      -e 's|@''HAVE_DECL_GETPAGESIZE''@|$(HAVE_DECL_GETPAGESIZE)|g' \
+	      -e 's|@''HAVE_DECL_GETUSERSHELL''@|$(HAVE_DECL_GETUSERSHELL)|g' \
 	      -e 's|@''HAVE_OS_H''@|$(HAVE_OS_H)|g' \
 	      -e 's|@''HAVE_SYS_PARAM_H''@|$(HAVE_SYS_PARAM_H)|g' \
 	      -e 's|@''REPLACE_CHOWN''@|$(REPLACE_CHOWN)|g' \
 	      -e 's|@''REPLACE_CLOSE''@|$(REPLACE_CLOSE)|g' \
-	      -e 's|@''REPLACE_FCHDIR''@|$(REPLACE_FCHDIR)|g' \
+	      -e 's|@''REPLACE_DUP''@|$(REPLACE_DUP)|g' \
+	      -e 's|@''REPLACE_DUP2''@|$(REPLACE_DUP2)|g' \
+	      -e 's|@''REPLACE_FCHOWNAT''@|$(REPLACE_FCHOWNAT)|g' \
 	      -e 's|@''REPLACE_GETCWD''@|$(REPLACE_GETCWD)|g' \
+	      -e 's|@''REPLACE_GETGROUPS''@|$(REPLACE_GETGROUPS)|g' \
 	      -e 's|@''REPLACE_GETPAGESIZE''@|$(REPLACE_GETPAGESIZE)|g' \
 	      -e 's|@''REPLACE_LCHOWN''@|$(REPLACE_LCHOWN)|g' \
+	      -e 's|@''REPLACE_LINK''@|$(REPLACE_LINK)|g' \
+	      -e 's|@''REPLACE_LINKAT''@|$(REPLACE_LINKAT)|g' \
 	      -e 's|@''REPLACE_LSEEK''@|$(REPLACE_LSEEK)|g' \
+	      -e 's|@''REPLACE_PREAD''@|$(REPLACE_PREAD)|g' \
+	      -e 's|@''REPLACE_PWRITE''@|$(REPLACE_PWRITE)|g' \
+	      -e 's|@''REPLACE_READLINK''@|$(REPLACE_READLINK)|g' \
+	      -e 's|@''REPLACE_RMDIR''@|$(REPLACE_RMDIR)|g' \
+	      -e 's|@''REPLACE_SLEEP''@|$(REPLACE_SLEEP)|g' \
+	      -e 's|@''REPLACE_SYMLINK''@|$(REPLACE_SYMLINK)|g' \
+	      -e 's|@''REPLACE_TTYNAME_R''@|$(REPLACE_TTYNAME_R)|g' \
+	      -e 's|@''REPLACE_UNLINK''@|$(REPLACE_UNLINK)|g' \
+	      -e 's|@''REPLACE_UNLINKAT''@|$(REPLACE_UNLINKAT)|g' \
+	      -e 's|@''REPLACE_USLEEP''@|$(REPLACE_USLEEP)|g' \
 	      -e 's|@''REPLACE_WRITE''@|$(REPLACE_WRITE)|g' \
 	      -e 's|@''UNISTD_H_HAVE_WINSOCK2_H''@|$(UNISTD_H_HAVE_WINSOCK2_H)|g' \
-	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
-	      < $(srcdir)/unistd.in.h; \
-	} > $@-t
+	      -e 's|@''UNISTD_H_HAVE_WINSOCK2_H_AND_USE_SOCKETS''@|$(UNISTD_H_HAVE_WINSOCK2_H_AND_USE_SOCKETS)|g' \
+	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
+	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
+	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)'; \
+	} > $@-t && \
 	mv $@-t $@
 MOSTLYCLEANFILES += unistd.h unistd.h-t
 
@@ -362,6 +498,25 @@ libgnu_la_SOURCES += version-etc.h versi
 
 ## end   gnulib module version-etc
 
+## begin gnulib module warn-on-use
+
+BUILT_SOURCES += warn-on-use.h
+# The warn-on-use.h that gets inserted into generated .h files is the same as
+# build-aux/warn-on-use.h, except that it has the copyright header cut off.
+warn-on-use.h: $(top_srcdir)/build-aux/warn-on-use.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	sed -n -e '/^.ifndef/,$$p' \
+	  < $(top_srcdir)/build-aux/warn-on-use.h \
+	  > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += warn-on-use.h warn-on-use.h-t
+
+WARN_ON_USE_H=warn-on-use.h
+
+EXTRA_DIST += $(top_srcdir)/build-aux/warn-on-use.h
+
+## end   gnulib module warn-on-use
+
 
 mostlyclean-local: mostlyclean-generic
 	@for dir in '' $(MOSTLYCLEANDIRS); do \
--- a/gl/errno.in.h
+++ b/gl/errno.in.h
@@ -1,6 +1,6 @@
 /* A POSIX-like <errno.h>.
 
-   Copyright (C) 2008 Free Software Foundation, Inc.
+   Copyright (C) 2008-2010 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -145,6 +145,11 @@
 #  define GNULIB_defined_ENOTSUP 1
 # endif
 
+# ifndef ESTALE
+#  define ESTALE    2009
+#  define GNULIB_defined_ESTALE 1
+# endif
+
 # ifndef ECANCELED
 #  define ECANCELED 2008
 #  define GNULIB_defined_ECANCELED 1
--- a/gl/error.c
+++ b/gl/error.c
@@ -1,5 +1,5 @@
 /* Error handler for noninteractive utilities
-   Copyright (C) 1990-1998, 2000-2007 Free Software Foundation, Inc.
+   Copyright (C) 1990-1998, 2000-2007, 2009-2010 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    This program is free software: you can redistribute it and/or modify
@@ -70,8 +70,8 @@ unsigned int error_message_count;
 extern void __error (int status, int errnum, const char *message, ...)
      __attribute__ ((__format__ (__printf__, 3, 4)));
 extern void __error_at_line (int status, int errnum, const char *file_name,
-			     unsigned int line_number, const char *message,
-			     ...)
+                             unsigned int line_number, const char *message,
+                             ...)
      __attribute__ ((__format__ (__printf__, 5, 6)));;
 # define error __error
 # define error_at_line __error_at_line
@@ -85,6 +85,18 @@ extern void __error_at_line (int status,
 
 #else /* not _LIBC */
 
+# include <fcntl.h>
+# include <unistd.h>
+
+# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+/* Get declarations of the Win32 API functions.  */
+#  define WIN32_LEAN_AND_MEAN
+#  include <windows.h>
+# endif
+
+/* The gnulib override of fcntl is not needed in this file.  */
+# undef fcntl
+
 # if !HAVE_DECL_STRERROR_R && STRERROR_R_CHAR_P
 #  ifndef HAVE_DECL_STRERROR_R
 "this configure-time declaration test was not run"
@@ -98,8 +110,52 @@ extern char *program_name;
 
 # if HAVE_STRERROR_R || defined strerror_r
 #  define __strerror_r strerror_r
-# endif	/* HAVE_STRERROR_R || defined strerror_r */
-#endif	/* not _LIBC */
+# endif /* HAVE_STRERROR_R || defined strerror_r */
+#endif  /* not _LIBC */
+
+#if !_LIBC
+/* Return non-zero if FD is open.  */
+static inline int
+is_open (int fd)
+{
+# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+  /* On Win32: The initial state of unassigned standard file descriptors is
+     that they are open but point to an INVALID_HANDLE_VALUE.  There is no
+     fcntl, and the gnulib replacement fcntl does not support F_GETFL.  */
+  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;
+# else
+#  ifndef F_GETFL
+#   error Please port fcntl to your platform
+#  endif
+  return 0 <= fcntl (fd, F_GETFL);
+# endif
+}
+#endif
+
+static inline void
+flush_stdout (void)
+{
+#if !_LIBC
+  int stdout_fd;
+
+# if GNULIB_FREOPEN_SAFER
+  /* Use of gnulib's freopen-safer module normally ensures that
+       fileno (stdout) == 1
+     whenever stdout is open.  */
+  stdout_fd = STDOUT_FILENO;
+# else
+  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in
+     practice it is not a problem, because stdout is statically allocated and
+     the fd of a FILE stream is stored as a field in its allocated memory.  */
+  stdout_fd = fileno (stdout);
+# endif
+  /* POSIX states that fflush (stdout) after fclose is unspecified; it
+     is safe in glibc, but not on all other platforms.  fflush (NULL)
+     is always defined, but too draconian.  */
+  if (0 <= stdout_fd && is_open (stdout_fd))
+#endif
+    fflush (stdout);
+}
 
 static void
 print_errno_message (int errnum)
@@ -147,58 +203,58 @@ error_tail (int status, int errnum, cons
       bool use_malloc = false;
 
       while (1)
-	{
-	  if (__libc_use_alloca (len * sizeof (wchar_t)))
-	    wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));
-	  else
-	    {
-	      if (!use_malloc)
-		wmessage = NULL;
-
-	      wchar_t *p = (wchar_t *) realloc (wmessage,
-						len * sizeof (wchar_t));
-	      if (p == NULL)
-		{
-		  free (wmessage);
-		  fputws_unlocked (L"out of memory\n", stderr);
-		  return;
-		}
-	      wmessage = p;
-	      use_malloc = true;
-	    }
-
-	  memset (&st, '\0', sizeof (st));
-	  tmp = message;
-
-	  res = mbsrtowcs (wmessage, &tmp, len, &st);
-	  if (res != len)
-	    break;
-
-	  if (__builtin_expect (len >= SIZE_MAX / 2, 0))
-	    {
-	      /* This really should not happen if everything is fine.  */
-	      res = (size_t) -1;
-	      break;
-	    }
+        {
+          if (__libc_use_alloca (len * sizeof (wchar_t)))
+            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));
+          else
+            {
+              if (!use_malloc)
+                wmessage = NULL;
+
+              wchar_t *p = (wchar_t *) realloc (wmessage,
+                                                len * sizeof (wchar_t));
+              if (p == NULL)
+                {
+                  free (wmessage);
+                  fputws_unlocked (L"out of memory\n", stderr);
+                  return;
+                }
+              wmessage = p;
+              use_malloc = true;
+            }
+
+          memset (&st, '\0', sizeof (st));
+          tmp = message;
+
+          res = mbsrtowcs (wmessage, &tmp, len, &st);
+          if (res != len)
+            break;
+
+          if (__builtin_expect (len >= SIZE_MAX / 2, 0))
+            {
+              /* This really should not happen if everything is fine.  */
+              res = (size_t) -1;
+              break;
+            }
 
-	  len *= 2;
-	}
+          len *= 2;
+        }
 
       if (res == (size_t) -1)
-	{
-	  /* The string cannot be converted.  */
-	  if (use_malloc)
-	    {
-	      free (wmessage);
-	      use_malloc = false;
-	    }
-	  wmessage = (wchar_t *) L"???";
-	}
+        {
+          /* The string cannot be converted.  */
+          if (use_malloc)
+            {
+              free (wmessage);
+              use_malloc = false;
+            }
+          wmessage = (wchar_t *) L"???";
+        }
 
       __vfwprintf (stderr, wmessage, args);
 
       if (use_malloc)
-	free (wmessage);
+        free (wmessage);
     }
   else
 #endif
@@ -233,10 +289,10 @@ error (int status, int errnum, const cha
      cancellation.  Therefore disable cancellation for now.  */
   int state = PTHREAD_CANCEL_ENABLE;
   __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),
-		   0);
+                   0);
 #endif
 
-  fflush (stdout);
+  flush_stdout ();
 #ifdef _LIBC
   _IO_flockfile (stderr);
 #endif
@@ -268,7 +324,7 @@ int error_one_per_line;
 
 void
 error_at_line (int status, int errnum, const char *file_name,
-	       unsigned int line_number, const char *message, ...)
+               unsigned int line_number, const char *message, ...)
 {
   va_list args;
 
@@ -278,10 +334,10 @@ error_at_line (int status, int errnum, c
       static unsigned int old_line_number;
 
       if (old_line_number == line_number
-	  && (file_name == old_file_name
-	      || strcmp (old_file_name, file_name) == 0))
-	/* Simply return and print nothing.  */
-	return;
+          && (file_name == old_file_name
+              || strcmp (old_file_name, file_name) == 0))
+        /* Simply return and print nothing.  */
+        return;
 
       old_file_name = file_name;
       old_line_number = line_number;
@@ -292,10 +348,10 @@ error_at_line (int status, int errnum, c
      cancellation.  Therefore disable cancellation for now.  */
   int state = PTHREAD_CANCEL_ENABLE;
   __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),
-		   0);
+                   0);
 #endif
 
-  fflush (stdout);
+  flush_stdout ();
 #ifdef _LIBC
   _IO_flockfile (stderr);
 #endif
@@ -312,10 +368,10 @@ error_at_line (int status, int errnum, c
 
 #if _LIBC
   __fxprintf (NULL, file_name != NULL ? "%s:%d: " : " ",
-	      file_name, line_number);
+              file_name, line_number);
 #else
   fprintf (stderr, file_name != NULL ? "%s:%d: " : " ",
-	   file_name, line_number);
+           file_name, line_number);
 #endif
 
   va_start (args, message);
--- a/gl/error.h
+++ b/gl/error.h
@@ -1,5 +1,6 @@
 /* Declaration for error-reporting function
-   Copyright (C) 1995, 1996, 1997, 2003, 2006, 2008 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1996, 1997, 2003, 2006, 2008, 2009, 2010 Free Software
+   Foundation, Inc.
    This file is part of the GNU C Library.
 
    This program is free software: you can redistribute it and/or modify
@@ -19,19 +20,18 @@
 #define _ERROR_H 1
 
 #ifndef __attribute__
-/* This feature is available in gcc versions 2.5 and later.  */
-# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5)
-#  define __attribute__(Spec) /* empty */
-# endif
-/* The __-protected variants of `format' and `printf' attributes
-   are accepted by gcc versions 2.6.4 (effectively 2.7) and later.  */
+/* The __attribute__ feature is available in gcc versions 2.5 and later.
+   The __-protected variants of the attributes 'format' and 'printf' are
+   accepted by gcc versions 2.6.4 (effectively 2.7) and later.
+   We enable __attribute__ only if these are supported too, because
+   gnulib and libintl do '#define printf __printf__' when they override
+   the 'printf' function.  */
 # if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
-#  define __format__ format
-#  define __printf__ printf
+#  define __attribute__(Spec)   /* empty */
 # endif
 #endif
 
-#ifdef	__cplusplus
+#ifdef __cplusplus
 extern "C" {
 #endif
 
@@ -43,7 +43,7 @@ extern void error (int __status, int __e
      __attribute__ ((__format__ (__printf__, 3, 4)));
 
 extern void error_at_line (int __status, int __errnum, const char *__fname,
-			   unsigned int __lineno, const char *__format, ...)
+                           unsigned int __lineno, const char *__format, ...)
      __attribute__ ((__format__ (__printf__, 5, 6)));
 
 /* If NULL, error will flush stdout, then print on stderr the program
@@ -58,7 +58,7 @@ extern unsigned int error_message_count;
    variable controls whether this mode is selected or not.  */
 extern int error_one_per_line;
 
-#ifdef	__cplusplus
+#ifdef __cplusplus
 }
 #endif
 
--- a/gl/getopt.c
+++ b/gl/getopt.c
@@ -1,9 +1,9 @@
 /* Getopt for GNU.
-   NOTE: getopt is now part of the C library, so if you don't know what
+   NOTE: getopt is part of the C library, so if you don't know what
    "Keep this file name-space clean" means, talk to drepper@gnu.org
    before changing it!
-   Copyright (C) 1987,88,89,90,91,92,93,94,95,96,98,99,2000,2001,2002,2003,2004,2006,2008
-	Free Software Foundation, Inc.
+   Copyright (C) 1987-1996, 1998-2004, 2006, 2008-2010 Free Software
+   Foundation, Inc.
    This file is part of the GNU C Library.
 
    This program is free software: you can redistribute it and/or modify
@@ -41,12 +41,9 @@
 # include <wchar.h>
 #endif
 
-#ifndef attribute_hidden
-# define attribute_hidden
-#endif
-
-/* Unlike standard Unix `getopt', functions like `getopt_long'
-   let the user intersperse the options with the other arguments.
+/* This version of `getopt' appears to the caller like standard Unix `getopt'
+   but it behaves differently for the user, since it allows the user
+   to intersperse the options with the other arguments.
 
    As `getopt_long' works, it permutes the elements of ARGV so that,
    when it is done, all the options precede everything else.  Thus
@@ -54,7 +51,7 @@
 
    Using `getopt' or setting the environment variable POSIXLY_CORRECT
    disables permutation.
-   Then the application's behavior is completely standard.
+   Then the behavior is completely standard.
 
    GNU application programs can use a third alternative mode in which
    they can distinguish the relative order of options and other arguments.  */
@@ -121,18 +118,18 @@ extern char *__getopt_nonoption_flags;
 
 # ifdef USE_NONOPTION_FLAGS
 #  define SWAP_FLAGS(ch1, ch2) \
-  if (d->__nonoption_flags_len > 0)					      \
-    {									      \
-      char __tmp = __getopt_nonoption_flags[ch1];			      \
-      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \
-      __getopt_nonoption_flags[ch2] = __tmp;				      \
+  if (d->__nonoption_flags_len > 0)                                           \
+    {                                                                         \
+      char __tmp = __getopt_nonoption_flags[ch1];                             \
+      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];          \
+      __getopt_nonoption_flags[ch2] = __tmp;                                  \
     }
 # else
 #  define SWAP_FLAGS(ch1, ch2)
 # endif
-#else	/* !_LIBC */
+#else   /* !_LIBC */
 # define SWAP_FLAGS(ch1, ch2)
-#endif	/* _LIBC */
+#endif  /* _LIBC */
 
 /* Exchange two adjacent subsequences of ARGV.
    One subsequence is elements [first_nonopt,last_nonopt)
@@ -163,57 +160,57 @@ exchange (char **argv, struct _getopt_da
   if (d->__nonoption_flags_len > 0 && top >= d->__nonoption_flags_max_len)
     {
       /* We must extend the array.  The user plays games with us and
-	 presents new arguments.  */
+         presents new arguments.  */
       char *new_str = malloc (top + 1);
       if (new_str == NULL)
-	d->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;
+        d->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;
       else
-	{
-	  memset (__mempcpy (new_str, __getopt_nonoption_flags,
-			     d->__nonoption_flags_max_len),
-		  '\0', top + 1 - d->__nonoption_flags_max_len);
-	  d->__nonoption_flags_max_len = top + 1;
-	  __getopt_nonoption_flags = new_str;
-	}
+        {
+          memset (__mempcpy (new_str, __getopt_nonoption_flags,
+                             d->__nonoption_flags_max_len),
+                  '\0', top + 1 - d->__nonoption_flags_max_len);
+          d->__nonoption_flags_max_len = top + 1;
+          __getopt_nonoption_flags = new_str;
+        }
     }
 #endif
 
   while (top > middle && middle > bottom)
     {
       if (top - middle > middle - bottom)
-	{
-	  /* Bottom segment is the short one.  */
-	  int len = middle - bottom;
-	  register int i;
-
-	  /* Swap it with the top part of the top segment.  */
-	  for (i = 0; i < len; i++)
-	    {
-	      tem = argv[bottom + i];
-	      argv[bottom + i] = argv[top - (middle - bottom) + i];
-	      argv[top - (middle - bottom) + i] = tem;
-	      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
-	    }
-	  /* Exclude the moved bottom segment from further swapping.  */
-	  top -= len;
-	}
+        {
+          /* Bottom segment is the short one.  */
+          int len = middle - bottom;
+          register int i;
+
+          /* Swap it with the top part of the top segment.  */
+          for (i = 0; i < len; i++)
+            {
+              tem = argv[bottom + i];
+              argv[bottom + i] = argv[top - (middle - bottom) + i];
+              argv[top - (middle - bottom) + i] = tem;
+              SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
+            }
+          /* Exclude the moved bottom segment from further swapping.  */
+          top -= len;
+        }
       else
-	{
-	  /* Top segment is the short one.  */
-	  int len = top - middle;
-	  register int i;
-
-	  /* Swap it with the bottom part of the bottom segment.  */
-	  for (i = 0; i < len; i++)
-	    {
-	      tem = argv[bottom + i];
-	      argv[bottom + i] = argv[middle + i];
-	      argv[middle + i] = tem;
-	      SWAP_FLAGS (bottom + i, middle + i);
-	    }
-	  /* Exclude the moved top segment from further swapping.  */
-	  bottom += len;
-	}
+        {
+          /* Top segment is the short one.  */
+          int len = top - middle;
+          register int i;
+
+          /* Swap it with the bottom part of the bottom segment.  */
+          for (i = 0; i < len; i++)
+            {
+              tem = argv[bottom + i];
+              argv[bottom + i] = argv[middle + i];
+              argv[middle + i] = tem;
+              SWAP_FLAGS (bottom + i, middle + i);
+            }
+          /* Exclude the moved top segment from further swapping.  */
+          bottom += len;
+        }
     }
 
   /* Update records for the slots the non-options now occupy.  */
@@ -225,8 +222,9 @@ exchange (char **argv, struct _getopt_da
 /* Initialize the internal data when the first call is made.  */
 
 static const char *
-_getopt_initialize (int argc, char **argv, const char *optstring,
-		    int posixly_correct, struct _getopt_data *d)
+_getopt_initialize (int argc _GL_UNUSED,
+                    char **argv _GL_UNUSED, const char *optstring,
+                    struct _getopt_data *d, int posixly_correct)
 {
   /* Start processing options with ARGV-element 1 (since ARGV-element 0
      is the program name); the sequence of previously skipped
@@ -260,25 +258,25 @@ _getopt_initialize (int argc, char **arg
       && argc == __libc_argc && argv == __libc_argv)
     {
       if (d->__nonoption_flags_max_len == 0)
-	{
-	  if (__getopt_nonoption_flags == NULL
-	      || __getopt_nonoption_flags[0] == '\0')
-	    d->__nonoption_flags_max_len = -1;
-	  else
-	    {
-	      const char *orig_str = __getopt_nonoption_flags;
-	      int len = d->__nonoption_flags_max_len = strlen (orig_str);
-	      if (d->__nonoption_flags_max_len < argc)
-		d->__nonoption_flags_max_len = argc;
-	      __getopt_nonoption_flags =
-		(char *) malloc (d->__nonoption_flags_max_len);
-	      if (__getopt_nonoption_flags == NULL)
-		d->__nonoption_flags_max_len = -1;
-	      else
-		memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),
-			'\0', d->__nonoption_flags_max_len - len);
-	    }
-	}
+        {
+          if (__getopt_nonoption_flags == NULL
+              || __getopt_nonoption_flags[0] == '\0')
+            d->__nonoption_flags_max_len = -1;
+          else
+            {
+              const char *orig_str = __getopt_nonoption_flags;
+              int len = d->__nonoption_flags_max_len = strlen (orig_str);
+              if (d->__nonoption_flags_max_len < argc)
+                d->__nonoption_flags_max_len = argc;
+              __getopt_nonoption_flags =
+                (char *) malloc (d->__nonoption_flags_max_len);
+              if (__getopt_nonoption_flags == NULL)
+                d->__nonoption_flags_max_len = -1;
+              else
+                memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),
+                        '\0', d->__nonoption_flags_max_len - len);
+            }
+        }
       d->__nonoption_flags_len = d->__nonoption_flags_max_len;
     }
   else
@@ -330,6 +328,10 @@ _getopt_initialize (int argc, char **arg
    `flag' field is nonzero, the value of the option's `val' field
    if the `flag' field is zero.
 
+   The elements of ARGV aren't really const, because we permute them.
+   But we pretend they're const in the prototype to be compatible
+   with other systems.
+
    LONGOPTS is a vector of `struct option' terminated by an
    element containing a name which is zero.
 
@@ -338,19 +340,14 @@ _getopt_initialize (int argc, char **arg
    recent call.
 
    If LONG_ONLY is nonzero, '-' as well as '--' can introduce
-   long-named options.
-
-   If POSIXLY_CORRECT is nonzero, behave as if the POSIXLY_CORRECT
-   environment variable were set.  */
+   long-named options.  */
 
 int
 _getopt_internal_r (int argc, char **argv, const char *optstring,
-		    const struct option *longopts, int *longind,
-		    int long_only, int posixly_correct, struct _getopt_data *d)
+                    const struct option *longopts, int *longind,
+                    int long_only, struct _getopt_data *d, int posixly_correct)
 {
   int print_errors = d->opterr;
-  if (optstring[0] == ':')
-    print_errors = 0;
 
   if (argc < 1)
     return -1;
@@ -360,11 +357,15 @@ _getopt_internal_r (int argc, char **arg
   if (d->optind == 0 || !d->__initialized)
     {
       if (d->optind == 0)
-	d->optind = 1;	/* Don't scan ARGV[0], the program name.  */
-      optstring = _getopt_initialize (argc, argv, optstring,
-				      posixly_correct, d);
+        d->optind = 1;  /* Don't scan ARGV[0], the program name.  */
+      optstring = _getopt_initialize (argc, argv, optstring, d,
+                                      posixly_correct);
       d->__initialized = 1;
     }
+  else if (optstring[0] == '-' || optstring[0] == '+')
+    optstring++;
+  if (optstring[0] == ':')
+    print_errors = 0;
 
   /* Test whether ARGV[optind] points to a non-option argument.
      Either it does not have option syntax, or there is an environment flag
@@ -372,8 +373,8 @@ _getopt_internal_r (int argc, char **arg
      is only used when the used in the GNU libc.  */
 #if defined _LIBC && defined USE_NONOPTION_FLAGS
 # define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\0' \
-		      || (d->optind < d->__nonoption_flags_len		      \
-			  && __getopt_nonoption_flags[d->optind] == '1'))
+                      || (d->optind < d->__nonoption_flags_len                \
+                          && __getopt_nonoption_flags[d->optind] == '1'))
 #else
 # define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\0')
 #endif
@@ -383,78 +384,78 @@ _getopt_internal_r (int argc, char **arg
       /* Advance to the next ARGV-element.  */
 
       /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
-	 moved back by the user (who may also have changed the arguments).  */
+         moved back by the user (who may also have changed the arguments).  */
       if (d->__last_nonopt > d->optind)
-	d->__last_nonopt = d->optind;
+        d->__last_nonopt = d->optind;
       if (d->__first_nonopt > d->optind)
-	d->__first_nonopt = d->optind;
+        d->__first_nonopt = d->optind;
 
       if (d->__ordering == PERMUTE)
-	{
-	  /* If we have just processed some options following some non-options,
-	     exchange them so that the options come first.  */
-
-	  if (d->__first_nonopt != d->__last_nonopt
-	      && d->__last_nonopt != d->optind)
-	    exchange ((char **) argv, d);
-	  else if (d->__last_nonopt != d->optind)
-	    d->__first_nonopt = d->optind;
-
-	  /* Skip any additional non-options
-	     and extend the range of non-options previously skipped.  */
-
-	  while (d->optind < argc && NONOPTION_P)
-	    d->optind++;
-	  d->__last_nonopt = d->optind;
-	}
+        {
+          /* If we have just processed some options following some non-options,
+             exchange them so that the options come first.  */
+
+          if (d->__first_nonopt != d->__last_nonopt
+              && d->__last_nonopt != d->optind)
+            exchange ((char **) argv, d);
+          else if (d->__last_nonopt != d->optind)
+            d->__first_nonopt = d->optind;
+
+          /* Skip any additional non-options
+             and extend the range of non-options previously skipped.  */
+
+          while (d->optind < argc && NONOPTION_P)
+            d->optind++;
+          d->__last_nonopt = d->optind;
+        }
 
       /* The special ARGV-element `--' means premature end of options.
-	 Skip it like a null option,
-	 then exchange with previous non-options as if it were an option,
-	 then skip everything else like a non-option.  */
+         Skip it like a null option,
+         then exchange with previous non-options as if it were an option,
+         then skip everything else like a non-option.  */
 
       if (d->optind != argc && !strcmp (argv[d->optind], "--"))
-	{
-	  d->optind++;
+        {
+          d->optind++;
 
-	  if (d->__first_nonopt != d->__last_nonopt
-	      && d->__last_nonopt != d->optind)
-	    exchange ((char **) argv, d);
-	  else if (d->__first_nonopt == d->__last_nonopt)
-	    d->__first_nonopt = d->optind;
-	  d->__last_nonopt = argc;
+          if (d->__first_nonopt != d->__last_nonopt
+              && d->__last_nonopt != d->optind)
+            exchange ((char **) argv, d);
+          else if (d->__first_nonopt == d->__last_nonopt)
+            d->__first_nonopt = d->optind;
+          d->__last_nonopt = argc;
 
-	  d->optind = argc;
-	}
+          d->optind = argc;
+        }
 
       /* If we have done all the ARGV-elements, stop the scan
-	 and back over any non-options that we skipped and permuted.  */
+         and back over any non-options that we skipped and permuted.  */
 
       if (d->optind == argc)
-	{
-	  /* Set the next-arg-index to point at the non-options
-	     that we previously skipped, so the caller will digest them.  */
-	  if (d->__first_nonopt != d->__last_nonopt)
-	    d->optind = d->__first_nonopt;
-	  return -1;
-	}
+        {
+          /* Set the next-arg-index to point at the non-options
+             that we previously skipped, so the caller will digest them.  */
+          if (d->__first_nonopt != d->__last_nonopt)
+            d->optind = d->__first_nonopt;
+          return -1;
+        }
 
       /* If we have come to a non-option and did not permute it,
-	 either stop the scan or describe it to the caller and pass it by.  */
+         either stop the scan or describe it to the caller and pass it by.  */
 
       if (NONOPTION_P)
-	{
-	  if (d->__ordering == REQUIRE_ORDER)
-	    return -1;
-	  d->optarg = argv[d->optind++];
-	  return 1;
-	}
+        {
+          if (d->__ordering == REQUIRE_ORDER)
+            return -1;
+          d->optarg = argv[d->optind++];
+          return 1;
+        }
 
       /* We have found another option-ARGV-element.
-	 Skip the initial punctuation.  */
+         Skip the initial punctuation.  */
 
       d->__nextchar = (argv[d->optind] + 1
-		  + (longopts != NULL && argv[d->optind][1] == '-'));
+                  + (longopts != NULL && argv[d->optind][1] == '-'));
     }
 
   /* Decode the current option-ARGV-element.  */
@@ -474,8 +475,8 @@ _getopt_internal_r (int argc, char **arg
 
   if (longopts != NULL
       && (argv[d->optind][1] == '-'
-	  || (long_only && (argv[d->optind][2]
-			    || !strchr (optstring, argv[d->optind][1])))))
+          || (long_only && (argv[d->optind][2]
+                            || !strchr (optstring, argv[d->optind][1])))))
     {
       char *nameend;
       const struct option *p;
@@ -486,594 +487,585 @@ _getopt_internal_r (int argc, char **arg
       int option_index;
 
       for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)
-	/* Do nothing.  */ ;
+        /* Do nothing.  */ ;
 
       /* Test all long options for either exact match
-	 or abbreviated matches.  */
+         or abbreviated matches.  */
       for (p = longopts, option_index = 0; p->name; p++, option_index++)
-	if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))
-	  {
-	    if ((unsigned int) (nameend - d->__nextchar)
-		== (unsigned int) strlen (p->name))
-	      {
-		/* Exact match found.  */
-		pfound = p;
-		indfound = option_index;
-		exact = 1;
-		break;
-	      }
-	    else if (pfound == NULL)
-	      {
-		/* First nonexact match found.  */
-		pfound = p;
-		indfound = option_index;
-	      }
-	    else if (long_only
-		     || pfound->has_arg != p->has_arg
-		     || pfound->flag != p->flag
-		     || pfound->val != p->val)
-	      /* Second or later nonexact match found.  */
-	      ambig = 1;
-	  }
+        if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))
+          {
+            if ((unsigned int) (nameend - d->__nextchar)
+                == (unsigned int) strlen (p->name))
+              {
+                /* Exact match found.  */
+                pfound = p;
+                indfound = option_index;
+                exact = 1;
+                break;
+              }
+            else if (pfound == NULL)
+              {
+                /* First nonexact match found.  */
+                pfound = p;
+                indfound = option_index;
+              }
+            else if (long_only
+                     || pfound->has_arg != p->has_arg
+                     || pfound->flag != p->flag
+                     || pfound->val != p->val)
+              /* Second or later nonexact match found.  */
+              ambig = 1;
+          }
 
       if (ambig && !exact)
-	{
-	  if (print_errors)
-	    {
+        {
+          if (print_errors)
+            {
 #if defined _LIBC && defined USE_IN_LIBIO
-	      char *buf;
+              char *buf;
 
-	      if (__asprintf (&buf, _("%s: option `%s' is ambiguous\n"),
-			      argv[0], argv[d->optind]) >= 0)
-		{
-		  _IO_flockfile (stderr);
+              if (__asprintf (&buf, _("%s: option '%s' is ambiguous\n"),
+                              argv[0], argv[d->optind]) >= 0)
+                {
+                  _IO_flockfile (stderr);
 
-		  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
-		  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;
+                  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
+                  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;
 
-		  __fxprintf (NULL, "%s", buf);
+                  __fxprintf (NULL, "%s", buf);
 
-		  ((_IO_FILE *) stderr)->_flags2 = old_flags2;
-		  _IO_funlockfile (stderr);
+                  ((_IO_FILE *) stderr)->_flags2 = old_flags2;
+                  _IO_funlockfile (stderr);
 
-		  free (buf);
-		}
+                  free (buf);
+                }
 #else
-	      fprintf (stderr, _("%s: option `%s' is ambiguous\n"),
-		       argv[0], argv[d->optind]);
+              fprintf (stderr, _("%s: option '%s' is ambiguous\n"),
+                       argv[0], argv[d->optind]);
 #endif
-	    }
-	  d->__nextchar += strlen (d->__nextchar);
-	  d->optind++;
-	  d->optopt = 0;
-	  return '?';
-	}
+            }
+          d->__nextchar += strlen (d->__nextchar);
+          d->optind++;
+          d->optopt = 0;
+          return '?';
+        }
 
       if (pfound != NULL)
-	{
-	  option_index = indfound;
-	  d->optind++;
-	  if (*nameend)
-	    {
-	      /* Don't test has_arg with >, because some C compilers don't
-		 allow it to be used on enums.  */
-	      if (pfound->has_arg)
-		d->optarg = nameend + 1;
-	      else
-		{
-		  if (print_errors)
-		    {
+        {
+          option_index = indfound;
+          d->optind++;
+          if (*nameend)
+            {
+              /* Don't test has_arg with >, because some C compilers don't
+                 allow it to be used on enums.  */
+              if (pfound->has_arg)
+                d->optarg = nameend + 1;
+              else
+                {
+                  if (print_errors)
+                    {
 #if defined _LIBC && defined USE_IN_LIBIO
-		      char *buf;
-		      int n;
+                      char *buf;
+                      int n;
 #endif
 
-		      if (argv[d->optind - 1][1] == '-')
-			{
-			  /* --option */
+                      if (argv[d->optind - 1][1] == '-')
+                        {
+                          /* --option */
 #if defined _LIBC && defined USE_IN_LIBIO
-			  n = __asprintf (&buf, _("\
-%s: option `--%s' doesn't allow an argument\n"),
-					  argv[0], pfound->name);
+                          n = __asprintf (&buf, _("\
+%s: option '--%s' doesn't allow an argument\n"),
+                                          argv[0], pfound->name);
 #else
-			  fprintf (stderr, _("\
-%s: option `--%s' doesn't allow an argument\n"),
-				   argv[0], pfound->name);
-#endif
-			}
-		      else
-			{
-			  /* +option or -option */
+                          fprintf (stderr, _("\
+%s: option '--%s' doesn't allow an argument\n"),
+                                   argv[0], pfound->name);
+#endif
+                        }
+                      else
+                        {
+                          /* +option or -option */
 #if defined _LIBC && defined USE_IN_LIBIO
-			  n = __asprintf (&buf, _("\
-%s: option `%c%s' doesn't allow an argument\n"),
-					  argv[0], argv[d->optind - 1][0],
-					  pfound->name);
+                          n = __asprintf (&buf, _("\
+%s: option '%c%s' doesn't allow an argument\n"),
+                                          argv[0], argv[d->optind - 1][0],
+                                          pfound->name);
 #else
-			  fprintf (stderr, _("\
-%s: option `%c%s' doesn't allow an argument\n"),
-				   argv[0], argv[d->optind - 1][0],
-				   pfound->name);
+                          fprintf (stderr, _("\
+%s: option '%c%s' doesn't allow an argument\n"),
+                                   argv[0], argv[d->optind - 1][0],
+                                   pfound->name);
 #endif
-			}
+                        }
 
 #if defined _LIBC && defined USE_IN_LIBIO
-		      if (n >= 0)
-			{
-			  _IO_flockfile (stderr);
-
-			  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
-			  ((_IO_FILE *) stderr)->_flags2
-			    |= _IO_FLAGS2_NOTCANCEL;
-
-			  __fxprintf (NULL, "%s", buf);
-
-			  ((_IO_FILE *) stderr)->_flags2 = old_flags2;
-			  _IO_funlockfile (stderr);
-
-			  free (buf);
-			}
-#endif
-		    }
-
-		  d->__nextchar += strlen (d->__nextchar);
-
-		  d->optopt = pfound->val;
-		  return '?';
-		}
-	    }
-	  else if (pfound->has_arg == 1)
-	    {
-	      if (d->optind < argc)
-		d->optarg = argv[d->optind++];
-	      else
-		{
-		  if (print_errors)
-		    {
+                      if (n >= 0)
+                        {
+                          _IO_flockfile (stderr);
+
+                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
+                          ((_IO_FILE *) stderr)->_flags2
+                            |= _IO_FLAGS2_NOTCANCEL;
+
+                          __fxprintf (NULL, "%s", buf);
+
+                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;
+                          _IO_funlockfile (stderr);
+
+                          free (buf);
+                        }
+#endif
+                    }
+
+                  d->__nextchar += strlen (d->__nextchar);
+
+                  d->optopt = pfound->val;
+                  return '?';
+                }
+            }
+          else if (pfound->has_arg == 1)
+            {
+              if (d->optind < argc)
+                d->optarg = argv[d->optind++];
+              else
+                {
+                  if (print_errors)
+                    {
 #if defined _LIBC && defined USE_IN_LIBIO
-		      char *buf;
+                      char *buf;
 
-		      if (__asprintf (&buf, _("\
-%s: option `%s' requires an argument\n"),
-				      argv[0], argv[d->optind - 1]) >= 0)
-			{
-			  _IO_flockfile (stderr);
+                      if (__asprintf (&buf, _("\
+%s: option '--%s' requires an argument\n"),
+                                      argv[0], pfound->name) >= 0)
+                        {
+                          _IO_flockfile (stderr);
 
-			  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
-			  ((_IO_FILE *) stderr)->_flags2
-			    |= _IO_FLAGS2_NOTCANCEL;
+                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
+                          ((_IO_FILE *) stderr)->_flags2
+                            |= _IO_FLAGS2_NOTCANCEL;
 
-			  __fxprintf (NULL, "%s", buf);
+                          __fxprintf (NULL, "%s", buf);
 
-			  ((_IO_FILE *) stderr)->_flags2 = old_flags2;
-			  _IO_funlockfile (stderr);
+                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;
+                          _IO_funlockfile (stderr);
 
-			  free (buf);
-			}
+                          free (buf);
+                        }
 #else
-		      fprintf (stderr,
-			       _("%s: option `%s' requires an argument\n"),
-			       argv[0], argv[d->optind - 1]);
-#endif
-		    }
-		  d->__nextchar += strlen (d->__nextchar);
-		  d->optopt = pfound->val;
-		  return optstring[0] == ':' ? ':' : '?';
-		}
-	    }
-	  d->__nextchar += strlen (d->__nextchar);
-	  if (longind != NULL)
-	    *longind = option_index;
-	  if (pfound->flag)
-	    {
-	      *(pfound->flag) = pfound->val;
-	      return 0;
-	    }
-	  return pfound->val;
-	}
+                      fprintf (stderr,
+                               _("%s: option '--%s' requires an argument\n"),
+                               argv[0], pfound->name);
+#endif
+                    }
+                  d->__nextchar += strlen (d->__nextchar);
+                  d->optopt = pfound->val;
+                  return optstring[0] == ':' ? ':' : '?';
+                }
+            }
+          d->__nextchar += strlen (d->__nextchar);
+          if (longind != NULL)
+            *longind = option_index;
+          if (pfound->flag)
+            {
+              *(pfound->flag) = pfound->val;
+              return 0;
+            }
+          return pfound->val;
+        }
 
       /* Can't find it as a long option.  If this is not getopt_long_only,
-	 or the option starts with '--' or is not a valid short
-	 option, then it's an error.
-	 Otherwise interpret it as a short option.  */
+         or the option starts with '--' or is not a valid short
+         option, then it's an error.
+         Otherwise interpret it as a short option.  */
       if (!long_only || argv[d->optind][1] == '-'
-	  || strchr (optstring, *d->__nextchar) == NULL)
-	{
-	  if (print_errors)
-	    {
+          || strchr (optstring, *d->__nextchar) == NULL)
+        {
+          if (print_errors)
+            {
 #if defined _LIBC && defined USE_IN_LIBIO
-	      char *buf;
-	      int n;
+              char *buf;
+              int n;
 #endif
 
-	      if (argv[d->optind][1] == '-')
-		{
-		  /* --option */
+              if (argv[d->optind][1] == '-')
+                {
+                  /* --option */
 #if defined _LIBC && defined USE_IN_LIBIO
-		  n = __asprintf (&buf, _("%s: unrecognized option `--%s'\n"),
-				  argv[0], d->__nextchar);
+                  n = __asprintf (&buf, _("%s: unrecognized option '--%s'\n"),
+                                  argv[0], d->__nextchar);
 #else
-		  fprintf (stderr, _("%s: unrecognized option `--%s'\n"),
-			   argv[0], d->__nextchar);
+                  fprintf (stderr, _("%s: unrecognized option '--%s'\n"),
+                           argv[0], d->__nextchar);
 #endif
-		}
-	      else
-		{
-		  /* +option or -option */
+                }
+              else
+                {
+                  /* +option or -option */
 #if defined _LIBC && defined USE_IN_LIBIO
-		  n = __asprintf (&buf, _("%s: unrecognized option `%c%s'\n"),
-				  argv[0], argv[d->optind][0], d->__nextchar);
+                  n = __asprintf (&buf, _("%s: unrecognized option '%c%s'\n"),
+                                  argv[0], argv[d->optind][0], d->__nextchar);
 #else
-		  fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),
-			   argv[0], argv[d->optind][0], d->__nextchar);
+                  fprintf (stderr, _("%s: unrecognized option '%c%s'\n"),
+                           argv[0], argv[d->optind][0], d->__nextchar);
 #endif
-		}
+                }
 
 #if defined _LIBC && defined USE_IN_LIBIO
-	      if (n >= 0)
-		{
-		  _IO_flockfile (stderr);
-
-		  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
-		  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;
-
-		  __fxprintf (NULL, "%s", buf);
-
-		  ((_IO_FILE *) stderr)->_flags2 = old_flags2;
-		  _IO_funlockfile (stderr);
-
-		  free (buf);
-		}
-#endif
-	    }
-	  d->__nextchar = (char *) "";
-	  d->optind++;
-	  d->optopt = 0;
-	  return '?';
-	}
+              if (n >= 0)
+                {
+                  _IO_flockfile (stderr);
+
+                  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
+                  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;
+
+                  __fxprintf (NULL, "%s", buf);
+
+                  ((_IO_FILE *) stderr)->_flags2 = old_flags2;
+                  _IO_funlockfile (stderr);
+
+                  free (buf);
+                }
+#endif
+            }
+          d->__nextchar = (char *) "";
+          d->optind++;
+          d->optopt = 0;
+          return '?';
+        }
     }
 
   /* Look at and handle the next short option-character.  */
 
   {
     char c = *d->__nextchar++;
-    char *temp = strchr (optstring, c);
+    const char *temp = strchr (optstring, c);
 
     /* Increment `optind' when we start to process its last character.  */
     if (*d->__nextchar == '\0')
       ++d->optind;
 
-    if (temp == NULL || c == ':')
+    if (temp == NULL || c == ':' || c == ';')
       {
-	if (print_errors)
-	  {
+        if (print_errors)
+          {
 #if defined _LIBC && defined USE_IN_LIBIO
-	      char *buf;
-	      int n;
+              char *buf;
+              int n;
 #endif
 
-	    if (d->__posixly_correct)
-	      {
-		/* 1003.2 specifies the format of this message.  */
-#if defined _LIBC && defined USE_IN_LIBIO
-		n = __asprintf (&buf, _("%s: illegal option -- %c\n"),
-				argv[0], c);
-#else
-		fprintf (stderr, _("%s: illegal option -- %c\n"), argv[0], c);
-#endif
-	      }
-	    else
-	      {
 #if defined _LIBC && defined USE_IN_LIBIO
-		n = __asprintf (&buf, _("%s: invalid option -- %c\n"),
-				argv[0], c);
+              n = __asprintf (&buf, _("%s: invalid option -- '%c'\n"),
+                              argv[0], c);
 #else
-		fprintf (stderr, _("%s: invalid option -- %c\n"), argv[0], c);
+              fprintf (stderr, _("%s: invalid option -- '%c'\n"), argv[0], c);
 #endif
-	      }
 
 #if defined _LIBC && defined USE_IN_LIBIO
-	    if (n >= 0)
-	      {
-		_IO_flockfile (stderr);
+            if (n >= 0)
+              {
+                _IO_flockfile (stderr);
 
-		int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
-		((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;
+                int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
+                ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;
 
-		__fxprintf (NULL, "%s", buf);
+                __fxprintf (NULL, "%s", buf);
 
-		((_IO_FILE *) stderr)->_flags2 = old_flags2;
-		_IO_funlockfile (stderr);
+                ((_IO_FILE *) stderr)->_flags2 = old_flags2;
+                _IO_funlockfile (stderr);
 
-		free (buf);
-	      }
+                free (buf);
+              }
 #endif
-	  }
-	d->optopt = c;
-	return '?';
+          }
+        d->optopt = c;
+        return '?';
       }
     /* Convenience. Treat POSIX -W foo same as long option --foo */
     if (temp[0] == 'W' && temp[1] == ';')
       {
-	char *nameend;
-	const struct option *p;
-	const struct option *pfound = NULL;
-	int exact = 0;
-	int ambig = 0;
-	int indfound = 0;
-	int option_index;
-
-	/* This is an option that requires an argument.  */
-	if (*d->__nextchar != '\0')
-	  {
-	    d->optarg = d->__nextchar;
-	    /* If we end this ARGV-element by taking the rest as an arg,
-	       we must advance to the next element now.  */
-	    d->optind++;
-	  }
-	else if (d->optind == argc)
-	  {
-	    if (print_errors)
-	      {
-		/* 1003.2 specifies the format of this message.  */
+        char *nameend;
+        const struct option *p;
+        const struct option *pfound = NULL;
+        int exact = 0;
+        int ambig = 0;
+        int indfound = 0;
+        int option_index;
+
+        /* This is an option that requires an argument.  */
+        if (*d->__nextchar != '\0')
+          {
+            d->optarg = d->__nextchar;
+            /* If we end this ARGV-element by taking the rest as an arg,
+               we must advance to the next element now.  */
+            d->optind++;
+          }
+        else if (d->optind == argc)
+          {
+            if (print_errors)
+              {
 #if defined _LIBC && defined USE_IN_LIBIO
-		char *buf;
+                char *buf;
 
-		if (__asprintf (&buf,
-				_("%s: option requires an argument -- %c\n"),
-				argv[0], c) >= 0)
-		  {
-		    _IO_flockfile (stderr);
+                if (__asprintf (&buf,
+                                _("%s: option requires an argument -- '%c'\n"),
+                                argv[0], c) >= 0)
+                  {
+                    _IO_flockfile (stderr);
 
-		    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
-		    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;
+                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
+                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;
 
-		    __fxprintf (NULL, "%s", buf);
+                    __fxprintf (NULL, "%s", buf);
 
-		    ((_IO_FILE *) stderr)->_flags2 = old_flags2;
-		    _IO_funlockfile (stderr);
+                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;
+                    _IO_funlockfile (stderr);
 
-		    free (buf);
-		  }
+                    free (buf);
+                  }
 #else
-		fprintf (stderr, _("%s: option requires an argument -- %c\n"),
-			 argv[0], c);
-#endif
-	      }
-	    d->optopt = c;
-	    if (optstring[0] == ':')
-	      c = ':';
-	    else
-	      c = '?';
-	    return c;
-	  }
-	else
-	  /* We already incremented `d->optind' once;
-	     increment it again when taking next ARGV-elt as argument.  */
-	  d->optarg = argv[d->optind++];
-
-	/* optarg is now the argument, see if it's in the
-	   table of longopts.  */
-
-	for (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';
-	     nameend++)
-	  /* Do nothing.  */ ;
-
-	/* Test all long options for either exact match
-	   or abbreviated matches.  */
-	for (p = longopts, option_index = 0; p->name; p++, option_index++)
-	  if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))
-	    {
-	      if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))
-		{
-		  /* Exact match found.  */
-		  pfound = p;
-		  indfound = option_index;
-		  exact = 1;
-		  break;
-		}
-	      else if (pfound == NULL)
-		{
-		  /* First nonexact match found.  */
-		  pfound = p;
-		  indfound = option_index;
-		}
-	      else
-		/* Second or later nonexact match found.  */
-		ambig = 1;
-	    }
-	if (ambig && !exact)
-	  {
-	    if (print_errors)
-	      {
+                fprintf (stderr,
+                         _("%s: option requires an argument -- '%c'\n"),
+                         argv[0], c);
+#endif
+              }
+            d->optopt = c;
+            if (optstring[0] == ':')
+              c = ':';
+            else
+              c = '?';
+            return c;
+          }
+        else
+          /* We already incremented `d->optind' once;
+             increment it again when taking next ARGV-elt as argument.  */
+          d->optarg = argv[d->optind++];
+
+        /* optarg is now the argument, see if it's in the
+           table of longopts.  */
+
+        for (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';
+             nameend++)
+          /* Do nothing.  */ ;
+
+        /* Test all long options for either exact match
+           or abbreviated matches.  */
+        for (p = longopts, option_index = 0; p->name; p++, option_index++)
+          if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))
+            {
+              if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))
+                {
+                  /* Exact match found.  */
+                  pfound = p;
+                  indfound = option_index;
+                  exact = 1;
+                  break;
+                }
+              else if (pfound == NULL)
+                {
+                  /* First nonexact match found.  */
+                  pfound = p;
+                  indfound = option_index;
+                }
+              else if (long_only
+                       || pfound->has_arg != p->has_arg
+                       || pfound->flag != p->flag
+                       || pfound->val != p->val)
+                /* Second or later nonexact match found.  */
+                ambig = 1;
+            }
+        if (ambig && !exact)
+          {
+            if (print_errors)
+              {
 #if defined _LIBC && defined USE_IN_LIBIO
-		char *buf;
+                char *buf;
 
-		if (__asprintf (&buf, _("%s: option `-W %s' is ambiguous\n"),
-				argv[0], argv[d->optind]) >= 0)
-		  {
-		    _IO_flockfile (stderr);
+                if (__asprintf (&buf, _("%s: option '-W %s' is ambiguous\n"),
+                                argv[0], d->optarg) >= 0)
+                  {
+                    _IO_flockfile (stderr);
 
-		    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
-		    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;
+                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
+                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;
 
-		    __fxprintf (NULL, "%s", buf);
+                    __fxprintf (NULL, "%s", buf);
 
-		    ((_IO_FILE *) stderr)->_flags2 = old_flags2;
-		    _IO_funlockfile (stderr);
+                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;
+                    _IO_funlockfile (stderr);
 
-		    free (buf);
-		  }
+                    free (buf);
+                  }
 #else
-		fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
-			 argv[0], argv[d->optind]);
+                fprintf (stderr, _("%s: option '-W %s' is ambiguous\n"),
+                         argv[0], d->optarg);
 #endif
-	      }
-	    d->__nextchar += strlen (d->__nextchar);
-	    d->optind++;
-	    return '?';
-	  }
-	if (pfound != NULL)
-	  {
-	    option_index = indfound;
-	    if (*nameend)
-	      {
-		/* Don't test has_arg with >, because some C compilers don't
-		   allow it to be used on enums.  */
-		if (pfound->has_arg)
-		  d->optarg = nameend + 1;
-		else
-		  {
-		    if (print_errors)
-		      {
+              }
+            d->__nextchar += strlen (d->__nextchar);
+            d->optind++;
+            return '?';
+          }
+        if (pfound != NULL)
+          {
+            option_index = indfound;
+            if (*nameend)
+              {
+                /* Don't test has_arg with >, because some C compilers don't
+                   allow it to be used on enums.  */
+                if (pfound->has_arg)
+                  d->optarg = nameend + 1;
+                else
+                  {
+                    if (print_errors)
+                      {
 #if defined _LIBC && defined USE_IN_LIBIO
-			char *buf;
+                        char *buf;
 
-			if (__asprintf (&buf, _("\
-%s: option `-W %s' doesn't allow an argument\n"),
-					argv[0], pfound->name) >= 0)
-			  {
-			    _IO_flockfile (stderr);
+                        if (__asprintf (&buf, _("\
+%s: option '-W %s' doesn't allow an argument\n"),
+                                        argv[0], pfound->name) >= 0)
+                          {
+                            _IO_flockfile (stderr);
 
-			    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
-			    ((_IO_FILE *) stderr)->_flags2
-			      |= _IO_FLAGS2_NOTCANCEL;
+                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
+                            ((_IO_FILE *) stderr)->_flags2
+                              |= _IO_FLAGS2_NOTCANCEL;
 
-			    __fxprintf (NULL, "%s", buf);
+                            __fxprintf (NULL, "%s", buf);
 
-			    ((_IO_FILE *) stderr)->_flags2 = old_flags2;
-			    _IO_funlockfile (stderr);
+                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;
+                            _IO_funlockfile (stderr);
 
-			    free (buf);
-			  }
+                            free (buf);
+                          }
 #else
-			fprintf (stderr, _("\
-%s: option `-W %s' doesn't allow an argument\n"),
-				 argv[0], pfound->name);
-#endif
-		      }
-
-		    d->__nextchar += strlen (d->__nextchar);
-		    return '?';
-		  }
-	      }
-	    else if (pfound->has_arg == 1)
-	      {
-		if (d->optind < argc)
-		  d->optarg = argv[d->optind++];
-		else
-		  {
-		    if (print_errors)
-		      {
+                        fprintf (stderr, _("\
+%s: option '-W %s' doesn't allow an argument\n"),
+                                 argv[0], pfound->name);
+#endif
+                      }
+
+                    d->__nextchar += strlen (d->__nextchar);
+                    return '?';
+                  }
+              }
+            else if (pfound->has_arg == 1)
+              {
+                if (d->optind < argc)
+                  d->optarg = argv[d->optind++];
+                else
+                  {
+                    if (print_errors)
+                      {
 #if defined _LIBC && defined USE_IN_LIBIO
-			char *buf;
+                        char *buf;
 
-			if (__asprintf (&buf, _("\
-%s: option `%s' requires an argument\n"),
-					argv[0], argv[d->optind - 1]) >= 0)
-			  {
-			    _IO_flockfile (stderr);
+                        if (__asprintf (&buf, _("\
+%s: option '-W %s' requires an argument\n"),
+                                        argv[0], pfound->name) >= 0)
+                          {
+                            _IO_flockfile (stderr);
 
-			    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
-			    ((_IO_FILE *) stderr)->_flags2
-			      |= _IO_FLAGS2_NOTCANCEL;
+                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
+                            ((_IO_FILE *) stderr)->_flags2
+                              |= _IO_FLAGS2_NOTCANCEL;
 
-			    __fxprintf (NULL, "%s", buf);
+                            __fxprintf (NULL, "%s", buf);
 
-			    ((_IO_FILE *) stderr)->_flags2 = old_flags2;
-			    _IO_funlockfile (stderr);
+                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;
+                            _IO_funlockfile (stderr);
 
-			    free (buf);
-			  }
+                            free (buf);
+                          }
 #else
-			fprintf (stderr,
-				 _("%s: option `%s' requires an argument\n"),
-				 argv[0], argv[d->optind - 1]);
-#endif
-		      }
-		    d->__nextchar += strlen (d->__nextchar);
-		    return optstring[0] == ':' ? ':' : '?';
-		  }
-	      }
-	    d->__nextchar += strlen (d->__nextchar);
-	    if (longind != NULL)
-	      *longind = option_index;
-	    if (pfound->flag)
-	      {
-		*(pfound->flag) = pfound->val;
-		return 0;
-	      }
-	    return pfound->val;
-	  }
-	  d->__nextchar = NULL;
-	  return 'W';	/* Let the application handle it.   */
+                        fprintf (stderr, _("\
+%s: option '-W %s' requires an argument\n"),
+                                 argv[0], pfound->name);
+#endif
+                      }
+                    d->__nextchar += strlen (d->__nextchar);
+                    return optstring[0] == ':' ? ':' : '?';
+                  }
+              }
+            else
+              d->optarg = NULL;
+            d->__nextchar += strlen (d->__nextchar);
+            if (longind != NULL)
+              *longind = option_index;
+            if (pfound->flag)
+              {
+                *(pfound->flag) = pfound->val;
+                return 0;
+              }
+            return pfound->val;
+          }
+          d->__nextchar = NULL;
+          return 'W';   /* Let the application handle it.   */
       }
     if (temp[1] == ':')
       {
-	if (temp[2] == ':')
-	  {
-	    /* This is an option that accepts an argument optionally.  */
-	    if (*d->__nextchar != '\0')
-	      {
-		d->optarg = d->__nextchar;
-		d->optind++;
-	      }
-	    else
-	      d->optarg = NULL;
-	    d->__nextchar = NULL;
-	  }
-	else
-	  {
-	    /* This is an option that requires an argument.  */
-	    if (*d->__nextchar != '\0')
-	      {
-		d->optarg = d->__nextchar;
-		/* If we end this ARGV-element by taking the rest as an arg,
-		   we must advance to the next element now.  */
-		d->optind++;
-	      }
-	    else if (d->optind == argc)
-	      {
-		if (print_errors)
-		  {
-		    /* 1003.2 specifies the format of this message.  */
+        if (temp[2] == ':')
+          {
+            /* This is an option that accepts an argument optionally.  */
+            if (*d->__nextchar != '\0')
+              {
+                d->optarg = d->__nextchar;
+                d->optind++;
+              }
+            else
+              d->optarg = NULL;
+            d->__nextchar = NULL;
+          }
+        else
+          {
+            /* This is an option that requires an argument.  */
+            if (*d->__nextchar != '\0')
+              {
+                d->optarg = d->__nextchar;
+                /* If we end this ARGV-element by taking the rest as an arg,
+                   we must advance to the next element now.  */
+                d->optind++;
+              }
+            else if (d->optind == argc)
+              {
+                if (print_errors)
+                  {
 #if defined _LIBC && defined USE_IN_LIBIO
-		    char *buf;
+                    char *buf;
 
-		    if (__asprintf (&buf, _("\
-%s: option requires an argument -- %c\n"),
-				    argv[0], c) >= 0)
-		      {
-			_IO_flockfile (stderr);
+                    if (__asprintf (&buf, _("\
+%s: option requires an argument -- '%c'\n"),
+                                    argv[0], c) >= 0)
+                      {
+                        _IO_flockfile (stderr);
 
-			int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
-			((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;
+                        int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
+                        ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;
 
-			__fxprintf (NULL, "%s", buf);
+                        __fxprintf (NULL, "%s", buf);
 
-			((_IO_FILE *) stderr)->_flags2 = old_flags2;
-			_IO_funlockfile (stderr);
+                        ((_IO_FILE *) stderr)->_flags2 = old_flags2;
+                        _IO_funlockfile (stderr);
 
-			free (buf);
-		      }
+                        free (buf);
+                      }
 #else
-		    fprintf (stderr,
-			     _("%s: option requires an argument -- %c\n"),
-			     argv[0], c);
-#endif
-		  }
-		d->optopt = c;
-		if (optstring[0] == ':')
-		  c = ':';
-		else
-		  c = '?';
-	      }
-	    else
-	      /* We already incremented `optind' once;
-		 increment it again when taking next ARGV-elt as argument.  */
-	      d->optarg = argv[d->optind++];
-	    d->__nextchar = NULL;
-	  }
+                    fprintf (stderr,
+                             _("%s: option requires an argument -- '%c'\n"),
+                             argv[0], c);
+#endif
+                  }
+                d->optopt = c;
+                if (optstring[0] == ':')
+                  c = ':';
+                else
+                  c = '?';
+              }
+            else
+              /* We already incremented `optind' once;
+                 increment it again when taking next ARGV-elt as argument.  */
+              d->optarg = argv[d->optind++];
+            d->__nextchar = NULL;
+          }
       }
     return c;
   }
@@ -1081,16 +1073,17 @@ _getopt_internal_r (int argc, char **arg
 
 int
 _getopt_internal (int argc, char **argv, const char *optstring,
-		  const struct option *longopts, int *longind,
-		  int long_only, int posixly_correct)
+                  const struct option *longopts, int *longind, int long_only,
+                  int posixly_correct)
 {
   int result;
 
   getopt_data.optind = optind;
   getopt_data.opterr = opterr;
 
-  result = _getopt_internal_r (argc, argv, optstring, longopts, longind,
-			       long_only, posixly_correct, &getopt_data);
+  result = _getopt_internal_r (argc, argv, optstring, longopts,
+                               longind, long_only, &getopt_data,
+                               posixly_correct);
 
   optind = getopt_data.optind;
   optarg = getopt_data.optarg;
@@ -1110,10 +1103,23 @@ enum { POSIXLY_CORRECT = 1 };
 int
 getopt (int argc, char *const *argv, const char *optstring)
 {
-  return _getopt_internal (argc, (char **) argv, optstring, NULL, NULL, 0,
-			   POSIXLY_CORRECT);
+  return _getopt_internal (argc, (char **) argv, optstring,
+                           (const struct option *) 0,
+                           (int *) 0,
+                           0, POSIXLY_CORRECT);
 }
 
+#ifdef _LIBC
+int
+__posix_getopt (int argc, char *const *argv, const char *optstring)
+{
+  return _getopt_internal (argc, argv, optstring,
+                           (const struct option *) 0,
+                           (int *) 0,
+                           0, 1);
+}
+#endif
+
 
 #ifdef TEST
 
@@ -1132,51 +1138,51 @@ main (int argc, char **argv)
 
       c = getopt (argc, argv, "abc:d:0123456789");
       if (c == -1)
-	break;
+        break;
 
       switch (c)
-	{
-	case '0':
-	case '1':
-	case '2':
-	case '3':
-	case '4':
-	case '5':
-	case '6':
-	case '7':
-	case '8':
-	case '9':
-	  if (digit_optind != 0 && digit_optind != this_option_optind)
-	    printf ("digits occur in two different argv-elements.\n");
-	  digit_optind = this_option_optind;
-	  printf ("option %c\n", c);
-	  break;
-
-	case 'a':
-	  printf ("option a\n");
-	  break;
-
-	case 'b':
-	  printf ("option b\n");
-	  break;
-
-	case 'c':
-	  printf ("option c with value `%s'\n", optarg);
-	  break;
-
-	case '?':
-	  break;
-
-	default:
-	  printf ("?? getopt returned character code 0%o ??\n", c);
-	}
+        {
+        case '0':
+        case '1':
+        case '2':
+        case '3':
+        case '4':
+        case '5':
+        case '6':
+        case '7':
+        case '8':
+        case '9':
+          if (digit_optind != 0 && digit_optind != this_option_optind)
+            printf ("digits occur in two different argv-elements.\n");
+          digit_optind = this_option_optind;
+          printf ("option %c\n", c);
+          break;
+
+        case 'a':
+          printf ("option a\n");
+          break;
+
+        case 'b':
+          printf ("option b\n");
+          break;
+
+        case 'c':
+          printf ("option c with value '%s'\n", optarg);
+          break;
+
+        case '?':
+          break;
+
+        default:
+          printf ("?? getopt returned character code 0%o ??\n", c);
+        }
     }
 
   if (optind < argc)
     {
       printf ("non-option ARGV-elements: ");
       while (optind < argc)
-	printf ("%s ", argv[optind++]);
+        printf ("%s ", argv[optind++]);
       printf ("\n");
     }
 
--- a/gl/getopt.in.h
+++ b/gl/getopt.in.h
@@ -1,6 +1,6 @@
 /* Declarations for getopt.
-   Copyright (C) 1989-1994,1996-1999,2001,2003,2004,2005,2006,2007
-   Free Software Foundation, Inc.
+   Copyright (C) 1989-1994, 1996-1999, 2001, 2003-2007, 2009-2010 Free Software
+   Foundation, Inc.
    This file is part of the GNU C Library.
 
    This program is free software: you can redistribute it and/or modify
@@ -16,24 +16,42 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
-#ifndef _GETOPT_H
+#ifndef _GL_GETOPT_H
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+/* The include_next requires a split double-inclusion guard.  We must
+   also inform the replacement unistd.h to not recursively use
+   <getopt.h>; our definitions will be present soon enough.  */
+#if @HAVE_GETOPT_H@
+# define _GL_SYSTEM_GETOPT
+# @INCLUDE_NEXT@ @NEXT_GETOPT_H@
+# undef _GL_SYSTEM_GETOPT
+#endif
+
+#ifndef _GL_GETOPT_H
 
 #ifndef __need_getopt
-# define _GETOPT_H 1
+# define _GL_GETOPT_H 1
 #endif
 
 /* Standalone applications should #define __GETOPT_PREFIX to an
    identifier that prefixes the external functions and variables
    defined in this header.  When this happens, include the
    headers that might declare getopt so that they will not cause
-   confusion if included after this file.  Then systematically rename
+   confusion if included after this file (if the system had <getopt.h>,
+   we have already included it).  Then systematically rename
    identifiers so that they do not collide with the system functions
    and variables.  Renaming avoids problems with some compilers and
    linkers.  */
 #if defined __GETOPT_PREFIX && !defined __need_getopt
-# include <stdlib.h>
-# include <stdio.h>
-# include <unistd.h>
+# if !@HAVE_GETOPT_H@
+#  include <stdlib.h>
+#  include <stdio.h>
+#  include <unistd.h>
+# endif
 # undef __need_getopt
 # undef getopt
 # undef getopt_long
@@ -42,6 +60,7 @@
 # undef opterr
 # undef optind
 # undef optopt
+# undef option
 # define __GETOPT_CONCAT(x, y) x ## y
 # define __GETOPT_XCONCAT(x, y) __GETOPT_CONCAT (x, y)
 # define __GETOPT_ID(y) __GETOPT_XCONCAT (__GETOPT_PREFIX, y)
@@ -52,6 +71,8 @@
 # define opterr __GETOPT_ID (opterr)
 # define optind __GETOPT_ID (optind)
 # define optopt __GETOPT_ID (optopt)
+# define option __GETOPT_ID (option)
+# define _getopt_internal __GETOPT_ID (getopt_internal)
 #endif
 
 /* Standalone applications get correct prototypes for getopt_long and
@@ -94,12 +115,14 @@
 #  define __GNUC_PREREQ(maj, min) (0)
 # endif
 # if defined __cplusplus && __GNUC_PREREQ (2,8)
-#  define __THROW	throw ()
+#  define __THROW       throw ()
 # else
 #  define __THROW
 # endif
 #endif
 
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -142,9 +165,9 @@ extern int optopt;
    zero.
 
    The field `has_arg' is:
-   no_argument		(or 0) if the option does not take an argument,
-   required_argument	(or 1) if the option requires an argument,
-   optional_argument	(or 2) if the option takes an optional argument.
+   no_argument          (or 0) if the option does not take an argument,
+   required_argument    (or 1) if the option requires an argument,
+   optional_argument    (or 2) if the option takes an optional argument.
 
    If the field `flag' is not NULL, it points to a variable that is set
    to the value given in the field `val' when the option is found, but
@@ -169,10 +192,10 @@ struct option
 
 /* Names for the values of the `has_arg' field of `struct option'.  */
 
-# define no_argument		0
-# define required_argument	1
-# define optional_argument	2
-#endif	/* need getopt */
+# define no_argument            0
+# define required_argument      1
+# define optional_argument      2
+#endif  /* need getopt */
 
 
 /* Get definitions and prototypes for functions to process the
@@ -201,17 +224,17 @@ struct option
    the environment, then do not permute arguments.  */
 
 extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
-       __THROW;
+       __THROW _GL_ARG_NONNULL ((2, 3));
 
 #ifndef __need_getopt
 extern int getopt_long (int ___argc, char *__getopt_argv_const *___argv,
-			const char *__shortopts,
-		        const struct option *__longopts, int *__longind)
-       __THROW;
+                        const char *__shortopts,
+                        const struct option *__longopts, int *__longind)
+       __THROW _GL_ARG_NONNULL ((2, 3));
 extern int getopt_long_only (int ___argc, char *__getopt_argv_const *___argv,
-			     const char *__shortopts,
-		             const struct option *__longopts, int *__longind)
-       __THROW;
+                             const char *__shortopts,
+                             const struct option *__longopts, int *__longind)
+       __THROW _GL_ARG_NONNULL ((2, 3));
 
 #endif
 
@@ -223,3 +246,4 @@ extern int getopt_long_only (int ___argc
 #undef __need_getopt
 
 #endif /* getopt.h */
+#endif /* getopt.h */
--- a/gl/getopt1.c
+++ b/gl/getopt1.c
@@ -1,6 +1,6 @@
 /* getopt_long and getopt_long_only entry points for GNU getopt.
-   Copyright (C) 1987,88,89,90,91,92,93,94,96,97,98,2004,2006,2009
-     Free Software Foundation, Inc.
+   Copyright (C) 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1996, 1997,
+   1998, 2004, 2006, 2009, 2010 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    This program is free software: you can redistribute it and/or modify
@@ -32,25 +32,25 @@
 #include <stdlib.h>
 #endif
 
-#ifndef	NULL
+#ifndef NULL
 #define NULL 0
 #endif
 
 int
 getopt_long (int argc, char *__getopt_argv_const *argv, const char *options,
-	     const struct option *long_options, int *opt_index)
+             const struct option *long_options, int *opt_index)
 {
   return _getopt_internal (argc, (char **) argv, options, long_options,
-			   opt_index, 0, 0);
+                           opt_index, 0, 0);
 }
 
 int
 _getopt_long_r (int argc, char **argv, const char *options,
-		const struct option *long_options, int *opt_index,
-		struct _getopt_data *d)
+                const struct option *long_options, int *opt_index,
+                struct _getopt_data *d)
 {
   return _getopt_internal_r (argc, argv, options, long_options, opt_index,
-			     0, 0, d);
+                             0, d, 0);
 }
 
 /* Like getopt_long, but '-' as well as '--' can indicate a long option.
@@ -60,20 +60,20 @@ _getopt_long_r (int argc, char **argv, c
 
 int
 getopt_long_only (int argc, char *__getopt_argv_const *argv,
-		  const char *options,
-		  const struct option *long_options, int *opt_index)
+                  const char *options,
+                  const struct option *long_options, int *opt_index)
 {
   return _getopt_internal (argc, (char **) argv, options, long_options,
-			   opt_index, 1, 0);
+                           opt_index, 1, 0);
 }
 
 int
 _getopt_long_only_r (int argc, char **argv, const char *options,
-		     const struct option *long_options, int *opt_index,
-		     struct _getopt_data *d)
+                     const struct option *long_options, int *opt_index,
+                     struct _getopt_data *d)
 {
   return _getopt_internal_r (argc, argv, options, long_options, opt_index,
-			     1, 0, d);
+                             1, d, 0);
 }
 
 
@@ -93,74 +93,74 @@ main (int argc, char **argv)
       int option_index = 0;
       static const struct option long_options[] =
       {
-	{"add", 1, 0, 0},
-	{"append", 0, 0, 0},
-	{"delete", 1, 0, 0},
-	{"verbose", 0, 0, 0},
-	{"create", 0, 0, 0},
-	{"file", 1, 0, 0},
-	{0, 0, 0, 0}
+        {"add", 1, 0, 0},
+        {"append", 0, 0, 0},
+        {"delete", 1, 0, 0},
+        {"verbose", 0, 0, 0},
+        {"create", 0, 0, 0},
+        {"file", 1, 0, 0},
+        {0, 0, 0, 0}
       };
 
       c = getopt_long (argc, argv, "abc:d:0123456789",
-		       long_options, &option_index);
+                       long_options, &option_index);
       if (c == -1)
-	break;
+        break;
 
       switch (c)
-	{
-	case 0:
-	  printf ("option %s", long_options[option_index].name);
-	  if (optarg)
-	    printf (" with arg %s", optarg);
-	  printf ("\n");
-	  break;
-
-	case '0':
-	case '1':
-	case '2':
-	case '3':
-	case '4':
-	case '5':
-	case '6':
-	case '7':
-	case '8':
-	case '9':
-	  if (digit_optind != 0 && digit_optind != this_option_optind)
-	    printf ("digits occur in two different argv-elements.\n");
-	  digit_optind = this_option_optind;
-	  printf ("option %c\n", c);
-	  break;
-
-	case 'a':
-	  printf ("option a\n");
-	  break;
-
-	case 'b':
-	  printf ("option b\n");
-	  break;
-
-	case 'c':
-	  printf ("option c with value `%s'\n", optarg);
-	  break;
-
-	case 'd':
-	  printf ("option d with value `%s'\n", optarg);
-	  break;
-
-	case '?':
-	  break;
-
-	default:
-	  printf ("?? getopt returned character code 0%o ??\n", c);
-	}
+        {
+        case 0:
+          printf ("option %s", long_options[option_index].name);
+          if (optarg)
+            printf (" with arg %s", optarg);
+          printf ("\n");
+          break;
+
+        case '0':
+        case '1':
+        case '2':
+        case '3':
+        case '4':
+        case '5':
+        case '6':
+        case '7':
+        case '8':
+        case '9':
+          if (digit_optind != 0 && digit_optind != this_option_optind)
+            printf ("digits occur in two different argv-elements.\n");
+          digit_optind = this_option_optind;
+          printf ("option %c\n", c);
+          break;
+
+        case 'a':
+          printf ("option a\n");
+          break;
+
+        case 'b':
+          printf ("option b\n");
+          break;
+
+        case 'c':
+          printf ("option c with value `%s'\n", optarg);
+          break;
+
+        case 'd':
+          printf ("option d with value `%s'\n", optarg);
+          break;
+
+        case '?':
+          break;
+
+        default:
+          printf ("?? getopt returned character code 0%o ??\n", c);
+        }
     }
 
   if (optind < argc)
     {
       printf ("non-option ARGV-elements: ");
       while (optind < argc)
-	printf ("%s ", argv[optind++]);
+        printf ("%s ", argv[optind++]);
       printf ("\n");
     }
 
--- a/gl/getopt_int.h
+++ b/gl/getopt_int.h
@@ -1,6 +1,6 @@
 /* Internal declarations for getopt.
-   Copyright (C) 1989-1994,1996-1999,2001,2003,2004
-   Free Software Foundation, Inc.
+   Copyright (C) 1989-1994, 1996-1999, 2001, 2003-2004, 2009-2010 Free Software
+   Foundation, Inc.
    This file is part of the GNU C Library.
 
    This program is free software: you can redistribute it and/or modify
@@ -17,17 +17,53 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 #ifndef _GETOPT_INT_H
-#define _GETOPT_INT_H	1
+#define _GETOPT_INT_H   1
+
+#include <getopt.h>
 
 extern int _getopt_internal (int ___argc, char **___argv,
-			     const char *__shortopts,
-		             const struct option *__longopts, int *__longind,
-			     int __long_only, int __posixly_correct);
+                             const char *__shortopts,
+                             const struct option *__longopts, int *__longind,
+                             int __long_only, int __posixly_correct);
 
 
 /* Reentrant versions which can handle parsing multiple argument
    vectors at the same time.  */
 
+/* Describe how to deal with options that follow non-option ARGV-elements.
+
+   If the caller did not specify anything,
+   the default is REQUIRE_ORDER if the environment variable
+   POSIXLY_CORRECT is defined, PERMUTE otherwise.
+
+   REQUIRE_ORDER means don't recognize them as options;
+   stop option processing when the first non-option is seen.
+   This is what Unix does.
+   This mode of operation is selected by either setting the environment
+   variable POSIXLY_CORRECT, or using `+' as the first character
+   of the list of option characters, or by calling getopt.
+
+   PERMUTE is the default.  We permute the contents of ARGV as we
+   scan, so that eventually all the non-options are at the end.
+   This allows options to be given in any order, even with programs
+   that were not written to expect this.
+
+   RETURN_IN_ORDER is an option available to programs that were
+   written to expect options and other ARGV-elements in any order
+   and that care about the ordering of the two.  We describe each
+   non-option ARGV-element as if it were the argument of an option
+   with character code 1.  Using `-' as the first character of the
+   list of option characters selects this mode of operation.
+
+   The special argument `--' forces an end of option-scanning regardless
+   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
+   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
+
+enum __ord
+  {
+    REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
+  };
+
 /* Data type for reentrant functions.  */
 struct _getopt_data
 {
@@ -52,39 +88,8 @@ struct _getopt_data
      by advancing to the next ARGV-element.  */
   char *__nextchar;
 
-  /* Describe how to deal with options that follow non-option ARGV-elements.
-
-     If the caller did not specify anything,
-     the default is REQUIRE_ORDER if the environment variable
-     POSIXLY_CORRECT is defined, PERMUTE otherwise.
-
-     REQUIRE_ORDER means don't recognize them as options;
-     stop option processing when the first non-option is seen.
-     This is what Unix does.
-     This mode of operation is selected by either setting the environment
-     variable POSIXLY_CORRECT, or using `+' as the first character
-     of the list of option characters, or by calling getopt.
-
-     PERMUTE is the default.  We permute the contents of ARGV as we
-     scan, so that eventually all the non-options are at the end.
-     This allows options to be given in any order, even with programs
-     that were not written to expect this.
-
-     RETURN_IN_ORDER is an option available to programs that were
-     written to expect options and other ARGV-elements in any order
-     and that care about the ordering of the two.  We describe each
-     non-option ARGV-element as if it were the argument of an option
-     with character code 1.  Using `-' as the first character of the
-     list of option characters selects this mode of operation.
-
-     The special argument `--' forces an end of option-scanning regardless
-     of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
-     `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
-
-  enum
-    {
-      REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
-    } __ordering;
+  /* See __ord above.  */
+  enum __ord __ordering;
 
   /* If the POSIXLY_CORRECT environment variable is set
      or getopt was called.  */
@@ -108,23 +113,23 @@ struct _getopt_data
 
 /* The initializer is necessary to set OPTIND and OPTERR to their
    default values and to clear the initialization flag.  */
-#define _GETOPT_DATA_INITIALIZER	{ 1, 1 }
+#define _GETOPT_DATA_INITIALIZER        { 1, 1 }
 
 extern int _getopt_internal_r (int ___argc, char **___argv,
-			       const char *__shortopts,
-			       const struct option *__longopts, int *__longind,
-			       int __long_only, int __posixly_correct,
-			       struct _getopt_data *__data);
+                               const char *__shortopts,
+                               const struct option *__longopts, int *__longind,
+                               int __long_only, struct _getopt_data *__data,
+                               int __posixly_correct);
 
 extern int _getopt_long_r (int ___argc, char **___argv,
-			   const char *__shortopts,
-			   const struct option *__longopts, int *__longind,
-			   struct _getopt_data *__data);
+                           const char *__shortopts,
+                           const struct option *__longopts, int *__longind,
+                           struct _getopt_data *__data);
 
 extern int _getopt_long_only_r (int ___argc, char **___argv,
-				const char *__shortopts,
-				const struct option *__longopts,
-				int *__longind,
-				struct _getopt_data *__data);
+                                const char *__shortopts,
+                                const struct option *__longopts,
+                                int *__longind,
+                                struct _getopt_data *__data);
 
 #endif /* getopt_int.h */
--- a/gl/gettext.h
+++ b/gl/gettext.h
@@ -1,5 +1,6 @@
 /* Convenience header for conditional use of GNU <libintl.h>.
-   Copyright (C) 1995-1998, 2000-2002, 2004-2006, 2009 Free Software Foundation, Inc.
+   Copyright (C) 1995-1998, 2000-2002, 2004-2006, 2009-2010 Free Software
+   Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -80,7 +81,7 @@
     ((void) (Domainname), ngettext (Msgid1, Msgid2, N))
 # undef dcngettext
 # define dcngettext(Domainname, Msgid1, Msgid2, N, Category) \
-    ((void) (Category), dngettext(Domainname, Msgid1, Msgid2, N))
+    ((void) (Category), dngettext (Domainname, Msgid1, Msgid2, N))
 # undef textdomain
 # define textdomain(Domainname) ((const char *) (Domainname))
 # undef bindtextdomain
@@ -140,8 +141,8 @@ inline
 #endif
 static const char *
 pgettext_aux (const char *domain,
-	      const char *msg_ctxt_id, const char *msgid,
-	      int category)
+              const char *msg_ctxt_id, const char *msgid,
+              int category)
 {
   const char *translation = dcgettext (domain, msg_ctxt_id, category);
   if (translation == msg_ctxt_id)
@@ -159,9 +160,9 @@ inline
 #endif
 static const char *
 npgettext_aux (const char *domain,
-	       const char *msg_ctxt_id, const char *msgid,
-	       const char *msgid_plural, unsigned long int n,
-	       int category)
+               const char *msg_ctxt_id, const char *msgid,
+               const char *msgid_plural, unsigned long int n,
+               int category)
 {
   const char *translation =
     dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);
@@ -171,4 +172,109 @@ npgettext_aux (const char *domain,
     return translation;
 }
 
+/* The same thing extended for non-constant arguments.  Here MSGCTXT and MSGID
+   can be arbitrary expressions.  But for string literals these macros are
+   less efficient than those above.  */
+
+#include <string.h>
+
+#define _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS \
+  (((__GNUC__ >= 3 || __GNUG__ >= 2) && !__STRICT_ANSI__) \
+   /* || __STDC_VERSION__ >= 199901L */ )
+
+#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
+#include <stdlib.h>
+#endif
+
+#define pgettext_expr(Msgctxt, Msgid) \
+  dcpgettext_expr (NULL, Msgctxt, Msgid, LC_MESSAGES)
+#define dpgettext_expr(Domainname, Msgctxt, Msgid) \
+  dcpgettext_expr (Domainname, Msgctxt, Msgid, LC_MESSAGES)
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static const char *
+dcpgettext_expr (const char *domain,
+                 const char *msgctxt, const char *msgid,
+                 int category)
+{
+  size_t msgctxt_len = strlen (msgctxt) + 1;
+  size_t msgid_len = strlen (msgid) + 1;
+  const char *translation;
+#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
+  char msg_ctxt_id[msgctxt_len + msgid_len];
+#else
+  char buf[1024];
+  char *msg_ctxt_id =
+    (msgctxt_len + msgid_len <= sizeof (buf)
+     ? buf
+     : (char *) malloc (msgctxt_len + msgid_len));
+  if (msg_ctxt_id != NULL)
+#endif
+    {
+      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);
+      msg_ctxt_id[msgctxt_len - 1] = '\004';
+      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);
+      translation = dcgettext (domain, msg_ctxt_id, category);
+#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
+      if (msg_ctxt_id != buf)
+        free (msg_ctxt_id);
+#endif
+      if (translation != msg_ctxt_id)
+        return translation;
+    }
+  return msgid;
+}
+
+#define npgettext_expr(Msgctxt, Msgid, MsgidPlural, N) \
+  dcnpgettext_expr (NULL, Msgctxt, Msgid, MsgidPlural, N, LC_MESSAGES)
+#define dnpgettext_expr(Domainname, Msgctxt, Msgid, MsgidPlural, N) \
+  dcnpgettext_expr (Domainname, Msgctxt, Msgid, MsgidPlural, N, LC_MESSAGES)
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static const char *
+dcnpgettext_expr (const char *domain,
+                  const char *msgctxt, const char *msgid,
+                  const char *msgid_plural, unsigned long int n,
+                  int category)
+{
+  size_t msgctxt_len = strlen (msgctxt) + 1;
+  size_t msgid_len = strlen (msgid) + 1;
+  const char *translation;
+#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
+  char msg_ctxt_id[msgctxt_len + msgid_len];
+#else
+  char buf[1024];
+  char *msg_ctxt_id =
+    (msgctxt_len + msgid_len <= sizeof (buf)
+     ? buf
+     : (char *) malloc (msgctxt_len + msgid_len));
+  if (msg_ctxt_id != NULL)
+#endif
+    {
+      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);
+      msg_ctxt_id[msgctxt_len - 1] = '\004';
+      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);
+      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);
+#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
+      if (msg_ctxt_id != buf)
+        free (msg_ctxt_id);
+#endif
+      if (!(translation == msg_ctxt_id || translation == msgid_plural))
+        return translation;
+    }
+  return (n == 1 ? msgid : msgid_plural);
+}
+
 #endif /* _LIBGETTEXT_H */
--- a/gl/intprops.h
+++ b/gl/intprops.h
@@ -1,6 +1,7 @@
 /* intprops.h -- properties of integer types
 
-   Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2009, 2010 Free Software
+   Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -17,40 +18,43 @@
 
 /* Written by Paul Eggert.  */
 
-#include <limits.h>
+#ifndef GL_INTPROPS_H
+# define GL_INTPROPS_H
+
+# include <limits.h>
 
 /* The extra casts in the following macros work around compiler bugs,
    e.g., in Cray C 5.0.3.0.  */
 
 /* True if the arithmetic type T is an integer type.  bool counts as
    an integer.  */
-#define TYPE_IS_INTEGER(t) ((t) 1.5 == 1)
+# define TYPE_IS_INTEGER(t) ((t) 1.5 == 1)
 
 /* True if negative values of the signed integer type T use two's
    complement, ones' complement, or signed magnitude representation,
    respectively.  Much GNU code assumes two's complement, but some
    people like to be portable to all possible C hosts.  */
-#define TYPE_TWOS_COMPLEMENT(t) ((t) ~ (t) 0 == (t) -1)
-#define TYPE_ONES_COMPLEMENT(t) ((t) ~ (t) 0 == 0)
-#define TYPE_SIGNED_MAGNITUDE(t) ((t) ~ (t) 0 < (t) -1)
+# define TYPE_TWOS_COMPLEMENT(t) ((t) ~ (t) 0 == (t) -1)
+# define TYPE_ONES_COMPLEMENT(t) ((t) ~ (t) 0 == 0)
+# define TYPE_SIGNED_MAGNITUDE(t) ((t) ~ (t) 0 < (t) -1)
 
 /* True if the arithmetic type T is signed.  */
-#define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
+# define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
 
 /* The maximum and minimum values for the integer type T.  These
    macros have undefined behavior if T is signed and has padding bits.
    If this is a problem for you, please let us know how to fix it for
    your host.  */
-#define TYPE_MINIMUM(t) \
+# define TYPE_MINIMUM(t) \
   ((t) (! TYPE_SIGNED (t) \
-	? (t) 0 \
-	: TYPE_SIGNED_MAGNITUDE (t) \
-	? ~ (t) 0 \
-	: ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1)))
-#define TYPE_MAXIMUM(t) \
+        ? (t) 0 \
+        : TYPE_SIGNED_MAGNITUDE (t) \
+        ? ~ (t) 0 \
+        : ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1)))
+# define TYPE_MAXIMUM(t) \
   ((t) (! TYPE_SIGNED (t) \
-	? (t) -1 \
-	: ~ (~ (t) 0 << (sizeof (t) * CHAR_BIT - 1))))
+        ? (t) -1 \
+        : ~ (~ (t) 0 << (sizeof (t) * CHAR_BIT - 1))))
 
 /* Return zero if T can be determined to be an unsigned type.
    Otherwise, return 1.
@@ -58,20 +62,22 @@
    tighter bound.  Otherwise, it overestimates the true bound by one byte
    when applied to unsigned types of size 2, 4, 16, ... bytes.
    The symbol signed_type_or_expr__ is private to this header file.  */
-#if __GNUC__ >= 2
-# define signed_type_or_expr__(t) TYPE_SIGNED (__typeof__ (t))
-#else
-# define signed_type_or_expr__(t) 1
-#endif
+# if __GNUC__ >= 2
+#  define signed_type_or_expr__(t) TYPE_SIGNED (__typeof__ (t))
+# else
+#  define signed_type_or_expr__(t) 1
+# endif
 
 /* Bound on length of the string representing an integer type or expression T.
    Subtract 1 for the sign bit if T is signed; log10 (2.0) < 146/485;
    add 1 for integer division truncation; add 1 more for a minus sign
    if needed.  */
-#define INT_STRLEN_BOUND(t) \
+# define INT_STRLEN_BOUND(t) \
   ((sizeof (t) * CHAR_BIT - signed_type_or_expr__ (t)) * 146 / 485 \
    + signed_type_or_expr__ (t) + 1)
 
 /* Bound on buffer size needed to represent an integer type or expression T,
    including the terminating null.  */
-#define INT_BUFSIZE_BOUND(t) (INT_STRLEN_BOUND (t) + 1)
+# define INT_BUFSIZE_BOUND(t) (INT_STRLEN_BOUND (t) + 1)
+
+#endif /* GL_INTPROPS_H */
--- a/gl/m4/00gnulib.m4
+++ b/gl/m4/00gnulib.m4
@@ -1,5 +1,5 @@
 # 00gnulib.m4 serial 2
-dnl Copyright (C) 2009 Free Software Foundation, Inc.
+dnl Copyright (C) 2009-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
--- /dev/null
+++ b/gl/m4/alloca.m4
@@ -0,0 +1,47 @@
+# alloca.m4 serial 9
+dnl Copyright (C) 2002-2004, 2006-2007, 2009-2010 Free Software Foundation,
+dnl Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FUNC_ALLOCA],
+[
+  dnl Work around a bug of AC_EGREP_CPP in autoconf-2.57.
+  AC_REQUIRE([AC_PROG_CPP])
+  AC_REQUIRE([AC_PROG_EGREP])
+
+  AC_REQUIRE([AC_FUNC_ALLOCA])
+  if test $ac_cv_func_alloca_works = no; then
+    gl_PREREQ_ALLOCA
+  fi
+
+  # Define an additional variable used in the Makefile substitution.
+  if test $ac_cv_working_alloca_h = yes; then
+    AC_CACHE_CHECK([for alloca as a compiler built-in], [gl_cv_rpl_alloca], [
+      AC_EGREP_CPP([Need own alloca], [
+#if defined __GNUC__ || defined _AIX || defined _MSC_VER
+        Need own alloca
+#endif
+        ], [gl_cv_rpl_alloca=yes], [gl_cv_rpl_alloca=no])
+    ])
+    if test $gl_cv_rpl_alloca = yes; then
+      dnl OK, alloca can be implemented through a compiler built-in.
+      AC_DEFINE([HAVE_ALLOCA], [1],
+        [Define to 1 if you have 'alloca' after including <alloca.h>,
+         a header that may be supplied by this distribution.])
+      ALLOCA_H=alloca.h
+    else
+      dnl alloca exists as a library function, i.e. it is slow and probably
+      dnl a memory leak. Don't define HAVE_ALLOCA in this case.
+      ALLOCA_H=
+    fi
+  else
+    ALLOCA_H=alloca.h
+  fi
+  AC_SUBST([ALLOCA_H])
+])
+
+# Prerequisites of lib/alloca.c.
+# STACK_DIRECTION is already handled by AC_FUNC_ALLOCA.
+AC_DEFUN([gl_PREREQ_ALLOCA], [:])
--- a/gl/m4/autobuild.m4
+++ b/gl/m4/autobuild.m4
@@ -1,5 +1,6 @@
 # autobuild.m4 serial 7
-dnl Copyright (C) 2004, 2006, 2007, 2008 Free Software Foundation, Inc.
+dnl Copyright (C) 2004, 2006, 2007, 2008, 2009, 2010 Free Software Foundation,
+dnl Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
--- a/gl/m4/csharp.m4
+++ b/gl/m4/csharp.m4
@@ -1,5 +1,5 @@
 # csharp.m4 serial 3
-dnl Copyright (C) 2004-2005, 2009 Free Software Foundation, Inc.
+dnl Copyright (C) 2004-2005, 2009-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
--- a/gl/m4/csharpcomp.m4
+++ b/gl/m4/csharpcomp.m4
@@ -1,5 +1,5 @@
 # csharpcomp.m4 serial 8
-dnl Copyright (C) 2003-2005, 2007, 2009 Free Software Foundation, Inc.
+dnl Copyright (C) 2003-2005, 2007, 2009-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
--- /dev/null
+++ b/gl/m4/dos.m4
@@ -0,0 +1,71 @@
+#serial 11   -*- autoconf -*-
+
+# Define some macros required for proper operation of code in lib/*.c
+# on MSDOS/Windows systems.
+
+# Copyright (C) 2000-2001, 2004-2006, 2009-2010 Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# From Jim Meyering.
+
+AC_DEFUN([gl_AC_DOS],
+  [
+    AC_CACHE_CHECK([whether system is Windows or MSDOS], [ac_cv_win_or_dos],
+      [
+        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [[
+#if !defined _WIN32 && !defined __WIN32__ && !defined __MSDOS__ && !defined __CYGWIN__
+neither MSDOS nor Windows
+#endif]])],
+        [ac_cv_win_or_dos=yes],
+        [ac_cv_win_or_dos=no])
+      ])
+
+    if test x"$ac_cv_win_or_dos" = xyes; then
+      ac_fs_accepts_drive_letter_prefix=1
+      ac_fs_backslash_is_file_name_separator=1
+      AC_CACHE_CHECK([whether drive letter can start relative path],
+                     [ac_cv_drive_letter_can_be_relative],
+        [
+          AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [[
+#if defined __CYGWIN__
+drive letters are always absolute
+#endif]])],
+          [ac_cv_drive_letter_can_be_relative=yes],
+          [ac_cv_drive_letter_can_be_relative=no])
+        ])
+      if test x"$ac_cv_drive_letter_can_be_relative" = xyes; then
+        ac_fs_drive_letter_can_be_relative=1
+      else
+        ac_fs_drive_letter_can_be_relative=0
+      fi
+    else
+      ac_fs_accepts_drive_letter_prefix=0
+      ac_fs_backslash_is_file_name_separator=0
+      ac_fs_drive_letter_can_be_relative=0
+    fi
+
+    AC_DEFINE_UNQUOTED([FILE_SYSTEM_ACCEPTS_DRIVE_LETTER_PREFIX],
+      $ac_fs_accepts_drive_letter_prefix,
+      [Define on systems for which file names may have a so-called
+       `drive letter' prefix, define this to compute the length of that
+       prefix, including the colon.])
+
+    AH_VERBATIM(ISSLASH,
+    [#if FILE_SYSTEM_BACKSLASH_IS_FILE_NAME_SEPARATOR
+# define ISSLASH(C) ((C) == '/' || (C) == '\\')
+#else
+# define ISSLASH(C) ((C) == '/')
+#endif])
+
+    AC_DEFINE_UNQUOTED([FILE_SYSTEM_BACKSLASH_IS_FILE_NAME_SEPARATOR],
+      $ac_fs_backslash_is_file_name_separator,
+      [Define if the backslash character may also serve as a file name
+       component separator.])
+
+    AC_DEFINE_UNQUOTED([FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE],
+      $ac_fs_drive_letter_can_be_relative,
+      [Define if a drive letter prefix denotes a relative path if it is
+       not followed by a file name component separator.])
+  ])
--- /dev/null
+++ b/gl/m4/dup2.m4
@@ -0,0 +1,58 @@
+#serial 10
+dnl Copyright (C) 2002, 2005, 2007, 2009-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FUNC_DUP2],
+[
+  AC_REQUIRE([gl_UNISTD_H_DEFAULTS])
+  AC_REQUIRE([AC_CANONICAL_HOST])
+  AC_CHECK_FUNCS_ONCE([dup2])
+  if test $ac_cv_func_dup2 = no; then
+    HAVE_DUP2=0
+    AC_LIBOBJ([dup2])
+  else
+    AC_CACHE_CHECK([whether dup2 works], [gl_cv_func_dup2_works],
+      [AC_RUN_IFELSE([
+         AC_LANG_PROGRAM([[#include <unistd.h>
+#include <errno.h>]],
+           [if (dup2 (1, 1) == 0)
+              return 1;
+            close (0);
+            if (dup2 (0, 0) != -1)
+              return 2;
+            /* Many gnulib modules require POSIX conformance of EBADF.  */
+            if (dup2 (1, 1000000) == -1 && errno != EBADF)
+              return 3;
+            return 0;
+           ])
+        ],
+        [gl_cv_func_dup2_works=yes], [gl_cv_func_dup2_works=no],
+        [case "$host_os" in
+           mingw*) # on this platform, dup2 always returns 0 for success
+             gl_cv_func_dup2_works=no;;
+           cygwin*) # on cygwin 1.5.x, dup2(1,1) returns 0
+             gl_cv_func_dup2_works=no;;
+           linux*) # On linux between 2008-07-27 and 2009-05-11, dup2 of a
+                   # closed fd may yield -EBADF instead of -1 / errno=EBADF.
+             gl_cv_func_dup2_works=no;;
+           freebsd*) # on FreeBSD 6.1, dup2(1,1000000) gives EMFILE, not EBADF.
+             gl_cv_func_dup2_works=no;;
+           *) gl_cv_func_dup2_works=yes;;
+         esac])
+      ])
+    if test "$gl_cv_func_dup2_works" = no; then
+      gl_REPLACE_DUP2
+    fi
+  fi
+])
+
+AC_DEFUN([gl_REPLACE_DUP2],
+[
+  AC_REQUIRE([gl_UNISTD_H_DEFAULTS])
+  if test $ac_cv_func_dup2 = yes; then
+    REPLACE_DUP2=1
+  fi
+  AC_LIBOBJ([dup2])
+])
--- /dev/null
+++ b/gl/m4/eealloc.m4
@@ -0,0 +1,32 @@
+# eealloc.m4 serial 2
+dnl Copyright (C) 2003, 2009, 2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_EEALLOC],
+[
+  AC_REQUIRE([gl_EEMALLOC])
+  AC_REQUIRE([gl_EEREALLOC])
+  AC_REQUIRE([AC_C_INLINE])
+])
+
+AC_DEFUN([gl_EEMALLOC],
+[
+  _AC_FUNC_MALLOC_IF(
+    [gl_cv_func_malloc_0_nonnull=1],
+    [gl_cv_func_malloc_0_nonnull=0])
+  AC_DEFINE_UNQUOTED([MALLOC_0_IS_NONNULL], [$gl_cv_func_malloc_0_nonnull],
+    [If malloc(0) is != NULL, define this to 1.  Otherwise define this
+     to 0.])
+])
+
+AC_DEFUN([gl_EEREALLOC],
+[
+  _AC_FUNC_REALLOC_IF(
+    [gl_cv_func_realloc_0_nonnull=1],
+    [gl_cv_func_realloc_0_nonnull=0])
+  AC_DEFINE_UNQUOTED([REALLOC_0_IS_NONNULL], [$gl_cv_func_realloc_0_nonnull],
+    [If realloc(NULL,0) is != NULL, define this to 1.  Otherwise define this
+     to 0.])
+])
--- /dev/null
+++ b/gl/m4/environ.m4
@@ -0,0 +1,36 @@
+# environ.m4 serial 4
+dnl Copyright (C) 2001-2004, 2006-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN_ONCE([gl_ENVIRON],
+[
+  AC_REQUIRE([gl_UNISTD_H_DEFAULTS])
+  dnl Persuade glibc <unistd.h> to declare environ.
+  AC_REQUIRE([gl_USE_SYSTEM_EXTENSIONS])
+  gt_CHECK_VAR_DECL([#include <unistd.h>], environ)
+  if test $gt_cv_var_environ_declaration != yes; then
+    HAVE_DECL_ENVIRON=0
+  fi
+])
+
+# Check if a variable is properly declared.
+# gt_CHECK_VAR_DECL(includes,variable)
+AC_DEFUN([gt_CHECK_VAR_DECL],
+[
+  define([gt_cv_var], [gt_cv_var_]$2[_declaration])
+  AC_MSG_CHECKING([if $2 is properly declared])
+  AC_CACHE_VAL([gt_cv_var], [
+    AC_TRY_COMPILE([$1
+      extern struct { int foo; } $2;],
+      [$2.foo = 1;],
+      gt_cv_var=no,
+      gt_cv_var=yes)])
+  AC_MSG_RESULT([$gt_cv_var])
+  if test $gt_cv_var = yes; then
+    AC_DEFINE([HAVE_]m4_translit($2, [a-z], [A-Z])[_DECL], 1,
+              [Define if you have the declaration of $2.])
+  fi
+  undefine([gt_cv_var])
+])
--- a/gl/m4/errno_h.m4
+++ b/gl/m4/errno_h.m4
@@ -1,5 +1,5 @@
-# errno_h.m4 serial 5
-dnl Copyright (C) 2004, 2006, 2008, 2009 Free Software Foundation, Inc.
+# errno_h.m4 serial 6
+dnl Copyright (C) 2004, 2006, 2008, 2009, 2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
@@ -34,6 +34,9 @@ booboo
 #if !defined ENOTSUP
 booboo
 #endif
+#if !defined ESTALE
+booboo
+#endif
 #if !defined ECANCELED
 booboo
 #endif
--- a/gl/m4/error.m4
+++ b/gl/m4/error.m4
@@ -1,7 +1,6 @@
-#serial 11
+#serial 12
 
-# Copyright (C) 1996, 1997, 1998, 2001, 2002, 2003, 2004 Free Software
-# Foundation, Inc.
+# Copyright (C) 1996-1998, 2001-2004, 2009-2010 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -18,5 +17,6 @@ AC_DEFUN([gl_ERROR],
 AC_DEFUN([gl_PREREQ_ERROR],
 [
   AC_REQUIRE([AC_FUNC_STRERROR_R])
+  AC_REQUIRE([AC_C_INLINE])
   :
 ])
--- a/gl/m4/extensions.m4
+++ b/gl/m4/extensions.m4
@@ -1,7 +1,7 @@
-# serial 8  -*- Autoconf -*-
+# serial 9  -*- Autoconf -*-
 # Enable extensions on systems that normally disable them.
 
-# Copyright (C) 2003, 2006-2009 Free Software Foundation, Inc.
+# Copyright (C) 2003, 2006-2010 Free Software Foundation, Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -12,6 +12,20 @@
 # enough in this area it's likely we'll need to redefine
 # AC_USE_SYSTEM_EXTENSIONS for quite some time.
 
+# If autoconf reports a warning
+#     warning: AC_COMPILE_IFELSE was called before AC_USE_SYSTEM_EXTENSIONS
+# or  warning: AC_RUN_IFELSE was called before AC_USE_SYSTEM_EXTENSIONS
+# the fix is
+#   1) to ensure that AC_USE_SYSTEM_EXTENSIONS is never directly invoked
+#      but always AC_REQUIREd,
+#   2) to ensure that for each occurrence of
+#        AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])
+#      or
+#        AC_REQUIRE([gl_USE_SYSTEM_EXTENSIONS])
+#      the corresponding gnulib module description has 'extensions' among
+#      its dependencies. This will ensure that the gl_USE_SYSTEM_EXTENSIONS
+#      invocation occurs in gl_EARLY, not in gl_INIT.
+
 # AC_USE_SYSTEM_EXTENSIONS
 # ------------------------
 # Enable extensions on systems that normally disable them,
@@ -74,8 +88,8 @@ AC_BEFORE([$0], [AC_RUN_IFELSE])dnl
     [ac_cv_safe_to_define___extensions__],
     [AC_COMPILE_IFELSE(
        [AC_LANG_PROGRAM([[
-#	  define __EXTENSIONS__ 1
-	  ]AC_INCLUDES_DEFAULT])],
+#         define __EXTENSIONS__ 1
+          ]AC_INCLUDES_DEFAULT])],
        [ac_cv_safe_to_define___extensions__=yes],
        [ac_cv_safe_to_define___extensions__=no])])
   test $ac_cv_safe_to_define___extensions__ = yes &&
--- /dev/null
+++ b/gl/m4/fcntl-o.m4
@@ -0,0 +1,85 @@
+# fcntl-o.m4 serial 2
+dnl Copyright (C) 2006, 2009-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Written by Paul Eggert.
+
+# Test whether the flags O_NOATIME and O_NOFOLLOW actually work.
+# Define HAVE_WORKING_O_NOATIME to 1 if O_NOATIME works, or to 0 otherwise.
+# Define HAVE_WORKING_O_NOFOLLOW to 1 if O_NOFOLLOW works, or to 0 otherwise.
+AC_DEFUN([gl_FCNTL_O_FLAGS],
+[
+  dnl Persuade glibc <fcntl.h> to define O_NOATIME and O_NOFOLLOW.
+  dnl AC_USE_SYSTEM_EXTENSIONS was introduced in autoconf 2.60 and obsoletes
+  dnl AC_GNU_SOURCE.
+  m4_ifdef([AC_USE_SYSTEM_EXTENSIONS],
+    [AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])],
+    [AC_REQUIRE([AC_GNU_SOURCE])])
+  AC_CACHE_CHECK([for working fcntl.h], [gl_cv_header_working_fcntl_h],
+    [AC_RUN_IFELSE(
+       [AC_LANG_PROGRAM(
+          [[#include <sys/types.h>
+           #include <sys/stat.h>
+           #include <unistd.h>
+           #include <fcntl.h>
+           #ifndef O_NOATIME
+            #define O_NOATIME 0
+           #endif
+           #ifndef O_NOFOLLOW
+            #define O_NOFOLLOW 0
+           #endif
+           static int const constants[] =
+            {
+              O_CREAT, O_EXCL, O_NOCTTY, O_TRUNC, O_APPEND,
+              O_NONBLOCK, O_SYNC, O_ACCMODE, O_RDONLY, O_RDWR, O_WRONLY
+            };
+          ]],
+          [[
+            int status = !constants;
+            {
+              static char const sym[] = "conftest.sym";
+              if (symlink (".", sym) != 0
+                  || close (open (sym, O_RDONLY | O_NOFOLLOW)) == 0)
+                status |= 32;
+              unlink (sym);
+            }
+            {
+              static char const file[] = "confdefs.h";
+              int fd = open (file, O_RDONLY | O_NOATIME);
+              char c;
+              struct stat st0, st1;
+              if (fd < 0
+                  || fstat (fd, &st0) != 0
+                  || sleep (1) != 0
+                  || read (fd, &c, 1) != 1
+                  || close (fd) != 0
+                  || stat (file, &st1) != 0
+                  || st0.st_atime != st1.st_atime)
+                status |= 64;
+            }
+            return status;]])],
+       [gl_cv_header_working_fcntl_h=yes],
+       [case $? in #(
+        32) gl_cv_header_working_fcntl_h='no (bad O_NOFOLLOW)';; #(
+        64) gl_cv_header_working_fcntl_h='no (bad O_NOATIME)';; #(
+        96) gl_cv_header_working_fcntl_h='no (bad O_NOATIME, O_NOFOLLOW)';; #(
+         *) gl_cv_header_working_fcntl_h='no';;
+        esac],
+       [gl_cv_header_working_fcntl_h=cross-compiling])])
+
+  case $gl_cv_header_working_fcntl_h in #(
+  *O_NOATIME* | no | cross-compiling) ac_val=0;; #(
+  *) ac_val=1;;
+  esac
+  AC_DEFINE_UNQUOTED([HAVE_WORKING_O_NOATIME], [$ac_val],
+    [Define to 1 if O_NOATIME works.])
+
+  case $gl_cv_header_working_fcntl_h in #(
+  *O_NOFOLLOW* | no | cross-compiling) ac_val=0;; #(
+  *) ac_val=1;;
+  esac
+  AC_DEFINE_UNQUOTED([HAVE_WORKING_O_NOFOLLOW], [$ac_val],
+    [Define to 1 if O_NOFOLLOW works.])
+])
--- /dev/null
+++ b/gl/m4/fcntl_h.m4
@@ -0,0 +1,43 @@
+# serial 12
+# Configure fcntl.h.
+dnl Copyright (C) 2006, 2007, 2009, 2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Written by Paul Eggert.
+
+AC_DEFUN([gl_FCNTL_H],
+[
+  AC_REQUIRE([gl_FCNTL_H_DEFAULTS])
+  AC_REQUIRE([gl_FCNTL_O_FLAGS])
+  gl_CHECK_NEXT_HEADERS([fcntl.h])
+
+  dnl Check for declarations of anything we want to poison if the
+  dnl corresponding gnulib module is not in use, if it is not common
+  dnl enough to be declared everywhere.
+  gl_WARN_ON_USE_PREPARE([[#include <fcntl.h>
+    ]], [fcntl openat])
+])
+
+AC_DEFUN([gl_FCNTL_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_FCNTL_H_DEFAULTS])
+  gl_MODULE_INDICATOR_SET_VARIABLE([$1])
+  dnl Define it also as a C macro, for the benefit of the unit tests.
+  gl_MODULE_INDICATOR_FOR_TESTS([$1])
+])
+
+AC_DEFUN([gl_FCNTL_H_DEFAULTS],
+[
+  GNULIB_FCNTL=0;   AC_SUBST([GNULIB_FCNTL])
+  GNULIB_OPEN=0;    AC_SUBST([GNULIB_OPEN])
+  GNULIB_OPENAT=0;  AC_SUBST([GNULIB_OPENAT])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_FCNTL=1;     AC_SUBST([HAVE_FCNTL])
+  HAVE_OPENAT=1;    AC_SUBST([HAVE_OPENAT])
+  REPLACE_FCNTL=0;  AC_SUBST([REPLACE_FCNTL])
+  REPLACE_OPEN=0;   AC_SUBST([REPLACE_OPEN])
+  REPLACE_OPENAT=0; AC_SUBST([REPLACE_OPENAT])
+])
--- a/gl/m4/getopt.m4
+++ b/gl/m4/getopt.m4
@@ -1,82 +1,305 @@
-# getopt.m4 serial 14
-dnl Copyright (C) 2002-2006, 2008 Free Software Foundation, Inc.
+# getopt.m4 serial 28
+dnl Copyright (C) 2002-2006, 2008-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
 
-# The getopt module assume you want GNU getopt, with getopt_long etc,
-# rather than vanilla POSIX getopt.  This means your code should
-# always include <getopt.h> for the getopt prototypes.
+# Request a POSIX compliant getopt function.
+AC_DEFUN([gl_FUNC_GETOPT_POSIX],
+[
+  m4_divert_text([DEFAULTS], [gl_getopt_required=POSIX])
+  AC_REQUIRE([gl_UNISTD_H_DEFAULTS])
+  gl_GETOPT_IFELSE([
+    gl_REPLACE_GETOPT
+  ],
+  [])
+])
+
+# Request a POSIX compliant getopt function with GNU extensions (such as
+# options with optional arguments) and the functions getopt_long,
+# getopt_long_only.
+AC_DEFUN([gl_FUNC_GETOPT_GNU],
+[
+  m4_divert_text([INIT_PREPARE], [gl_getopt_required=GNU])
+
+  AC_REQUIRE([gl_FUNC_GETOPT_POSIX])
+])
 
-AC_DEFUN([gl_GETOPT_SUBSTITUTE],
+# Request the gnulib implementation of the getopt functions unconditionally.
+# argp.m4 uses this.
+AC_DEFUN([gl_REPLACE_GETOPT],
 [
+  dnl Arrange for getopt.h to be created.
+  gl_GETOPT_SUBSTITUTE_HEADER
+  dnl Arrange for unistd.h to include getopt.h.
+  GNULIB_UNISTD_H_GETOPT=1
+  dnl Arrange to compile the getopt implementation.
   AC_LIBOBJ([getopt])
   AC_LIBOBJ([getopt1])
-  gl_GETOPT_SUBSTITUTE_HEADER
   gl_PREREQ_GETOPT
 ])
 
-AC_DEFUN([gl_GETOPT_SUBSTITUTE_HEADER],
+# emacs' configure.in uses this.
+AC_DEFUN([gl_GETOPT_IFELSE],
 [
-  GETOPT_H=getopt.h
-  AC_DEFINE([__GETOPT_PREFIX], [[rpl_]],
-    [Define to rpl_ if the getopt replacement functions and variables
-     should be used.])
-  AC_SUBST([GETOPT_H])
+  AC_REQUIRE([gl_GETOPT_CHECK_HEADERS])
+  AS_IF([test -n "$gl_replace_getopt"], [$1], [$2])
 ])
 
+# Determine whether to replace the entire getopt facility.
 AC_DEFUN([gl_GETOPT_CHECK_HEADERS],
 [
-  if test -z "$GETOPT_H"; then
-    AC_CHECK_HEADERS([getopt.h], [], [GETOPT_H=getopt.h])
+  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles
+
+  dnl Persuade Solaris <unistd.h> to declare optarg, optind, opterr, optopt.
+  AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])
+
+  gl_CHECK_NEXT_HEADERS([getopt.h])
+  AC_CHECK_HEADERS_ONCE([getopt.h])
+  if test $ac_cv_header_getopt_h = yes; then
+    HAVE_GETOPT_H=1
+  else
+    HAVE_GETOPT_H=0
+  fi
+  AC_SUBST([HAVE_GETOPT_H])
+
+  gl_replace_getopt=
+
+  dnl Test whether <getopt.h> is available.
+  if test -z "$gl_replace_getopt" && test $gl_getopt_required = GNU; then
+    AC_CHECK_HEADERS([getopt.h], [], [gl_replace_getopt=yes])
   fi
 
-  if test -z "$GETOPT_H"; then
-    AC_CHECK_FUNCS([getopt_long_only], [], [GETOPT_H=getopt.h])
+  dnl Test whether the function getopt_long is available.
+  if test -z "$gl_replace_getopt" && test $gl_getopt_required = GNU; then
+    AC_CHECK_FUNCS([getopt_long_only], [], [gl_replace_getopt=yes])
   fi
 
-  dnl BSD getopt_long uses an incompatible method to reset option processing,
-  dnl and (as of 2004-10-15) mishandles optional option-arguments.
-  if test -z "$GETOPT_H"; then
-    AC_CHECK_DECL([optreset], [GETOPT_H=getopt.h], [], [#include <getopt.h>])
-  fi
-
-  dnl Solaris 10 getopt doesn't handle `+' as a leading character in an
-  dnl option string (as of 2005-05-05).
-  if test -z "$GETOPT_H"; then
-    AC_CACHE_CHECK([for working GNU getopt function], [gl_cv_func_gnu_getopt],
-      [AC_RUN_IFELSE(
-	[AC_LANG_PROGRAM([[#include <getopt.h>]],
-	   [[
-	     char *myargv[3];
-	     myargv[0] = "conftest";
-	     myargv[1] = "-+";
-	     myargv[2] = 0;
-	     return getopt (2, myargv, "+a") != '?';
-	   ]])],
-	[gl_cv_func_gnu_getopt=yes],
-	[gl_cv_func_gnu_getopt=no],
-	[dnl cross compiling - pessimistically guess based on decls
-	 dnl Solaris 10 getopt doesn't handle `+' as a leading character in an
-	 dnl option string (as of 2005-05-05).
-	 AC_CHECK_DECL([getopt_clip],
-	   [gl_cv_func_gnu_getopt=no], [gl_cv_func_gnu_getopt=yes],
-	   [#include <getopt.h>])])])
-    if test "$gl_cv_func_gnu_getopt" = "no"; then
-      GETOPT_H=getopt.h
+  dnl BSD getopt_long uses an incompatible method to reset option processing.
+  dnl Existence of the variable, in and of itself, is not a reason to replace
+  dnl getopt, but knowledge of the variable is needed to determine how to
+  dnl reset and whether a reset reparses the environment.
+  dnl Solaris supports neither optreset nor optind=0, but keeps no state that
+  dnl needs a reset beyond setting optind=1; detect Solaris by getopt_clip.
+  if test -z "$gl_replace_getopt"; then
+    AC_CHECK_DECLS([optreset], [],
+      [AC_CHECK_DECLS([getopt_clip], [], [],
+        [[#include <getopt.h>]])
+      ],
+      [[#include <getopt.h>]])
+  fi
+
+  dnl mingw's getopt (in libmingwex.a) does weird things when the options
+  dnl strings starts with '+' and it's not the first call.  Some internal state
+  dnl is left over from earlier calls, and neither setting optind = 0 nor
+  dnl setting optreset = 1 get rid of this internal state.
+  dnl POSIX is silent on optind vs. optreset, so we allow either behavior.
+  dnl POSIX 2008 does not specify leading '+' behavior, but see
+  dnl http://austingroupbugs.net/view.php?id=191 for a recommendation on
+  dnl the next version of POSIX.  For now, we only guarantee leading '+'
+  dnl behavior with getopt-gnu.
+  if test -z "$gl_replace_getopt"; then
+    AC_CACHE_CHECK([whether getopt is POSIX compatible],
+      [gl_cv_func_getopt_posix],
+      [
+        dnl This test fails on mingw and succeeds on all other platforms.
+        AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+
+#if !HAVE_DECL_OPTRESET && !HAVE_DECL_GETOPT_CLIP
+# define OPTIND_MIN 0
+#else
+# define OPTIND_MIN 1
+#endif
+
+int
+main ()
+{
+  {
+    int argc = 0;
+    char *argv[10];
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "-a";
+    argv[argc++] = "foo";
+    argv[argc++] = "bar";
+    argv[argc] = NULL;
+    optind = OPTIND_MIN;
+    opterr = 0;
+
+    c = getopt (argc, argv, "ab");
+    if (!(c == 'a'))
+      return 1;
+    c = getopt (argc, argv, "ab");
+    if (!(c == -1))
+      return 2;
+    if (!(optind == 2))
+      return 3;
+  }
+  /* Some internal state exists at this point.  */
+  {
+    int argc = 0;
+    char *argv[10];
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "donald";
+    argv[argc++] = "-p";
+    argv[argc++] = "billy";
+    argv[argc++] = "duck";
+    argv[argc++] = "-a";
+    argv[argc++] = "bar";
+    argv[argc] = NULL;
+    optind = OPTIND_MIN;
+    opterr = 0;
+
+    c = getopt (argc, argv, "+abp:q:");
+    if (!(c == -1))
+      return 4;
+    if (!(strcmp (argv[0], "program") == 0))
+      return 5;
+    if (!(strcmp (argv[1], "donald") == 0))
+      return 6;
+    if (!(strcmp (argv[2], "-p") == 0))
+      return 7;
+    if (!(strcmp (argv[3], "billy") == 0))
+      return 8;
+    if (!(strcmp (argv[4], "duck") == 0))
+      return 9;
+    if (!(strcmp (argv[5], "-a") == 0))
+      return 10;
+    if (!(strcmp (argv[6], "bar") == 0))
+      return 11;
+    if (!(optind == 1))
+      return 12;
+  }
+  /* Detect MacOS 10.5 bug.  */
+  {
+    char *argv[3] = { "program", "-ab", NULL };
+    optind = OPTIND_MIN;
+    opterr = 0;
+    if (getopt (2, argv, "ab:") != 'a')
+      return 13;
+    if (getopt (2, argv, "ab:") != '?')
+      return 14;
+    if (optopt != 'b')
+      return 15;
+    if (optind != 2)
+      return 16;
+  }
+
+  return 0;
+}
+]])],
+          [gl_cv_func_getopt_posix=yes], [gl_cv_func_getopt_posix=no],
+          [case "$host_os" in
+             mingw*) gl_cv_func_getopt_posix="guessing no";;
+             darwin*) gl_cv_func_getopt_posix="guessing no";;
+             *)      gl_cv_func_getopt_posix="guessing yes";;
+           esac
+          ])
+      ])
+    case "$gl_cv_func_getopt_posix" in
+      *no) gl_replace_getopt=yes ;;
+    esac
+  fi
+
+  if test -z "$gl_replace_getopt" && test $gl_getopt_required = GNU; then
+    AC_CACHE_CHECK([for working GNU getopt function], [gl_cv_func_getopt_gnu],
+      [# Even with POSIXLY_CORRECT, the GNU extension of leading '-' in the
+       # optstring is necessary for programs like m4 that have POSIX-mandated
+       # semantics for supporting options interspersed with files.
+       # Also, since getopt_long is a GNU extension, we require optind=0.
+       gl_had_POSIXLY_CORRECT=${POSIXLY_CORRECT:+yes}
+       POSIXLY_CORRECT=1
+       export POSIXLY_CORRECT
+       AC_RUN_IFELSE(
+        [AC_LANG_PROGRAM([[#include <getopt.h>
+                           #include <stddef.h>
+                           #include <string.h>
+           ]], [[
+             /* This code succeeds on glibc 2.8, OpenBSD 4.0, Cygwin, mingw,
+                and fails on MacOS X 10.5, AIX 5.2, HP-UX 11, IRIX 6.5,
+                OSF/1 5.1, Solaris 10.  */
+             {
+               char *myargv[3];
+               myargv[0] = "conftest";
+               myargv[1] = "-+";
+               myargv[2] = 0;
+               opterr = 0;
+               if (getopt (2, myargv, "+a") != '?')
+                 return 1;
+             }
+             /* This code succeeds on glibc 2.8, mingw,
+                and fails on MacOS X 10.5, OpenBSD 4.0, AIX 5.2, HP-UX 11,
+                IRIX 6.5, OSF/1 5.1, Solaris 10, Cygwin 1.5.x.  */
+             {
+               char *argv[] = { "program", "-p", "foo", "bar", NULL };
+
+               optind = 1;
+               if (getopt (4, argv, "p::") != 'p')
+                 return 2;
+               if (optarg != NULL)
+                 return 3;
+               if (getopt (4, argv, "p::") != -1)
+                 return 4;
+               if (optind != 2)
+                 return 5;
+             }
+             /* This code succeeds on glibc 2.8 and fails on Cygwin 1.7.0.  */
+             {
+               char *argv[] = { "program", "foo", "-p", NULL };
+               optind = 0;
+               if (getopt (3, argv, "-p") != 1)
+                 return 6;
+               if (getopt (3, argv, "-p") != 'p')
+                 return 7;
+             }
+             /* This code fails on glibc 2.11.  */
+             {
+               char *argv[] = { "program", "-b", "-a", NULL };
+               optind = opterr = 0;
+               if (getopt (3, argv, "+:a:b") != 'b')
+                 return 8;
+               if (getopt (3, argv, "+:a:b") != ':')
+                 return 9;
+             }
+             return 0;
+           ]])],
+        [gl_cv_func_getopt_gnu=yes],
+        [gl_cv_func_getopt_gnu=no],
+        [dnl Cross compiling. Guess based on host and declarations.
+         case $host_os:$ac_cv_have_decl_optreset in
+           *-gnu*:* | mingw*:*) gl_cv_func_getopt_gnu=no;;
+           *:yes)               gl_cv_func_getopt_gnu=no;;
+           *)                   gl_cv_func_getopt_gnu=yes;;
+         esac
+        ])
+       if test "$gl_had_POSIXLY_CORRECT" != yes; then
+         AS_UNSET([POSIXLY_CORRECT])
+       fi
+      ])
+    if test "$gl_cv_func_getopt_gnu" = "no"; then
+      gl_replace_getopt=yes
     fi
   fi
 ])
 
-AC_DEFUN([gl_GETOPT_IFELSE],
+# emacs' configure.in uses this.
+AC_DEFUN([gl_GETOPT_SUBSTITUTE_HEADER],
 [
-  AC_REQUIRE([gl_GETOPT_CHECK_HEADERS])
-  AS_IF([test -n "$GETOPT_H"], [$1], [$2])
+  GETOPT_H=getopt.h
+  AC_DEFINE([__GETOPT_PREFIX], [[rpl_]],
+    [Define to rpl_ if the getopt replacement functions and variables
+     should be used.])
+  AC_SUBST([GETOPT_H])
 ])
 
-AC_DEFUN([gl_GETOPT], [gl_GETOPT_IFELSE([gl_GETOPT_SUBSTITUTE])])
-
 # Prerequisites of lib/getopt*.
+# emacs' configure.in uses this.
 AC_DEFUN([gl_PREREQ_GETOPT],
 [
   AC_CHECK_DECLS_ONCE([getenv])
--- a/gl/m4/gnulib-cache.m4
+++ b/gl/m4/gnulib-cache.m4
@@ -1,4 +1,4 @@
-# Copyright (C) 2002-2009 Free Software Foundation, Inc.
+# Copyright (C) 2002-2010 Free Software Foundation, Inc.
 #
 # This file is free software, distributed under the terms of the GNU
 # General Public License.  As a special exception to the GNU General
--- a/gl/m4/gnulib-common.m4
+++ b/gl/m4/gnulib-common.m4
@@ -1,5 +1,5 @@
-# gnulib-common.m4 serial 11
-dnl Copyright (C) 2007-2009 Free Software Foundation, Inc.
+# gnulib-common.m4 serial 20
+dnl Copyright (C) 2007-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
@@ -23,23 +23,83 @@ AC_DEFUN([gl_COMMON_BODY], [
 # define __GNUC_STDC_INLINE__ 1
 #endif])
   AH_VERBATIM([unused_parameter],
-[/* Define as a marker that can be attached to function parameter declarations
-   for parameters that are not used.  This helps to reduce warnings, such as
-   from GCC -Wunused-parameter.  */
+[/* Define as a marker that can be attached to declarations that might not
+    be used.  This helps to reduce warnings, such as from
+    GCC -Wunused-parameter.  */
 #if __GNUC__ >= 3 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)
-# define _UNUSED_PARAMETER_ __attribute__ ((__unused__))
+# define _GL_UNUSED __attribute__ ((__unused__))
 #else
-# define _UNUSED_PARAMETER_
+# define _GL_UNUSED
 #endif
+/* The name _UNUSED_PARAMETER_ is an earlier spelling, although the name
+   is a misnomer outside of parameter lists.  */
+#define _UNUSED_PARAMETER_ _GL_UNUSED
 ])
+  dnl Preparation for running test programs:
+  dnl Tell glibc to write diagnostics from -D_FORTIFY_SOURCE=2 to stderr, not
+  dnl to /dev/tty, so they can be redirected to log files.  Such diagnostics
+  dnl arise e.g., in the macros gl_PRINTF_DIRECTIVE_N, gl_SNPRINTF_DIRECTIVE_N.
+  LIBC_FATAL_STDERR_=1
+  export LIBC_FATAL_STDERR_
+])
+
+# gl_MODULE_INDICATOR_CONDITION
+# expands to a C preprocessor expression that evaluates to 1 or 0, depending
+# whether a gnulib module that has been requested shall be considered present
+# or not.
+AC_DEFUN([gl_MODULE_INDICATOR_CONDITION], [1])
+
+# gl_MODULE_INDICATOR_SET_VARIABLE([modulename])
+# sets the shell variable that indicates the presence of the given module to
+# a C preprocessor expression that will evaluate to 1.
+AC_DEFUN([gl_MODULE_INDICATOR_SET_VARIABLE],
+[
+  GNULIB_[]m4_translit([[$1]],
+    [abcdefghijklmnopqrstuvwxyz./-],
+    [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=gl_MODULE_INDICATOR_CONDITION
 ])
 
 # gl_MODULE_INDICATOR([modulename])
-# defines a C macro indicating the presence of the given module.
+# defines a C macro indicating the presence of the given module
+# in a location where it can be used.
+#                                             |  Value  |   Value   |
+#                                             | in lib/ | in tests/ |
+# --------------------------------------------+---------+-----------+
+# Module present among main modules:          |    1    |     1     |
+# --------------------------------------------+---------+-----------+
+# Module present among tests-related modules: |    0    |     1     |
+# --------------------------------------------+---------+-----------+
+# Module not present at all:                  |    0    |     0     |
+# --------------------------------------------+---------+-----------+
 AC_DEFUN([gl_MODULE_INDICATOR],
 [
-  AC_DEFINE([GNULIB_]translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___]), [1],
-    [Define to 1 when using the gnulib module ]$1[.])
+  AC_DEFINE_UNQUOTED([GNULIB_]m4_translit([[$1]],
+      [abcdefghijklmnopqrstuvwxyz./-],
+      [ABCDEFGHIJKLMNOPQRSTUVWXYZ___]),
+    [gl_MODULE_INDICATOR_CONDITION],
+    [Define to a C preprocessor expression that evaluates to 1 or 0,
+     depending whether the gnulib module $1 shall be considered present.])
+])
+
+# gl_MODULE_INDICATOR_FOR_TESTS([modulename])
+# defines a C macro indicating the presence of the given module
+# in lib or tests. This is useful to determine whether the module
+# should be tested.
+#                                             |  Value  |   Value   |
+#                                             | in lib/ | in tests/ |
+# --------------------------------------------+---------+-----------+
+# Module present among main modules:          |    1    |     1     |
+# --------------------------------------------+---------+-----------+
+# Module present among tests-related modules: |    1    |     1     |
+# --------------------------------------------+---------+-----------+
+# Module not present at all:                  |    0    |     0     |
+# --------------------------------------------+---------+-----------+
+AC_DEFUN([gl_MODULE_INDICATOR_FOR_TESTS],
+[
+  AC_DEFINE([GNULIB_TEST_]m4_translit([[$1]],
+      [abcdefghijklmnopqrstuvwxyz./-],
+      [ABCDEFGHIJKLMNOPQRSTUVWXYZ___]), [1],
+    [Define to 1 when the gnulib module $1 should be tested.])
 ])
 
 # m4_foreach_w
@@ -49,10 +109,25 @@ m4_ifndef([m4_foreach_w],
   [m4_define([m4_foreach_w],
     [m4_foreach([$1], m4_split(m4_normalize([$2]), [ ]), [$3])])])
 
+# AS_VAR_IF(VAR, VALUE, [IF-MATCH], [IF-NOT-MATCH])
+# ----------------------------------------------------
+# Backport of autoconf-2.63b's macro.
+# Remove this macro when we can assume autoconf >= 2.64.
+m4_ifndef([AS_VAR_IF],
+[m4_define([AS_VAR_IF],
+[AS_IF([test x"AS_VAR_GET([$1])" = x""$2], [$3], [$4])])])
+
 # AC_PROG_MKDIR_P
-# is a backport of autoconf-2.60's AC_PROG_MKDIR_P.
-# Remove this macro when we can assume autoconf >= 2.60.
-m4_ifdef([AC_PROG_MKDIR_P], [], [
+# is a backport of autoconf-2.60's AC_PROG_MKDIR_P, with a fix
+# for interoperability with automake-1.9.6 from autoconf-2.62.
+# Remove this macro when we can assume autoconf >= 2.62 or
+# autoconf >= 2.60 && automake >= 1.10.
+m4_ifdef([AC_PROG_MKDIR_P], [
+  dnl For automake-1.9.6 && autoconf < 2.62: Ensure MKDIR_P is AC_SUBSTed.
+  m4_define([AC_PROG_MKDIR_P],
+    m4_defn([AC_PROG_MKDIR_P])[
+    AC_SUBST([MKDIR_P])])], [
+  dnl For autoconf < 2.60: Backport of AC_PROG_MKDIR_P.
   AC_DEFUN_ONCE([AC_PROG_MKDIR_P],
     [AC_REQUIRE([AM_PROG_MKDIR_P])dnl defined by automake
      MKDIR_P='$(mkdir_p)'
@@ -63,6 +138,7 @@ m4_ifdef([AC_PROG_MKDIR_P], [], [
 # so that mixed use of GNU C and GNU C++ and mixed use of Sun C and Sun C++
 # works.
 # This definition can be removed once autoconf >= 2.62 can be assumed.
+m4_if(m4_version_compare(m4_defn([m4_PACKAGE_VERSION]),[2.62]),[-1],[
 AC_DEFUN([AC_C_RESTRICT],
 [AC_CACHE_CHECK([for C/C++ restrict keyword], [ac_cv_c_restrict],
   [ac_cv_c_restrict=no
@@ -70,13 +146,13 @@ AC_DEFUN([AC_C_RESTRICT],
    for ac_kw in __restrict __restrict__ _Restrict restrict; do
      AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
       [[typedef int * int_ptr;
-	int foo (int_ptr $ac_kw ip) {
-	return ip[0];
+        int foo (int_ptr $ac_kw ip) {
+        return ip[0];
        }]],
       [[int s[1];
-	int * $ac_kw t = s;
-	t[0] = 0;
-	return foo(t)]])],
+        int * $ac_kw t = s;
+        t[0] = 0;
+        return foo(t)]])],
       [ac_cv_c_restrict=$ac_kw])
      test "$ac_cv_c_restrict" != no && break
    done
@@ -100,6 +176,7 @@ AC_DEFUN([AC_C_RESTRICT],
    *)  AC_DEFINE_UNQUOTED([restrict], [$ac_cv_c_restrict]) ;;
  esac
 ])
+])
 
 # gl_BIGENDIAN
 # is like AC_C_BIGENDIAN, except that it can be AC_REQUIREd.
--- a/gl/m4/gnulib-comp.m4
+++ b/gl/m4/gnulib-comp.m4
@@ -1,5 +1,5 @@
 # DO NOT EDIT! GENERATED AUTOMATICALLY!
-# Copyright (C) 2002-2009 Free Software Foundation, Inc.
+# Copyright (C) 2002-2010 Free Software Foundation, Inc.
 #
 # This file is free software, distributed under the terms of the GNU
 # General Public License.  As a special exception to the GNU General
@@ -25,13 +25,99 @@ AC_DEFUN([gl_EARLY],
   m4_pattern_allow([^gl_LIBOBJS$])dnl a variable
   m4_pattern_allow([^gl_LTLIBOBJS$])dnl a variable
   AC_REQUIRE([AC_PROG_RANLIB])
+  # Code from module alloca-opt:
+  # Code from module alloca-opt-tests:
+  # Code from module arg-nonnull:
+  # Code from module autobuild:
   AB_INIT
+  # Code from module binary-io:
+  # Code from module binary-io-tests:
+  # Code from module c++defs:
+  # Code from module csharpcomp-script:
+  # Code from module dup2:
+  # Code from module dup2-tests:
+  # Code from module environ:
+  # Code from module environ-tests:
+  # Code from module errno:
+  # Code from module errno-tests:
+  # Code from module error:
+  # Code from module extensions:
   AC_REQUIRE([gl_USE_SYSTEM_EXTENSIONS])
+  # Code from module fcntl-h:
+  # Code from module fcntl-h-tests:
+  # Code from module fdl-1.3:
+  # Code from module gendocs:
+  # Code from module getopt:
+  # Code from module getopt-gnu:
+  # Code from module getopt-posix:
+  # Code from module getopt-posix-tests:
+  # Code from module gettext-h:
+  # Code from module gnumakefile:
+  # Code from module gnupload:
+  # Code from module gpl-3.0:
+  # Code from module ignore-value:
+  # Code from module include_next:
+  # Code from module intprops:
+  # Code from module lgpl-2.1:
+  # Code from module lstat:
+  # Code from module lstat-tests:
+  # Code from module maintainer-makefile:
+  # Code from module malloc-posix:
+  # Code from module malloca:
+  # Code from module malloca-tests:
+  # Code from module manywarnings:
+  # Code from module multiarch:
+  # Code from module open:
+  # Code from module open-tests:
+  # Code from module pathmax:
+  # Code from module pmccabe2html:
+  # Code from module progname:
+  # Code from module putenv:
+  # Code from module same-inode:
+  # Code from module setenv:
+  # Code from module setenv-tests:
+  # Code from module stat:
+  # Code from module stat-tests:
+  # Code from module stdarg:
   dnl Some compilers (e.g., AIX 5.3 cc) need to be in c99 mode
   dnl for the builtin va_copy to work.  With Autoconf 2.60 or later,
   dnl AC_PROG_CC_STDC arranges for this.  With older Autoconf AC_PROG_CC_STDC
   dnl shouldn't hurt, though installers are on their own to set c99 mode.
   AC_REQUIRE([AC_PROG_CC_STDC])
+  # Code from module stdbool:
+  # Code from module stdbool-tests:
+  # Code from module stddef:
+  # Code from module stddef-tests:
+  # Code from module stdint:
+  # Code from module stdint-tests:
+  # Code from module stdlib:
+  # Code from module stdlib-tests:
+  # Code from module strerror:
+  # Code from module strerror-tests:
+  # Code from module string:
+  # Code from module string-tests:
+  # Code from module symlink:
+  # Code from module symlink-tests:
+  # Code from module sys_stat:
+  # Code from module sys_stat-tests:
+  # Code from module time:
+  # Code from module time-tests:
+  # Code from module unistd:
+  # Code from module unistd-tests:
+  # Code from module unsetenv:
+  # Code from module unsetenv-tests:
+  # Code from module useless-if-before-free:
+  # Code from module vc-list-files:
+  # Code from module vc-list-files-tests:
+  # Code from module verify:
+  # Code from module verify-tests:
+  # Code from module version-etc:
+  # Code from module version-etc-fsf:
+  # Code from module version-etc-tests:
+  # Code from module warn-on-use:
+  # Code from module warnings:
+  # Code from module wchar:
+  # Code from module wchar-tests:
 ])
 
 # This macro should be invoked from ./configure.ac, in the section
@@ -40,6 +126,7 @@ AC_DEFUN([gl_INIT],
 [
   AM_CONDITIONAL([GL_COND_LIBTOOL], [true])
   gl_cond_libtool=true
+  gl_m4_base='gl/m4'
   m4_pushdef([AC_LIBOBJ], m4_defn([gl_LIBOBJ]))
   m4_pushdef([AC_REPLACE_FUNCS], m4_defn([gl_REPLACE_FUNCS]))
   m4_pushdef([AC_LIBSOURCES], m4_defn([gl_LIBSOURCES]))
@@ -47,16 +134,32 @@ AC_DEFUN([gl_INIT],
   m4_pushdef([gl_LIBSOURCES_DIR], [])
   gl_COMMON
   gl_source_base='gl'
+  # Code from module arg-nonnull:
+  # Code from module autobuild:
+  # Code from module c++defs:
+  # Code from module csharpcomp-script:
   AC_REQUIRE([gt_CSHARPCOMP])
   AC_CONFIG_FILES([csharpcomp.sh:build-aux/csharpcomp.sh.in])
+  # Code from module errno:
   gl_HEADER_ERRNO_H
+  # Code from module error:
   gl_ERROR
   m4_ifdef([AM_XGETTEXT_OPTION],
-    [AM_XGETTEXT_OPTION([--flag=error:3:c-format])
-     AM_XGETTEXT_OPTION([--flag=error_at_line:5:c-format])])
-  gl_GETOPT
+    [AM_][XGETTEXT_OPTION([--flag=error:3:c-format])
+     AM_][XGETTEXT_OPTION([--flag=error_at_line:5:c-format])])
+  # Code from module extensions:
+  # Code from module fdl-1.3:
+  # Code from module gendocs:
+  # Code from module getopt:
+  # Code from module getopt-gnu:
+  gl_FUNC_GETOPT_GNU
+  gl_MODULE_INDICATOR_FOR_TESTS([getopt-gnu])
+  # Code from module getopt-posix:
+  gl_FUNC_GETOPT_POSIX
+  # Code from module gettext-h:
   AC_SUBST([LIBINTL])
   AC_SUBST([LTLIBINTL])
+  # Code from module gnumakefile:
   # Autoconf 2.61a.99 and earlier don't support linking a file only
   # in VPATH builds.  But since GNUmakefile is for maintainer use
   # only, it does not matter if we skip the link with older autoconf.
@@ -67,14 +170,39 @@ AC_DEFUN([gl_INIT],
   	m4_defn([m4_PACKAGE_VERSION])), [1], [],
         [AC_CONFIG_LINKS([$GNUmakefile:$GNUmakefile], [],
   	[GNUmakefile=$GNUmakefile])])
-  gl_PMCCABE2HTML
+  # Code from module gnupload:
+  # Code from module gpl-3.0:
+  # Code from module include_next:
+  # Code from module intprops:
+  # Code from module lgpl-2.1:
+  # Code from module maintainer-makefile:
+  AC_CONFIG_COMMANDS_PRE([m4_ifdef([AH_HEADER],
+    [AC_SUBST([CONFIG_INCLUDE], m4_defn([AH_HEADER]))])])
+  # Code from module manywarnings:
+  # Code from module pmccabe2html:
+  AC_PATH_PROG([PMCCABE], [pmccabe], [false])
+  # Code from module progname:
+  AC_CHECK_DECLS([program_invocation_name], [], [], [#include <errno.h>])
+  AC_CHECK_DECLS([program_invocation_short_name], [], [], [#include <errno.h>])
+  # Code from module stdarg:
   gl_STDARG_H
+  # Code from module stddef:
+  gl_STDDEF_H
+  # Code from module strerror:
   gl_FUNC_STRERROR
   gl_STRING_MODULE_INDICATOR([strerror])
+  # Code from module string:
   gl_HEADER_STRING_H
+  # Code from module unistd:
   gl_UNISTD_H
+  # Code from module useless-if-before-free:
+  # Code from module vc-list-files:
+  # Code from module version-etc:
   gl_VERSION_ETC
+  # Code from module warn-on-use:
+  # Code from module warnings:
   AC_SUBST([WARN_CFLAGS])
+  # End of code from modules
   m4_ifval(gl_LIBSOURCES_LIST, [
     m4_syscmd([test ! -d ]m4_defn([gl_LIBSOURCES_DIR])[ ||
       for gl_file in ]gl_LIBSOURCES_LIST[ ; do
@@ -97,7 +225,7 @@ AC_DEFUN([gl_INIT],
     if test -n "$gl_LIBOBJS"; then
       # Remove the extension.
       sed_drop_objext='s/\.o$//;s/\.obj$//'
-      for i in `for i in $gl_LIBOBJS; do echo "$i"; done | sed "$sed_drop_objext" | sort | uniq`; do
+      for i in `for i in $gl_LIBOBJS; do echo "$i"; done | sed -e "$sed_drop_objext" | sort | uniq`; do
         gl_libobjs="$gl_libobjs $i.$ac_objext"
         gl_ltlibobjs="$gl_ltlibobjs $i.lo"
       done
@@ -114,8 +242,50 @@ AC_DEFUN([gl_INIT],
   m4_pushdef([gltests_LIBSOURCES_DIR], [])
   gl_COMMON
   gl_source_base='gltests'
+changequote(,)dnl
+  gltests_WITNESS=IN_`echo "${PACKAGE-$PACKAGE_TARNAME}" | LC_ALL=C tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ | LC_ALL=C sed -e 's/[^A-Z0-9_]/_/g'`_GNULIB_TESTS
+changequote([, ])dnl
+  AC_SUBST([gltests_WITNESS])
+  gl_module_indicator_condition=$gltests_WITNESS
+  m4_pushdef([gl_MODULE_INDICATOR_CONDITION], [$gl_module_indicator_condition])
+  gl_FUNC_ALLOCA
+  gl_FUNC_DUP2
+  gl_UNISTD_MODULE_INDICATOR([dup2])
+  gl_ENVIRON
+  gl_UNISTD_MODULE_INDICATOR([environ])
+  gl_FCNTL_H
+  AC_REQUIRE([AC_C_INLINE])
+  gl_FUNC_LSTAT
+  gl_SYS_STAT_MODULE_INDICATOR([lstat])
+  gl_FUNC_MALLOC_POSIX
+  gl_STDLIB_MODULE_INDICATOR([malloc-posix])
+  gl_MALLOCA
+  gl_MULTIARCH
+  gl_FUNC_OPEN
+  gl_FCNTL_MODULE_INDICATOR([open])
+  gl_PATHMAX
+  gl_FUNC_PUTENV
+  gl_STDLIB_MODULE_INDICATOR([putenv])
+  gl_FUNC_SETENV
+  gl_STDLIB_MODULE_INDICATOR([setenv])
+  gl_FUNC_STAT
+  gl_SYS_STAT_MODULE_INDICATOR([stat])
+  AM_STDBOOL_H
+  gl_STDINT_H
+  gt_TYPE_WCHAR_T
+  gt_TYPE_WINT_T
+  gl_STDLIB_H
+  gl_FUNC_SYMLINK
+  gl_UNISTD_MODULE_INDICATOR([symlink])
+  gl_HEADER_SYS_STAT_H
+  AC_PROG_MKDIR_P
+  gl_HEADER_TIME_H
+  gl_FUNC_UNSETENV
+  gl_STDLIB_MODULE_INDICATOR([unsetenv])
   abs_aux_dir=`cd "$ac_aux_dir"; pwd`
   AC_SUBST([abs_aux_dir])
+  gl_WCHAR_H
+  m4_popdef([gl_MODULE_INDICATOR_CONDITION])
   m4_ifval(gltests_LIBSOURCES_LIST, [
     m4_syscmd([test ! -d ]m4_defn([gltests_LIBSOURCES_DIR])[ ||
       for gl_file in ]gltests_LIBSOURCES_LIST[ ; do
@@ -138,7 +308,7 @@ AC_DEFUN([gl_INIT],
     if test -n "$gltests_LIBOBJS"; then
       # Remove the extension.
       sed_drop_objext='s/\.o$//;s/\.obj$//'
-      for i in `for i in $gltests_LIBOBJS; do echo "$i"; done | sed "$sed_drop_objext" | sort | uniq`; do
+      for i in `for i in $gltests_LIBOBJS; do echo "$i"; done | sed -e "$sed_drop_objext" | sort | uniq`; do
         gltests_libobjs="$gltests_libobjs $i.$ac_objext"
         gltests_ltlibobjs="$gltests_ltlibobjs $i.lo"
       done
@@ -146,6 +316,8 @@ AC_DEFUN([gl_INIT],
     AC_SUBST([gltests_LIBOBJS], [$gltests_libobjs])
     AC_SUBST([gltests_LTLIBOBJS], [$gltests_ltlibobjs])
   ])
+  LIBTESTS_LIBDEPS="$gltests_libdeps"
+  AC_SUBST([LIBTESTS_LIBDEPS])
 ])
 
 # Like AC_LIBOBJ, except that the module name goes
@@ -205,14 +377,16 @@ AC_DEFUN([gltests_LIBSOURCES], [
 # This macro records the list of files which have been installed by
 # gnulib-tool and may be removed by future gnulib-tool invocations.
 AC_DEFUN([gl_FILE_LIST], [
+  build-aux/arg-nonnull.h
+  build-aux/c++defs.h
   build-aux/csharpcomp.sh.in
   build-aux/gendocs.sh
   build-aux/gnupload
-  build-aux/link-warning.h
   build-aux/pmccabe.css
   build-aux/pmccabe2html
   build-aux/useless-if-before-free
   build-aux/vc-list-files
+  build-aux/warn-on-use.h
   doc/fdl-1.3.texi
   doc/gendocs_template
   doc/gpl-3.0.texi
@@ -229,35 +403,124 @@ AC_DEFUN([gl_FILE_LIST], [
   lib/progname.c
   lib/progname.h
   lib/stdarg.in.h
+  lib/stddef.in.h
   lib/strerror.c
   lib/string.in.h
   lib/unistd.in.h
   lib/version-etc.c
   lib/version-etc.h
   m4/00gnulib.m4
+  m4/alloca.m4
   m4/autobuild.m4
   m4/csharp.m4
   m4/csharpcomp.m4
+  m4/dos.m4
+  m4/dup2.m4
+  m4/eealloc.m4
+  m4/environ.m4
   m4/errno_h.m4
   m4/error.m4
   m4/extensions.m4
+  m4/fcntl-o.m4
+  m4/fcntl_h.m4
   m4/getopt.m4
   m4/gnulib-common.m4
   m4/include_next.m4
+  m4/longlong.m4
+  m4/lstat.m4
+  m4/malloc.m4
+  m4/malloca.m4
   m4/manywarnings.m4
-  m4/pmccabe2html.m4
+  m4/mode_t.m4
+  m4/multiarch.m4
+  m4/open.m4
+  m4/pathmax.m4
+  m4/putenv.m4
+  m4/setenv.m4
+  m4/stat.m4
   m4/stdarg.m4
+  m4/stdbool.m4
+  m4/stddef_h.m4
+  m4/stdint.m4
+  m4/stdlib_h.m4
   m4/strerror.m4
   m4/string_h.m4
+  m4/symlink.m4
+  m4/sys_stat_h.m4
+  m4/time_h.m4
   m4/unistd_h.m4
   m4/version-etc.m4
+  m4/warn-on-use.m4
   m4/warnings.m4
+  m4/wchar_h.m4
+  m4/wchar_t.m4
+  m4/wint_t.m4
+  tests/init.sh
+  tests/macros.h
+  tests/signature.h
+  tests/test-alloca-opt.c
+  tests/test-binary-io.c
+  tests/test-binary-io.sh
+  tests/test-dup2.c
+  tests/test-environ.c
   tests/test-errno.c
+  tests/test-fcntl-h.c
+  tests/test-getopt.c
+  tests/test-getopt.h
+  tests/test-getopt_long.h
+  tests/test-lstat.c
+  tests/test-lstat.h
+  tests/test-malloca.c
+  tests/test-open.c
+  tests/test-open.h
+  tests/test-setenv.c
+  tests/test-stat.c
+  tests/test-stat.h
+  tests/test-stdbool.c
+  tests/test-stddef.c
+  tests/test-stdint.c
+  tests/test-stdlib.c
   tests/test-strerror.c
   tests/test-string.c
+  tests/test-symlink.c
+  tests/test-symlink.h
+  tests/test-sys_stat.c
+  tests/test-time.c
   tests/test-unistd.c
+  tests/test-unsetenv.c
   tests/test-vc-list-files-cvs.sh
   tests/test-vc-list-files-git.sh
+  tests/test-verify.c
+  tests/test-verify.sh
+  tests/test-version-etc.c
+  tests/test-version-etc.sh
+  tests/test-wchar.c
+  tests=lib/alloca.in.h
+  tests=lib/binary-io.h
+  tests=lib/dup2.c
+  tests=lib/fcntl.in.h
+  tests=lib/ignore-value.h
+  tests=lib/lstat.c
+  tests=lib/malloc.c
+  tests=lib/malloca.c
+  tests=lib/malloca.h
+  tests=lib/malloca.valgrind
+  tests=lib/open.c
+  tests=lib/pathmax.h
+  tests=lib/putenv.c
+  tests=lib/same-inode.h
+  tests=lib/setenv.c
+  tests=lib/stat.c
+  tests=lib/stdbool.in.h
+  tests=lib/stdint.in.h
+  tests=lib/stdlib.in.h
+  tests=lib/symlink.c
+  tests=lib/sys_stat.in.h
+  tests=lib/time.in.h
+  tests=lib/unsetenv.c
+  tests=lib/verify.h
+  tests=lib/version-etc-fsf.c
+  tests=lib/wchar.in.h
   top/GNUmakefile
   top/maint.mk
 ])
--- /dev/null
+++ b/gl/m4/gnulib-tool.m4
@@ -0,0 +1,57 @@
+# gnulib-tool.m4 serial 2
+dnl Copyright (C) 2004-2005, 2009-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl The following macros need not be invoked explicitly.
+dnl Invoking them does nothing except to declare default arguments
+dnl for "gnulib-tool --import".
+
+dnl Usage: gl_LOCAL_DIR([DIR])
+AC_DEFUN([gl_LOCAL_DIR], [])
+
+dnl Usage: gl_MODULES([module1 module2 ...])
+AC_DEFUN([gl_MODULES], [])
+
+dnl Usage: gl_AVOID([module1 module2 ...])
+AC_DEFUN([gl_AVOID], [])
+
+dnl Usage: gl_SOURCE_BASE([DIR])
+AC_DEFUN([gl_SOURCE_BASE], [])
+
+dnl Usage: gl_M4_BASE([DIR])
+AC_DEFUN([gl_M4_BASE], [])
+
+dnl Usage: gl_PO_BASE([DIR])
+AC_DEFUN([gl_PO_BASE], [])
+
+dnl Usage: gl_DOC_BASE([DIR])
+AC_DEFUN([gl_DOC_BASE], [])
+
+dnl Usage: gl_TESTS_BASE([DIR])
+AC_DEFUN([gl_TESTS_BASE], [])
+
+dnl Usage: gl_WITH_TESTS
+AC_DEFUN([gl_WITH_TESTS], [])
+
+dnl Usage: gl_LIB([LIBNAME])
+AC_DEFUN([gl_LIB], [])
+
+dnl Usage: gl_LGPL or gl_LGPL([VERSION])
+AC_DEFUN([gl_LGPL], [])
+
+dnl Usage: gl_MAKEFILE_NAME([FILENAME])
+AC_DEFUN([gl_MAKEFILE_NAME], [])
+
+dnl Usage: gl_LIBTOOL
+AC_DEFUN([gl_LIBTOOL], [])
+
+dnl Usage: gl_MACRO_PREFIX([PREFIX])
+AC_DEFUN([gl_MACRO_PREFIX], [])
+
+dnl Usage: gl_PO_DOMAIN([DOMAIN])
+AC_DEFUN([gl_PO_DOMAIN], [])
+
+dnl Usage: gl_VC_FILES([BOOLEAN])
+AC_DEFUN([gl_VC_FILES], [])
--- a/gl/m4/include_next.m4
+++ b/gl/m4/include_next.m4
@@ -1,5 +1,5 @@
 # include_next.m4 serial 14
-dnl Copyright (C) 2006-2009 Free Software Foundation, Inc.
+dnl Copyright (C) 2006-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
@@ -109,11 +109,11 @@ EOF
 # be
 # '"///usr/include/foo.h"', or whatever other absolute file name is suitable.
 # That way, a header file with the following line:
-#	#@INCLUDE_NEXT@ @NEXT_FOO_H@
+#       #@INCLUDE_NEXT@ @NEXT_FOO_H@
 # or
-#	#@INCLUDE_NEXT_AS_FIRST_DIRECTIVE@ @NEXT_AS_FIRST_DIRECTIVE_FOO_H@
+#       #@INCLUDE_NEXT_AS_FIRST_DIRECTIVE@ @NEXT_AS_FIRST_DIRECTIVE_FOO_H@
 # behaves (after sed substitution) as if it contained
-#	#include_next <foo.h>
+#       #include_next <foo.h>
 # even if the compiler does not support include_next.
 # The three "///" are to pacify Sun C 5.8, which otherwise would say
 # "warning: #include of /usr/include/... may be non-portable".
@@ -129,46 +129,46 @@ AC_DEFUN([gl_CHECK_NEXT_HEADERS],
 
   m4_foreach_w([gl_HEADER_NAME], [$1],
     [AS_VAR_PUSHDEF([gl_next_header],
-		    [gl_cv_next_]m4_defn([gl_HEADER_NAME]))
+                    [gl_cv_next_]m4_defn([gl_HEADER_NAME]))
      if test $gl_cv_have_include_next = yes; then
        AS_VAR_SET([gl_next_header], ['<'gl_HEADER_NAME'>'])
      else
        AC_CACHE_CHECK(
-	 [absolute name of <]m4_defn([gl_HEADER_NAME])[>],
-	 m4_defn([gl_next_header]),
-	 [AS_VAR_PUSHDEF([gl_header_exists],
-			 [ac_cv_header_]m4_defn([gl_HEADER_NAME]))
-	  if test AS_VAR_GET(gl_header_exists) = yes; then
-	    AC_LANG_CONFTEST(
-	      [AC_LANG_SOURCE(
-		 [[#include <]]m4_dquote(m4_defn([gl_HEADER_NAME]))[[>]]
-	       )])
-	    dnl AIX "xlc -E" and "cc -E" omit #line directives for header files
-	    dnl that contain only a #include of other header files and no
-	    dnl non-comment tokens of their own. This leads to a failure to
-	    dnl detect the absolute name of <dirent.h>, <signal.h>, <poll.h>
-	    dnl and others. The workaround is to force preservation of comments
-	    dnl through option -C. This ensures all necessary #line directives
-	    dnl are present. GCC supports option -C as well.
-	    case "$host_os" in
-	      aix*) gl_absname_cpp="$ac_cpp -C" ;;
-	      *)    gl_absname_cpp="$ac_cpp" ;;
-	    esac
-	    dnl eval is necessary to expand gl_absname_cpp.
-	    dnl Ultrix and Pyramid sh refuse to redirect output of eval,
-	    dnl so use subshell.
-	    AS_VAR_SET([gl_next_header],
-	      ['"'`(eval "$gl_absname_cpp conftest.$ac_ext") 2>&AS_MESSAGE_LOG_FD |
-	       sed -n '\#/]m4_defn([gl_HEADER_NAME])[#{
-		 s#.*"\(.*/]m4_defn([gl_HEADER_NAME])[\)".*#\1#
-		 s#^/[^/]#//&#
-		 p
-		 q
-	       }'`'"'])
-	  else
-	    AS_VAR_SET([gl_next_header], ['<'gl_HEADER_NAME'>'])
-	  fi
-	  AS_VAR_POPDEF([gl_header_exists])])
+         [absolute name of <]m4_defn([gl_HEADER_NAME])[>],
+         m4_defn([gl_next_header]),
+         [AS_VAR_PUSHDEF([gl_header_exists],
+                         [ac_cv_header_]m4_defn([gl_HEADER_NAME]))
+          if test AS_VAR_GET(gl_header_exists) = yes; then
+            AC_LANG_CONFTEST(
+              [AC_LANG_SOURCE(
+                 [[#include <]]m4_dquote(m4_defn([gl_HEADER_NAME]))[[>]]
+               )])
+            dnl AIX "xlc -E" and "cc -E" omit #line directives for header files
+            dnl that contain only a #include of other header files and no
+            dnl non-comment tokens of their own. This leads to a failure to
+            dnl detect the absolute name of <dirent.h>, <signal.h>, <poll.h>
+            dnl and others. The workaround is to force preservation of comments
+            dnl through option -C. This ensures all necessary #line directives
+            dnl are present. GCC supports option -C as well.
+            case "$host_os" in
+              aix*) gl_absname_cpp="$ac_cpp -C" ;;
+              *)    gl_absname_cpp="$ac_cpp" ;;
+            esac
+            dnl eval is necessary to expand gl_absname_cpp.
+            dnl Ultrix and Pyramid sh refuse to redirect output of eval,
+            dnl so use subshell.
+            AS_VAR_SET([gl_next_header],
+              ['"'`(eval "$gl_absname_cpp conftest.$ac_ext") 2>&AS_MESSAGE_LOG_FD |
+               sed -n '\#/]m4_defn([gl_HEADER_NAME])[#{
+                 s#.*"\(.*/]m4_defn([gl_HEADER_NAME])[\)".*#\1#
+                 s#^/[^/]#//&#
+                 p
+                 q
+               }'`'"'])
+          else
+            AS_VAR_SET([gl_next_header], ['<'gl_HEADER_NAME'>'])
+          fi
+          AS_VAR_POPDEF([gl_header_exists])])
      fi
      AC_SUBST(
        AS_TR_CPP([NEXT_]m4_defn([gl_HEADER_NAME])),
--- /dev/null
+++ b/gl/m4/longlong.m4
@@ -0,0 +1,106 @@
+# longlong.m4 serial 14
+dnl Copyright (C) 1999-2007, 2009-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Paul Eggert.
+
+# Define HAVE_LONG_LONG_INT if 'long long int' works.
+# This fixes a bug in Autoconf 2.61, but can be removed once we
+# assume 2.62 everywhere.
+
+# Note: If the type 'long long int' exists but is only 32 bits large
+# (as on some very old compilers), HAVE_LONG_LONG_INT will not be
+# defined. In this case you can treat 'long long int' like 'long int'.
+
+AC_DEFUN([AC_TYPE_LONG_LONG_INT],
+[
+  AC_CACHE_CHECK([for long long int], [ac_cv_type_long_long_int],
+    [AC_LINK_IFELSE(
+       [_AC_TYPE_LONG_LONG_SNIPPET],
+       [dnl This catches a bug in Tandem NonStop Kernel (OSS) cc -O circa 2004.
+        dnl If cross compiling, assume the bug isn't important, since
+        dnl nobody cross compiles for this platform as far as we know.
+        AC_RUN_IFELSE(
+          [AC_LANG_PROGRAM(
+             [[@%:@include <limits.h>
+               @%:@ifndef LLONG_MAX
+               @%:@ define HALF \
+                        (1LL << (sizeof (long long int) * CHAR_BIT - 2))
+               @%:@ define LLONG_MAX (HALF - 1 + HALF)
+               @%:@endif]],
+             [[long long int n = 1;
+               int i;
+               for (i = 0; ; i++)
+                 {
+                   long long int m = n << i;
+                   if (m >> i != n)
+                     return 1;
+                   if (LLONG_MAX / 2 < m)
+                     break;
+                 }
+               return 0;]])],
+          [ac_cv_type_long_long_int=yes],
+          [ac_cv_type_long_long_int=no],
+          [ac_cv_type_long_long_int=yes])],
+       [ac_cv_type_long_long_int=no])])
+  if test $ac_cv_type_long_long_int = yes; then
+    AC_DEFINE([HAVE_LONG_LONG_INT], [1],
+      [Define to 1 if the system has the type `long long int'.])
+  fi
+])
+
+# Define HAVE_UNSIGNED_LONG_LONG_INT if 'unsigned long long int' works.
+# This fixes a bug in Autoconf 2.61, but can be removed once we
+# assume 2.62 everywhere.
+
+# Note: If the type 'unsigned long long int' exists but is only 32 bits
+# large (as on some very old compilers), AC_TYPE_UNSIGNED_LONG_LONG_INT
+# will not be defined. In this case you can treat 'unsigned long long int'
+# like 'unsigned long int'.
+
+AC_DEFUN([AC_TYPE_UNSIGNED_LONG_LONG_INT],
+[
+  AC_CACHE_CHECK([for unsigned long long int],
+    [ac_cv_type_unsigned_long_long_int],
+    [AC_LINK_IFELSE(
+       [_AC_TYPE_LONG_LONG_SNIPPET],
+       [ac_cv_type_unsigned_long_long_int=yes],
+       [ac_cv_type_unsigned_long_long_int=no])])
+  if test $ac_cv_type_unsigned_long_long_int = yes; then
+    AC_DEFINE([HAVE_UNSIGNED_LONG_LONG_INT], [1],
+      [Define to 1 if the system has the type `unsigned long long int'.])
+  fi
+])
+
+# Expands to a C program that can be used to test for simultaneous support
+# of 'long long' and 'unsigned long long'. We don't want to say that
+# 'long long' is available if 'unsigned long long' is not, or vice versa,
+# because too many programs rely on the symmetry between signed and unsigned
+# integer types (excluding 'bool').
+AC_DEFUN([_AC_TYPE_LONG_LONG_SNIPPET],
+[
+  AC_LANG_PROGRAM(
+    [[/* For now, do not test the preprocessor; as of 2007 there are too many
+         implementations with broken preprocessors.  Perhaps this can
+         be revisited in 2012.  In the meantime, code should not expect
+         #if to work with literals wider than 32 bits.  */
+      /* Test literals.  */
+      long long int ll = 9223372036854775807ll;
+      long long int nll = -9223372036854775807LL;
+      unsigned long long int ull = 18446744073709551615ULL;
+      /* Test constant expressions.   */
+      typedef int a[((-9223372036854775807LL < 0 && 0 < 9223372036854775807ll)
+                     ? 1 : -1)];
+      typedef int b[(18446744073709551615ULL <= (unsigned long long int) -1
+                     ? 1 : -1)];
+      int i = 63;]],
+    [[/* Test availability of runtime routines for shift and division.  */
+      long long int llmax = 9223372036854775807ll;
+      unsigned long long int ullmax = 18446744073709551615ull;
+      return ((ll << 63) | (ll >> 63) | (ll < i) | (ll > i)
+              | (llmax / ll) | (llmax % ll)
+              | (ull << 63) | (ull >> 63) | (ull << i) | (ull >> i)
+              | (ullmax / ull) | (ullmax % ull));]])
+])
--- /dev/null
+++ b/gl/m4/lstat.m4
@@ -0,0 +1,28 @@
+# serial 20
+
+# Copyright (C) 1997-2001, 2003-2010 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+dnl From Jim Meyering.
+
+AC_DEFUN([gl_FUNC_LSTAT],
+[
+  AC_REQUIRE([gl_SYS_STAT_H_DEFAULTS])
+  dnl If lstat does not exist, the replacement <sys/stat.h> does
+  dnl "#define lstat stat", and lstat.c is a no-op.
+  AC_CHECK_FUNCS_ONCE([lstat])
+  if test $ac_cv_func_lstat = yes; then
+    AC_REQUIRE([AC_FUNC_LSTAT_FOLLOWS_SLASHED_SYMLINK])
+    if test $ac_cv_func_lstat_dereferences_slashed_symlink = no; then
+      dnl Note: AC_FUNC_LSTAT_FOLLOWS_SLASHED_SYMLINK does AC_LIBOBJ([lstat]).
+      REPLACE_LSTAT=1
+    fi
+    # Prerequisites of lib/lstat.c.
+    AC_REQUIRE([AC_C_INLINE])
+  else
+    HAVE_LSTAT=0
+  fi
+])
--- /dev/null
+++ b/gl/m4/malloc.m4
@@ -0,0 +1,41 @@
+# malloc.m4 serial 9
+dnl Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# gl_FUNC_MALLOC_POSIX
+# --------------------
+# Test whether 'malloc' is POSIX compliant (sets errno to ENOMEM when it
+# fails), and replace malloc if it is not.
+AC_DEFUN([gl_FUNC_MALLOC_POSIX],
+[
+  AC_REQUIRE([gl_CHECK_MALLOC_POSIX])
+  if test $gl_cv_func_malloc_posix = yes; then
+    HAVE_MALLOC_POSIX=1
+    AC_DEFINE([HAVE_MALLOC_POSIX], [1],
+      [Define if the 'malloc' function is POSIX compliant.])
+  else
+    AC_LIBOBJ([malloc])
+    HAVE_MALLOC_POSIX=0
+  fi
+  AC_SUBST([HAVE_MALLOC_POSIX])
+])
+
+# Test whether malloc, realloc, calloc are POSIX compliant,
+# Set gl_cv_func_malloc_posix to yes or no accordingly.
+AC_DEFUN([gl_CHECK_MALLOC_POSIX],
+[
+  AC_CACHE_CHECK([whether malloc, realloc, calloc are POSIX compliant],
+    [gl_cv_func_malloc_posix],
+    [
+      dnl It is too dangerous to try to allocate a large amount of memory:
+      dnl some systems go to their knees when you do that. So assume that
+      dnl all Unix implementations of the function are POSIX compliant.
+      AC_TRY_COMPILE([],
+        [#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+         choke me
+         #endif
+        ], [gl_cv_func_malloc_posix=yes], [gl_cv_func_malloc_posix=no])
+    ])
+])
--- /dev/null
+++ b/gl/m4/malloca.m4
@@ -0,0 +1,15 @@
+# malloca.m4 serial 1
+dnl Copyright (C) 2003-2004, 2006-2007, 2009-2010 Free Software Foundation,
+dnl Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_MALLOCA],
+[
+  dnl Use the autoconf tests for alloca(), but not the AC_SUBSTed variables
+  dnl @ALLOCA@ and @LTALLOCA@.
+  dnl gl_FUNC_ALLOCA   dnl Already brought in by the module dependencies.
+  AC_REQUIRE([gl_EEMALLOC])
+  AC_REQUIRE([AC_TYPE_LONG_LONG_INT])
+])
--- a/gl/m4/manywarnings.m4
+++ b/gl/m4/manywarnings.m4
@@ -1,5 +1,5 @@
 # manywarnings.m4 serial 1
-dnl Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+dnl Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
--- /dev/null
+++ b/gl/m4/mode_t.m4
@@ -0,0 +1,26 @@
+# mode_t.m4 serial 2
+dnl Copyright (C) 2009-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# For using mode_t, it's sufficient to use AC_TYPE_MODE_T and
+# include <sys/types.h>.
+
+# Define PROMOTED_MODE_T to the type that is the result of "default argument
+# promotion" (ISO C 6.5.2.2.(6)) of the type mode_t.
+AC_DEFUN([gl_PROMOTED_TYPE_MODE_T],
+[
+  AC_REQUIRE([AC_TYPE_MODE_T])
+  AC_CACHE_CHECK([for promoted mode_t type], [gl_cv_promoted_mode_t], [
+    dnl Assume mode_t promotes to 'int' if and only if it is smaller than 'int',
+    dnl and to itself otherwise. This assumption is not guaranteed by the ISO C
+    dnl standard, but we don't know of any real-world counterexamples.
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/types.h>]],
+      [[typedef int array[2 * (sizeof (mode_t) < sizeof (int)) - 1];]])],
+      [gl_cv_promoted_mode_t='int'],
+      [gl_cv_promoted_mode_t='mode_t'])
+  ])
+  AC_DEFINE_UNQUOTED([PROMOTED_MODE_T], [$gl_cv_promoted_mode_t],
+    [Define to the type that is the result of default argument promotions of type mode_t.])
+])
--- /dev/null
+++ b/gl/m4/multiarch.m4
@@ -0,0 +1,65 @@
+# multiarch.m4 serial 5
+dnl Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# Determine whether the compiler is or may be producing universal binaries.
+#
+# On MacOS X 10.5 and later systems, the user can create libraries and
+# executables that work on multiple system types--known as "fat" or
+# "universal" binaries--by specifying multiple '-arch' options to the
+# compiler but only a single '-arch' option to the preprocessor.  Like
+# this:
+#
+#     ./configure CC="gcc -arch i386 -arch x86_64 -arch ppc -arch ppc64" \
+#                 CXX="g++ -arch i386 -arch x86_64 -arch ppc -arch ppc64" \
+#                 CPP="gcc -E" CXXCPP="g++ -E"
+#
+# Detect this situation and set the macro AA_APPLE_UNIVERSAL_BUILD at the
+# beginning of config.h and set APPLE_UNIVERSAL_BUILD accordingly.
+
+AC_DEFUN_ONCE([gl_MULTIARCH],
+[
+  dnl Code similar to autoconf-2.63 AC_C_BIGENDIAN.
+  gl_cv_c_multiarch=no
+  AC_COMPILE_IFELSE(
+    [AC_LANG_SOURCE(
+      [[#ifndef __APPLE_CC__
+         not a universal capable compiler
+        #endif
+        typedef int dummy;
+      ]])],
+    [
+     dnl Check for potential -arch flags.  It is not universal unless
+     dnl there are at least two -arch flags with different values.
+     arch=
+     prev=
+     for word in ${CC} ${CFLAGS} ${CPPFLAGS} ${LDFLAGS}; do
+       if test -n "$prev"; then
+         case $word in
+           i?86 | x86_64 | ppc | ppc64)
+             if test -z "$arch" || test "$arch" = "$word"; then
+               arch="$word"
+             else
+               gl_cv_c_multiarch=yes
+             fi
+             ;;
+         esac
+         prev=
+       else
+         if test "x$word" = "x-arch"; then
+           prev=arch
+         fi
+       fi
+     done
+    ])
+  if test $gl_cv_c_multiarch = yes; then
+    AC_DEFINE([AA_APPLE_UNIVERSAL_BUILD], [1],
+      [Define if the compiler is building for multiple architectures of Apple platforms at once.])
+    APPLE_UNIVERSAL_BUILD=1
+  else
+    APPLE_UNIVERSAL_BUILD=0
+  fi
+  AC_SUBST([APPLE_UNIVERSAL_BUILD])
+])
--- /dev/null
+++ b/gl/m4/open.m4
@@ -0,0 +1,74 @@
+# open.m4 serial 8
+dnl Copyright (C) 2007-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FUNC_OPEN],
+[
+  AC_REQUIRE([AC_CANONICAL_HOST])
+  case "$host_os" in
+    mingw* | pw*)
+      gl_REPLACE_OPEN
+      ;;
+    *)
+      dnl open("foo/") should not create a file when the file name has a
+      dnl trailing slash.  FreeBSD only has the problem on symlinks.
+      AC_CHECK_FUNCS_ONCE([lstat])
+      AC_CACHE_CHECK([whether open recognizes a trailing slash],
+        [gl_cv_func_open_slash],
+        [# Assume that if we have lstat, we can also check symlinks.
+          if test $ac_cv_func_lstat = yes; then
+            touch conftest.tmp
+            ln -s conftest.tmp conftest.lnk
+          fi
+          AC_TRY_RUN([
+#include <fcntl.h>
+#if HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+int main ()
+{
+#if HAVE_LSTAT
+  if (open ("conftest.lnk/", O_RDONLY) != -1) return 2;
+#endif
+  return open ("conftest.sl/", O_CREAT, 0600) >= 0;
+}], [gl_cv_func_open_slash=yes], [gl_cv_func_open_slash=no],
+            [
+changequote(,)dnl
+             case "$host_os" in
+               freebsd*)        gl_cv_func_open_slash="guessing no" ;;
+               solaris2.[0-9]*) gl_cv_func_open_slash="guessing no" ;;
+               hpux*)           gl_cv_func_open_slash="guessing no" ;;
+               *)               gl_cv_func_open_slash="guessing yes" ;;
+             esac
+changequote([,])dnl
+            ])
+          rm -f conftest.sl conftest.tmp conftest.lnk
+        ])
+      case "$gl_cv_func_open_slash" in
+        *no)
+          AC_DEFINE([OPEN_TRAILING_SLASH_BUG], [1],
+            [Define to 1 if open() fails to recognize a trailing slash.])
+          gl_REPLACE_OPEN
+          ;;
+      esac
+      ;;
+  esac
+])
+
+AC_DEFUN([gl_REPLACE_OPEN],
+[
+  AC_REQUIRE([gl_FCNTL_H_DEFAULTS])
+  REPLACE_OPEN=1
+  AC_LIBOBJ([open])
+  gl_PREREQ_OPEN
+])
+
+# Prerequisites of lib/open.c.
+AC_DEFUN([gl_PREREQ_OPEN],
+[
+  AC_REQUIRE([AC_C_INLINE])
+  AC_REQUIRE([gl_PROMOTED_TYPE_MODE_T])
+  :
+])
--- /dev/null
+++ b/gl/m4/pathmax.m4
@@ -0,0 +1,13 @@
+# pathmax.m4 serial 8
+dnl Copyright (C) 2002-2003, 2005-2006, 2009-2010 Free Software Foundation,
+dnl Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_PATHMAX],
+[
+  dnl Prerequisites of lib/pathmax.h.
+  AC_CHECK_FUNCS_ONCE([pathconf])
+  AC_CHECK_HEADERS_ONCE([sys/param.h])
+])
--- a/gl/m4/pmccabe2html.m4
+++ /dev/null
@@ -1,14 +0,0 @@
-# pmccabe2html.m4 serial 2
-dnl Copyright (C) 2008, 2009 Free Software Foundation, Inc.
-dnl This file is free software; the Free Software Foundation
-dnl gives unlimited permission to copy and/or distribute it,
-dnl with or without modifications, as long as this notice is preserved.
-
-dnl From Simon Josefsson
-
-# Usage: gl_PMCCABE2HTML([]).
-AC_DEFUN([gl_PMCCABE2HTML],
-[
-  AC_REQUIRE([AC_PROG_AWK])
-  AC_PATH_PROG([PMCCABE], [pmccabe], [false])
-])
--- /dev/null
+++ b/gl/m4/putenv.m4
@@ -0,0 +1,41 @@
+# putenv.m4 serial 16
+dnl Copyright (C) 2002-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Jim Meyering.
+dnl
+dnl Check whether putenv ("FOO") removes FOO from the environment.
+dnl The putenv in libc on at least SunOS 4.1.4 does *not* do that.
+
+AC_DEFUN([gl_FUNC_PUTENV],
+[
+  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])
+  AC_CACHE_CHECK([for putenv compatible with GNU and SVID],
+   [gl_cv_func_svid_putenv],
+   [AC_RUN_IFELSE([AC_LANG_PROGRAM([AC_INCLUDES_DEFAULT],[[
+    /* Put it in env.  */
+    if (putenv ("CONFTEST_putenv=val"))
+      return 1;
+
+    /* Try to remove it.  */
+    if (putenv ("CONFTEST_putenv"))
+      return 1;
+
+    /* Make sure it was deleted.  */
+    if (getenv ("CONFTEST_putenv") != 0)
+      return 1;
+
+    return 0;
+              ]])],
+             gl_cv_func_svid_putenv=yes,
+             gl_cv_func_svid_putenv=no,
+             dnl When crosscompiling, assume putenv is broken.
+             gl_cv_func_svid_putenv=no)
+   ])
+  if test $gl_cv_func_svid_putenv = no; then
+    REPLACE_PUTENV=1
+    AC_LIBOBJ([putenv])
+  fi
+])
--- /dev/null
+++ b/gl/m4/setenv.m4
@@ -0,0 +1,111 @@
+# setenv.m4 serial 16
+dnl Copyright (C) 2001-2004, 2006-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FUNC_SETENV],
+[
+  AC_REQUIRE([gl_FUNC_SETENV_SEPARATE])
+  if test $HAVE_SETENV$REPLACE_SETENV != 10; then
+    AC_LIBOBJ([setenv])
+  fi
+])
+
+# Like gl_FUNC_SETENV, except prepare for separate compilation (no AC_LIBOBJ).
+AC_DEFUN([gl_FUNC_SETENV_SEPARATE],
+[
+  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])
+  AC_CHECK_FUNCS_ONCE([setenv])
+  if test $ac_cv_func_setenv = no; then
+    HAVE_SETENV=0
+  else
+    AC_CACHE_CHECK([whether setenv validates arguments],
+      [gl_cv_func_setenv_works],
+      [AC_RUN_IFELSE([AC_LANG_PROGRAM([[
+       #include <stdlib.h>
+       #include <errno.h>
+       #include <string.h>
+      ]], [[
+       if (setenv ("", "", 0) != -1) return 1;
+       if (errno != EINVAL) return 2;
+       if (setenv ("a", "=", 1) != 0) return 3;
+       if (strcmp (getenv ("a"), "=") != 0) return 4;
+      ]])],
+      [gl_cv_func_setenv_works=yes], [gl_cv_func_setenv_works=no],
+      [gl_cv_func_setenv_works="guessing no"])])
+    if test "$gl_cv_func_setenv_works" != yes; then
+      REPLACE_SETENV=1
+      AC_LIBOBJ([setenv])
+    fi
+  fi
+  gl_PREREQ_SETENV
+])
+
+AC_DEFUN([gl_FUNC_UNSETENV],
+[
+  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])
+  AC_CHECK_FUNCS([unsetenv])
+  if test $ac_cv_func_unsetenv = no; then
+    HAVE_UNSETENV=0
+    AC_LIBOBJ([unsetenv])
+    gl_PREREQ_UNSETENV
+  else
+    dnl Some BSDs return void, failing to do error checking.
+    AC_CACHE_CHECK([for unsetenv() return type], [gt_cv_func_unsetenv_ret],
+      [AC_TRY_COMPILE([#include <stdlib.h>
+extern
+#ifdef __cplusplus
+"C"
+#endif
+#if defined(__STDC__) || defined(__cplusplus)
+int unsetenv (const char *name);
+#else
+int unsetenv();
+#endif
+], , gt_cv_func_unsetenv_ret='int', gt_cv_func_unsetenv_ret='void')])
+    if test $gt_cv_func_unsetenv_ret = 'void'; then
+      AC_DEFINE([VOID_UNSETENV], [1], [Define to 1 if unsetenv returns void
+       instead of int.])
+      REPLACE_UNSETENV=1
+      AC_LIBOBJ([unsetenv])
+    fi
+
+    dnl Solaris 10 unsetenv does not remove all copies of a name.
+    AC_CACHE_CHECK([whether unsetenv works on duplicates],
+      [gl_cv_func_unsetenv_works],
+      [AC_RUN_IFELSE([AC_LANG_PROGRAM([[
+       #include <stdlib.h>
+      ]], [[
+       char entry[] = "b=2";
+       if (putenv ((char *) "a=1")) return 1;
+       if (putenv (entry)) return 2;
+       entry[0] = 'a';
+       unsetenv ("a");
+       if (getenv ("a")) return 3;
+      ]])],
+      [gl_cv_func_unsetenv_works=yes], [gl_cv_func_unsetenv_works=no],
+      [gl_cv_func_unsetenv_works="guessing no"])])
+    if test "$gl_cv_func_unsetenv_works" != yes; then
+      REPLACE_UNSETENV=1
+      AC_LIBOBJ([unsetenv])
+    fi
+  fi
+])
+
+# Prerequisites of lib/setenv.c.
+AC_DEFUN([gl_PREREQ_SETENV],
+[
+  AC_REQUIRE([AC_FUNC_ALLOCA])
+  AC_REQUIRE([gl_ENVIRON])
+  AC_CHECK_HEADERS_ONCE([unistd.h])
+  AC_CHECK_HEADERS([search.h])
+  AC_CHECK_FUNCS([tsearch])
+])
+
+# Prerequisites of lib/unsetenv.c.
+AC_DEFUN([gl_PREREQ_UNSETENV],
+[
+  AC_REQUIRE([gl_ENVIRON])
+  AC_CHECK_HEADERS_ONCE([unistd.h])
+])
--- /dev/null
+++ b/gl/m4/stat.m4
@@ -0,0 +1,63 @@
+# serial 4
+
+# Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FUNC_STAT],
+[
+  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles
+  AC_REQUIRE([gl_AC_DOS])
+  AC_REQUIRE([gl_SYS_STAT_H_DEFAULTS])
+  AC_CHECK_FUNCS_ONCE([lstat])
+  dnl mingw is the only known platform where stat(".") and stat("./") differ
+  AC_CACHE_CHECK([whether stat handles trailing slashes on directories],
+      [gl_cv_func_stat_dir_slash],
+      [AC_RUN_IFELSE(
+         [AC_LANG_PROGRAM(
+           [[#include <sys/stat.h>
+]], [[struct stat st; return stat (".", &st) != stat ("./", &st);]])],
+         [gl_cv_func_stat_dir_slash=yes], [gl_cv_func_stat_dir_slash=no],
+         [case $host_os in
+            mingw*) gl_cv_func_stat_dir_slash="guessing no";;
+            *) gl_cv_func_stat_dir_slash="guessing yes";;
+          esac])])
+  dnl Solaris 9 mistakenly succeeds on stat("file/")
+  dnl FreeBSD 7.2 mistakenly succeeds on stat("link-to-file/")
+  AC_CACHE_CHECK([whether stat handles trailing slashes on files],
+      [gl_cv_func_stat_file_slash],
+      [touch conftest.tmp
+       # Assume that if we have lstat, we can also check symlinks.
+       if test $ac_cv_func_lstat = yes; then
+         ln -s conftest.tmp conftest.lnk
+       fi
+       AC_RUN_IFELSE(
+         [AC_LANG_PROGRAM(
+           [[#include <sys/stat.h>
+]], [[struct stat st;
+      if (!stat ("conftest.tmp/", &st)) return 1;
+#if HAVE_LSTAT
+      if (!stat ("conftest.lnk/", &st)) return 2;
+#endif
+           ]])],
+         [gl_cv_func_stat_file_slash=yes], [gl_cv_func_stat_file_slash=no],
+         [gl_cv_func_stat_file_slash="guessing no"])
+       rm -f conftest.tmp conftest.lnk])
+  case $gl_cv_func_stat_dir_slash in
+    *no) REPLACE_STAT=1
+      AC_DEFINE([REPLACE_FUNC_STAT_DIR], [1], [Define to 1 if stat needs
+        help when passed a directory name with a trailing slash]);;
+  esac
+  case $gl_cv_func_stat_file_slash in
+    *no) REPLACE_STAT=1
+      AC_DEFINE([REPLACE_FUNC_STAT_FILE], [1], [Define to 1 if stat needs
+        help when passed a file name with a trailing slash]);;
+  esac
+  if test $REPLACE_STAT = 1; then
+    AC_LIBOBJ([stat])
+    dnl Prerequisites of lib/stat.c.
+    AC_REQUIRE([AC_C_INLINE])
+  fi
+])
--- a/gl/m4/stdarg.m4
+++ b/gl/m4/stdarg.m4
@@ -1,5 +1,5 @@
 # stdarg.m4 serial 3
-dnl Copyright (C) 2006, 2008-2009 Free Software Foundation, Inc.
+dnl Copyright (C) 2006, 2008-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
--- /dev/null
+++ b/gl/m4/stdbool.m4
@@ -0,0 +1,115 @@
+# Check for stdbool.h that conforms to C99.
+
+dnl Copyright (C) 2002-2006, 2009-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# Prepare for substituting <stdbool.h> if it is not supported.
+
+AC_DEFUN([AM_STDBOOL_H],
+[
+  AC_REQUIRE([AC_HEADER_STDBOOL])
+
+  # Define two additional variables used in the Makefile substitution.
+
+  if test "$ac_cv_header_stdbool_h" = yes; then
+    STDBOOL_H=''
+  else
+    STDBOOL_H='stdbool.h'
+  fi
+  AC_SUBST([STDBOOL_H])
+
+  if test "$ac_cv_type__Bool" = yes; then
+    HAVE__BOOL=1
+  else
+    HAVE__BOOL=0
+  fi
+  AC_SUBST([HAVE__BOOL])
+])
+
+# AM_STDBOOL_H will be renamed to gl_STDBOOL_H in the future.
+AC_DEFUN([gl_STDBOOL_H], [AM_STDBOOL_H])
+
+# This macro is only needed in autoconf <= 2.59.  Newer versions of autoconf
+# have this macro built-in.
+
+AC_DEFUN([AC_HEADER_STDBOOL],
+  [AC_CACHE_CHECK([for stdbool.h that conforms to C99],
+     [ac_cv_header_stdbool_h],
+     [AC_TRY_COMPILE(
+        [
+          #include <stdbool.h>
+          #ifndef bool
+           "error: bool is not defined"
+          #endif
+          #ifndef false
+           "error: false is not defined"
+          #endif
+          #if false
+           "error: false is not 0"
+          #endif
+          #ifndef true
+           "error: true is not defined"
+          #endif
+          #if true != 1
+           "error: true is not 1"
+          #endif
+          #ifndef __bool_true_false_are_defined
+           "error: __bool_true_false_are_defined is not defined"
+          #endif
+
+          struct s { _Bool s: 1; _Bool t; } s;
+
+          char a[true == 1 ? 1 : -1];
+          char b[false == 0 ? 1 : -1];
+          char c[__bool_true_false_are_defined == 1 ? 1 : -1];
+          char d[(bool) 0.5 == true ? 1 : -1];
+          bool e = &s;
+          char f[(_Bool) 0.0 == false ? 1 : -1];
+          char g[true];
+          char h[sizeof (_Bool)];
+          char i[sizeof s.t];
+          enum { j = false, k = true, l = false * true, m = true * 256 };
+          _Bool n[m];
+          char o[sizeof n == m * sizeof n[0] ? 1 : -1];
+          char p[-1 - (_Bool) 0 < 0 && -1 - (bool) 0 < 0 ? 1 : -1];
+          #if defined __xlc__ || defined __GNUC__
+           /* Catch a bug in IBM AIX xlc compiler version 6.0.0.0
+              reported by James Lemley on 2005-10-05; see
+              http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html
+              This test is not quite right, since xlc is allowed to
+              reject this program, as the initializer for xlcbug is
+              not one of the forms that C requires support for.
+              However, doing the test right would require a run-time
+              test, and that would make cross-compilation harder.
+              Let us hope that IBM fixes the xlc bug, and also adds
+              support for this kind of constant expression.  In the
+              meantime, this test will reject xlc, which is OK, since
+              our stdbool.h substitute should suffice.  We also test
+              this with GCC, where it should work, to detect more
+              quickly whether someone messes up the test in the
+              future.  */
+           char digs[] = "0123456789";
+           int xlcbug = 1 / (&(digs + 5)[-2 + (bool) 1] == &digs[4] ? 1 : -1);
+          #endif
+          /* Catch a bug in an HP-UX C compiler.  See
+             http://gcc.gnu.org/ml/gcc-patches/2003-12/msg02303.html
+             http://lists.gnu.org/archive/html/bug-coreutils/2005-11/msg00161.html
+           */
+          _Bool q = true;
+          _Bool *pq = &q;
+        ],
+        [
+          *pq |= q;
+          *pq |= ! q;
+          /* Refer to every declared value, to avoid compiler optimizations.  */
+          return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
+                  + !m + !n + !o + !p + !q + !pq);
+        ],
+        [ac_cv_header_stdbool_h=yes],
+        [ac_cv_header_stdbool_h=no])])
+   AC_CHECK_TYPES([_Bool])
+   if test $ac_cv_header_stdbool_h = yes; then
+     AC_DEFINE([HAVE_STDBOOL_H], [1], [Define to 1 if stdbool.h conforms to C99.])
+   fi])
--- /dev/null
+++ b/gl/m4/stddef_h.m4
@@ -0,0 +1,45 @@
+dnl A placeholder for POSIX 2008 <stddef.h>, for platforms that have issues.
+# stddef_h.m4 serial 2
+dnl Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_STDDEF_H],
+[
+  AC_REQUIRE([gl_STDDEF_H_DEFAULTS])
+  AC_REQUIRE([gt_TYPE_WCHAR_T])
+  if test $gt_cv_c_wchar_t = no; then
+    HAVE_WCHAR_T=0
+    STDDEF_H=stddef.h
+  fi
+  AC_CACHE_CHECK([whether NULL can be used in arbitrary expressions],
+    [gl_cv_decl_null_works],
+    [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <stddef.h>
+      int test[2 * (sizeof NULL == sizeof (void *)) -1];
+]])],
+      [gl_cv_decl_null_works=yes],
+      [gl_cv_decl_null_works=no])])
+  if test $gl_cv_decl_null_works = no; then
+    REPLACE_NULL=1
+    STDDEF_H=stddef.h
+  fi
+  if test -n "$STDDEF_H"; then
+    gl_CHECK_NEXT_HEADERS([stddef.h])
+  fi
+])
+
+AC_DEFUN([gl_STDDEF_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_STDDEF_H_DEFAULTS])
+  gl_MODULE_INDICATOR_SET_VARIABLE([$1])
+])
+
+AC_DEFUN([gl_STDDEF_H_DEFAULTS],
+[
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  REPLACE_NULL=0;                AC_SUBST([REPLACE_NULL])
+  HAVE_WCHAR_T=1;                AC_SUBST([HAVE_WCHAR_T])
+  STDDEF_H='';                   AC_SUBST([STDDEF_H])
+])
--- /dev/null
+++ b/gl/m4/stdint.m4
@@ -0,0 +1,472 @@
+# stdint.m4 serial 35
+dnl Copyright (C) 2001-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Paul Eggert and Bruno Haible.
+dnl Test whether <stdint.h> is supported or must be substituted.
+
+AC_DEFUN([gl_STDINT_H],
+[
+  AC_PREREQ([2.59])dnl
+
+  dnl Check for long long int and unsigned long long int.
+  AC_REQUIRE([AC_TYPE_LONG_LONG_INT])
+  if test $ac_cv_type_long_long_int = yes; then
+    HAVE_LONG_LONG_INT=1
+  else
+    HAVE_LONG_LONG_INT=0
+  fi
+  AC_SUBST([HAVE_LONG_LONG_INT])
+  AC_REQUIRE([AC_TYPE_UNSIGNED_LONG_LONG_INT])
+  if test $ac_cv_type_unsigned_long_long_int = yes; then
+    HAVE_UNSIGNED_LONG_LONG_INT=1
+  else
+    HAVE_UNSIGNED_LONG_LONG_INT=0
+  fi
+  AC_SUBST([HAVE_UNSIGNED_LONG_LONG_INT])
+
+  dnl Check for <inttypes.h>.
+  dnl AC_INCLUDES_DEFAULT defines $ac_cv_header_inttypes_h.
+  if test $ac_cv_header_inttypes_h = yes; then
+    HAVE_INTTYPES_H=1
+  else
+    HAVE_INTTYPES_H=0
+  fi
+  AC_SUBST([HAVE_INTTYPES_H])
+
+  dnl Check for <sys/types.h>.
+  dnl AC_INCLUDES_DEFAULT defines $ac_cv_header_sys_types_h.
+  if test $ac_cv_header_sys_types_h = yes; then
+    HAVE_SYS_TYPES_H=1
+  else
+    HAVE_SYS_TYPES_H=0
+  fi
+  AC_SUBST([HAVE_SYS_TYPES_H])
+
+  gl_CHECK_NEXT_HEADERS([stdint.h])
+  if test $ac_cv_header_stdint_h = yes; then
+    HAVE_STDINT_H=1
+  else
+    HAVE_STDINT_H=0
+  fi
+  AC_SUBST([HAVE_STDINT_H])
+
+  dnl Now see whether we need a substitute <stdint.h>.
+  if test $ac_cv_header_stdint_h = yes; then
+    AC_CACHE_CHECK([whether stdint.h conforms to C99],
+      [gl_cv_header_working_stdint_h],
+      [gl_cv_header_working_stdint_h=no
+       AC_COMPILE_IFELSE([
+         AC_LANG_PROGRAM([[
+#define __STDC_LIMIT_MACROS 1 /* to make it work also in C++ mode */
+#define __STDC_CONSTANT_MACROS 1 /* to make it work also in C++ mode */
+#define _GL_JUST_INCLUDE_SYSTEM_STDINT_H 1 /* work if build isn't clean */
+#include <stdint.h>
+/* Dragonfly defines WCHAR_MIN, WCHAR_MAX only in <wchar.h>.  */
+#if !(defined WCHAR_MIN && defined WCHAR_MAX)
+#error "WCHAR_MIN, WCHAR_MAX not defined in <stdint.h>"
+#endif
+]
+gl_STDINT_INCLUDES
+[
+#ifdef INT8_MAX
+int8_t a1 = INT8_MAX;
+int8_t a1min = INT8_MIN;
+#endif
+#ifdef INT16_MAX
+int16_t a2 = INT16_MAX;
+int16_t a2min = INT16_MIN;
+#endif
+#ifdef INT32_MAX
+int32_t a3 = INT32_MAX;
+int32_t a3min = INT32_MIN;
+#endif
+#ifdef INT64_MAX
+int64_t a4 = INT64_MAX;
+int64_t a4min = INT64_MIN;
+#endif
+#ifdef UINT8_MAX
+uint8_t b1 = UINT8_MAX;
+#else
+typedef int b1[(unsigned char) -1 != 255 ? 1 : -1];
+#endif
+#ifdef UINT16_MAX
+uint16_t b2 = UINT16_MAX;
+#endif
+#ifdef UINT32_MAX
+uint32_t b3 = UINT32_MAX;
+#endif
+#ifdef UINT64_MAX
+uint64_t b4 = UINT64_MAX;
+#endif
+int_least8_t c1 = INT8_C (0x7f);
+int_least8_t c1max = INT_LEAST8_MAX;
+int_least8_t c1min = INT_LEAST8_MIN;
+int_least16_t c2 = INT16_C (0x7fff);
+int_least16_t c2max = INT_LEAST16_MAX;
+int_least16_t c2min = INT_LEAST16_MIN;
+int_least32_t c3 = INT32_C (0x7fffffff);
+int_least32_t c3max = INT_LEAST32_MAX;
+int_least32_t c3min = INT_LEAST32_MIN;
+int_least64_t c4 = INT64_C (0x7fffffffffffffff);
+int_least64_t c4max = INT_LEAST64_MAX;
+int_least64_t c4min = INT_LEAST64_MIN;
+uint_least8_t d1 = UINT8_C (0xff);
+uint_least8_t d1max = UINT_LEAST8_MAX;
+uint_least16_t d2 = UINT16_C (0xffff);
+uint_least16_t d2max = UINT_LEAST16_MAX;
+uint_least32_t d3 = UINT32_C (0xffffffff);
+uint_least32_t d3max = UINT_LEAST32_MAX;
+uint_least64_t d4 = UINT64_C (0xffffffffffffffff);
+uint_least64_t d4max = UINT_LEAST64_MAX;
+int_fast8_t e1 = INT_FAST8_MAX;
+int_fast8_t e1min = INT_FAST8_MIN;
+int_fast16_t e2 = INT_FAST16_MAX;
+int_fast16_t e2min = INT_FAST16_MIN;
+int_fast32_t e3 = INT_FAST32_MAX;
+int_fast32_t e3min = INT_FAST32_MIN;
+int_fast64_t e4 = INT_FAST64_MAX;
+int_fast64_t e4min = INT_FAST64_MIN;
+uint_fast8_t f1 = UINT_FAST8_MAX;
+uint_fast16_t f2 = UINT_FAST16_MAX;
+uint_fast32_t f3 = UINT_FAST32_MAX;
+uint_fast64_t f4 = UINT_FAST64_MAX;
+#ifdef INTPTR_MAX
+intptr_t g = INTPTR_MAX;
+intptr_t gmin = INTPTR_MIN;
+#endif
+#ifdef UINTPTR_MAX
+uintptr_t h = UINTPTR_MAX;
+#endif
+intmax_t i = INTMAX_MAX;
+uintmax_t j = UINTMAX_MAX;
+
+#include <limits.h> /* for CHAR_BIT */
+#define TYPE_MINIMUM(t) \
+  ((t) ((t) 0 < (t) -1 ? (t) 0 : ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1)))
+#define TYPE_MAXIMUM(t) \
+  ((t) ((t) 0 < (t) -1 ? (t) -1 : ~ (~ (t) 0 << (sizeof (t) * CHAR_BIT - 1))))
+struct s {
+  int check_PTRDIFF:
+      PTRDIFF_MIN == TYPE_MINIMUM (ptrdiff_t)
+      && PTRDIFF_MAX == TYPE_MAXIMUM (ptrdiff_t)
+      ? 1 : -1;
+  /* Detect bug in FreeBSD 6.0 / ia64.  */
+  int check_SIG_ATOMIC:
+      SIG_ATOMIC_MIN == TYPE_MINIMUM (sig_atomic_t)
+      && SIG_ATOMIC_MAX == TYPE_MAXIMUM (sig_atomic_t)
+      ? 1 : -1;
+  int check_SIZE: SIZE_MAX == TYPE_MAXIMUM (size_t) ? 1 : -1;
+  int check_WCHAR:
+      WCHAR_MIN == TYPE_MINIMUM (wchar_t)
+      && WCHAR_MAX == TYPE_MAXIMUM (wchar_t)
+      ? 1 : -1;
+  /* Detect bug in mingw.  */
+  int check_WINT:
+      WINT_MIN == TYPE_MINIMUM (wint_t)
+      && WINT_MAX == TYPE_MAXIMUM (wint_t)
+      ? 1 : -1;
+
+  /* Detect bugs in glibc 2.4 and Solaris 10 stdint.h, among others.  */
+  int check_UINT8_C:
+        (-1 < UINT8_C (0)) == (-1 < (uint_least8_t) 0) ? 1 : -1;
+  int check_UINT16_C:
+        (-1 < UINT16_C (0)) == (-1 < (uint_least16_t) 0) ? 1 : -1;
+
+  /* Detect bugs in OpenBSD 3.9 stdint.h.  */
+#ifdef UINT8_MAX
+  int check_uint8: (uint8_t) -1 == UINT8_MAX ? 1 : -1;
+#endif
+#ifdef UINT16_MAX
+  int check_uint16: (uint16_t) -1 == UINT16_MAX ? 1 : -1;
+#endif
+#ifdef UINT32_MAX
+  int check_uint32: (uint32_t) -1 == UINT32_MAX ? 1 : -1;
+#endif
+#ifdef UINT64_MAX
+  int check_uint64: (uint64_t) -1 == UINT64_MAX ? 1 : -1;
+#endif
+  int check_uint_least8: (uint_least8_t) -1 == UINT_LEAST8_MAX ? 1 : -1;
+  int check_uint_least16: (uint_least16_t) -1 == UINT_LEAST16_MAX ? 1 : -1;
+  int check_uint_least32: (uint_least32_t) -1 == UINT_LEAST32_MAX ? 1 : -1;
+  int check_uint_least64: (uint_least64_t) -1 == UINT_LEAST64_MAX ? 1 : -1;
+  int check_uint_fast8: (uint_fast8_t) -1 == UINT_FAST8_MAX ? 1 : -1;
+  int check_uint_fast16: (uint_fast16_t) -1 == UINT_FAST16_MAX ? 1 : -1;
+  int check_uint_fast32: (uint_fast32_t) -1 == UINT_FAST32_MAX ? 1 : -1;
+  int check_uint_fast64: (uint_fast64_t) -1 == UINT_FAST64_MAX ? 1 : -1;
+  int check_uintptr: (uintptr_t) -1 == UINTPTR_MAX ? 1 : -1;
+  int check_uintmax: (uintmax_t) -1 == UINTMAX_MAX ? 1 : -1;
+  int check_size: (size_t) -1 == SIZE_MAX ? 1 : -1;
+};
+         ]])],
+         [dnl Determine whether the various *_MIN, *_MAX macros are usable
+          dnl in preprocessor expression. We could do it by compiling a test
+          dnl program for each of these macros. It is faster to run a program
+          dnl that inspects the macro expansion.
+          dnl This detects a bug on HP-UX 11.23/ia64.
+          AC_RUN_IFELSE([
+            AC_LANG_PROGRAM([[
+#define __STDC_LIMIT_MACROS 1 /* to make it work also in C++ mode */
+#define __STDC_CONSTANT_MACROS 1 /* to make it work also in C++ mode */
+#define _GL_JUST_INCLUDE_SYSTEM_STDINT_H 1 /* work if build isn't clean */
+#include <stdint.h>
+]
+gl_STDINT_INCLUDES
+[
+#include <stdio.h>
+#include <string.h>
+#define MVAL(macro) MVAL1(macro)
+#define MVAL1(expression) #expression
+static const char *macro_values[] =
+  {
+#ifdef INT8_MAX
+    MVAL (INT8_MAX),
+#endif
+#ifdef INT16_MAX
+    MVAL (INT16_MAX),
+#endif
+#ifdef INT32_MAX
+    MVAL (INT32_MAX),
+#endif
+#ifdef INT64_MAX
+    MVAL (INT64_MAX),
+#endif
+#ifdef UINT8_MAX
+    MVAL (UINT8_MAX),
+#endif
+#ifdef UINT16_MAX
+    MVAL (UINT16_MAX),
+#endif
+#ifdef UINT32_MAX
+    MVAL (UINT32_MAX),
+#endif
+#ifdef UINT64_MAX
+    MVAL (UINT64_MAX),
+#endif
+    NULL
+  };
+]], [[
+  const char **mv;
+  for (mv = macro_values; *mv != NULL; mv++)
+    {
+      const char *value = *mv;
+      /* Test whether it looks like a cast expression.  */
+      if (strncmp (value, "((unsigned int)"/*)*/, 15) == 0
+          || strncmp (value, "((unsigned short)"/*)*/, 17) == 0
+          || strncmp (value, "((unsigned char)"/*)*/, 16) == 0
+          || strncmp (value, "((int)"/*)*/, 6) == 0
+          || strncmp (value, "((signed short)"/*)*/, 15) == 0
+          || strncmp (value, "((signed char)"/*)*/, 14) == 0)
+        return 1;
+    }
+  return 0;
+]])],
+              [gl_cv_header_working_stdint_h=yes],
+              [],
+              [dnl When cross-compiling, assume it works.
+               gl_cv_header_working_stdint_h=yes
+              ])
+         ])
+      ])
+  fi
+  if test "$gl_cv_header_working_stdint_h" = yes; then
+    STDINT_H=
+  else
+    dnl Check for <sys/inttypes.h>, and for
+    dnl <sys/bitypes.h> (used in Linux libc4 >= 4.6.7 and libc5).
+    AC_CHECK_HEADERS([sys/inttypes.h sys/bitypes.h])
+    if test $ac_cv_header_sys_inttypes_h = yes; then
+      HAVE_SYS_INTTYPES_H=1
+    else
+      HAVE_SYS_INTTYPES_H=0
+    fi
+    AC_SUBST([HAVE_SYS_INTTYPES_H])
+    if test $ac_cv_header_sys_bitypes_h = yes; then
+      HAVE_SYS_BITYPES_H=1
+    else
+      HAVE_SYS_BITYPES_H=0
+    fi
+    AC_SUBST([HAVE_SYS_BITYPES_H])
+
+    dnl Check for <wchar.h> (missing in Linux uClibc when built without wide
+    dnl character support).
+    AC_CHECK_HEADERS_ONCE([wchar.h])
+
+    gl_STDINT_TYPE_PROPERTIES
+    STDINT_H=stdint.h
+  fi
+  AC_SUBST([STDINT_H])
+])
+
+dnl gl_STDINT_BITSIZEOF(TYPES, INCLUDES)
+dnl Determine the size of each of the given types in bits.
+AC_DEFUN([gl_STDINT_BITSIZEOF],
+[
+  dnl Use a shell loop, to avoid bloating configure, and
+  dnl - extra AH_TEMPLATE calls, so that autoheader knows what to put into
+  dnl   config.h.in,
+  dnl - extra AC_SUBST calls, so that the right substitutions are made.
+  m4_foreach_w([gltype], [$1],
+    [AH_TEMPLATE([BITSIZEOF_]m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]),
+       [Define to the number of bits in type ']gltype['.])])
+  for gltype in $1 ; do
+    AC_CACHE_CHECK([for bit size of $gltype], [gl_cv_bitsizeof_${gltype}],
+      [AC_COMPUTE_INT([result], [sizeof ($gltype) * CHAR_BIT],
+         [$2
+#include <limits.h>], [result=unknown])
+       eval gl_cv_bitsizeof_${gltype}=\$result
+      ])
+    eval result=\$gl_cv_bitsizeof_${gltype}
+    if test $result = unknown; then
+      dnl Use a nonempty default, because some compilers, such as IRIX 5 cc,
+      dnl do a syntax check even on unused #if conditions and give an error
+      dnl on valid C code like this:
+      dnl   #if 0
+      dnl   # if  > 32
+      dnl   # endif
+      dnl   #endif
+      result=0
+    fi
+    GLTYPE=`echo "$gltype" | tr 'abcdefghijklmnopqrstuvwxyz ' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_'`
+    AC_DEFINE_UNQUOTED([BITSIZEOF_${GLTYPE}], [$result])
+    eval BITSIZEOF_${GLTYPE}=\$result
+  done
+  m4_foreach_w([gltype], [$1],
+    [AC_SUBST([BITSIZEOF_]m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]))])
+])
+
+dnl gl_CHECK_TYPES_SIGNED(TYPES, INCLUDES)
+dnl Determine the signedness of each of the given types.
+dnl Define HAVE_SIGNED_TYPE if type is signed.
+AC_DEFUN([gl_CHECK_TYPES_SIGNED],
+[
+  dnl Use a shell loop, to avoid bloating configure, and
+  dnl - extra AH_TEMPLATE calls, so that autoheader knows what to put into
+  dnl   config.h.in,
+  dnl - extra AC_SUBST calls, so that the right substitutions are made.
+  m4_foreach_w([gltype], [$1],
+    [AH_TEMPLATE([HAVE_SIGNED_]m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]),
+       [Define to 1 if ']gltype[' is a signed integer type.])])
+  for gltype in $1 ; do
+    AC_CACHE_CHECK([whether $gltype is signed], [gl_cv_type_${gltype}_signed],
+      [AC_COMPILE_IFELSE(
+         [AC_LANG_PROGRAM([$2[
+            int verify[2 * (($gltype) -1 < ($gltype) 0) - 1];]])],
+         result=yes, result=no)
+       eval gl_cv_type_${gltype}_signed=\$result
+      ])
+    eval result=\$gl_cv_type_${gltype}_signed
+    GLTYPE=`echo $gltype | tr 'abcdefghijklmnopqrstuvwxyz ' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_'`
+    if test "$result" = yes; then
+      AC_DEFINE_UNQUOTED([HAVE_SIGNED_${GLTYPE}], [1])
+      eval HAVE_SIGNED_${GLTYPE}=1
+    else
+      eval HAVE_SIGNED_${GLTYPE}=0
+    fi
+  done
+  m4_foreach_w([gltype], [$1],
+    [AC_SUBST([HAVE_SIGNED_]m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]))])
+])
+
+dnl gl_INTEGER_TYPE_SUFFIX(TYPES, INCLUDES)
+dnl Determine the suffix to use for integer constants of the given types.
+dnl Define t_SUFFIX for each such type.
+AC_DEFUN([gl_INTEGER_TYPE_SUFFIX],
+[
+  dnl Use a shell loop, to avoid bloating configure, and
+  dnl - extra AH_TEMPLATE calls, so that autoheader knows what to put into
+  dnl   config.h.in,
+  dnl - extra AC_SUBST calls, so that the right substitutions are made.
+  m4_foreach_w([gltype], [$1],
+    [AH_TEMPLATE(m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_])[_SUFFIX],
+       [Define to l, ll, u, ul, ull, etc., as suitable for
+        constants of type ']gltype['.])])
+  for gltype in $1 ; do
+    AC_CACHE_CHECK([for $gltype integer literal suffix],
+      [gl_cv_type_${gltype}_suffix],
+      [eval gl_cv_type_${gltype}_suffix=no
+       eval result=\$gl_cv_type_${gltype}_signed
+       if test "$result" = yes; then
+         glsufu=
+       else
+         glsufu=u
+       fi
+       for glsuf in "$glsufu" ${glsufu}l ${glsufu}ll ${glsufu}i64; do
+         case $glsuf in
+           '')  gltype1='int';;
+           l)   gltype1='long int';;
+           ll)  gltype1='long long int';;
+           i64) gltype1='__int64';;
+           u)   gltype1='unsigned int';;
+           ul)  gltype1='unsigned long int';;
+           ull) gltype1='unsigned long long int';;
+           ui64)gltype1='unsigned __int64';;
+         esac
+         AC_COMPILE_IFELSE(
+           [AC_LANG_PROGRAM([$2[
+              extern $gltype foo;
+              extern $gltype1 foo;]])],
+           [eval gl_cv_type_${gltype}_suffix=\$glsuf])
+         eval result=\$gl_cv_type_${gltype}_suffix
+         test "$result" != no && break
+       done])
+    GLTYPE=`echo $gltype | tr 'abcdefghijklmnopqrstuvwxyz ' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_'`
+    eval result=\$gl_cv_type_${gltype}_suffix
+    test "$result" = no && result=
+    eval ${GLTYPE}_SUFFIX=\$result
+    AC_DEFINE_UNQUOTED([${GLTYPE}_SUFFIX], [$result])
+  done
+  m4_foreach_w([gltype], [$1],
+    [AC_SUBST(m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_])[_SUFFIX])])
+])
+
+dnl gl_STDINT_INCLUDES
+AC_DEFUN([gl_STDINT_INCLUDES],
+[[
+  /* BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be
+     included before <wchar.h>.  */
+  #include <stddef.h>
+  #include <signal.h>
+  #if HAVE_WCHAR_H
+  # include <stdio.h>
+  # include <time.h>
+  # include <wchar.h>
+  #endif
+]])
+
+dnl gl_STDINT_TYPE_PROPERTIES
+dnl Compute HAVE_SIGNED_t, BITSIZEOF_t and t_SUFFIX, for all the types t
+dnl of interest to stdint.in.h.
+AC_DEFUN([gl_STDINT_TYPE_PROPERTIES],
+[
+  AC_REQUIRE([gl_MULTIARCH])
+  if test $APPLE_UNIVERSAL_BUILD = 0; then
+    gl_STDINT_BITSIZEOF([ptrdiff_t size_t],
+      [gl_STDINT_INCLUDES])
+  fi
+  gl_STDINT_BITSIZEOF([sig_atomic_t wchar_t wint_t],
+    [gl_STDINT_INCLUDES])
+  gl_CHECK_TYPES_SIGNED([sig_atomic_t wchar_t wint_t],
+    [gl_STDINT_INCLUDES])
+  gl_cv_type_ptrdiff_t_signed=yes
+  gl_cv_type_size_t_signed=no
+  if test $APPLE_UNIVERSAL_BUILD = 0; then
+    gl_INTEGER_TYPE_SUFFIX([ptrdiff_t size_t],
+      [gl_STDINT_INCLUDES])
+  fi
+  gl_INTEGER_TYPE_SUFFIX([sig_atomic_t wchar_t wint_t],
+    [gl_STDINT_INCLUDES])
+])
+
+dnl Autoconf >= 2.61 has AC_COMPUTE_INT built-in.
+dnl Remove this when we can assume autoconf >= 2.61.
+m4_ifdef([AC_COMPUTE_INT], [], [
+  AC_DEFUN([AC_COMPUTE_INT], [_AC_COMPUTE_INT([$2],[$1],[$3],[$4])])
+])
+
+# Hey Emacs!
+# Local Variables:
+# indent-tabs-mode: nil
+# End:
--- /dev/null
+++ b/gl/m4/stdlib_h.m4
@@ -0,0 +1,110 @@
+# stdlib_h.m4 serial 28
+dnl Copyright (C) 2007-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_STDLIB_H],
+[
+  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])
+  gl_CHECK_NEXT_HEADERS([stdlib.h])
+  AC_CHECK_HEADERS([random.h], [], [], [AC_INCLUDES_DEFAULT])
+  if test $ac_cv_header_random_h = yes; then
+    HAVE_RANDOM_H=1
+  else
+    HAVE_RANDOM_H=0
+  fi
+  AC_SUBST([HAVE_RANDOM_H])
+  AC_CHECK_TYPES([struct random_data],
+    [], [HAVE_STRUCT_RANDOM_DATA=0],
+    [[#include <stdlib.h>
+      #if HAVE_RANDOM_H
+      # include <random.h>
+      #endif
+    ]])
+
+  dnl Check for declarations of anything we want to poison if the
+  dnl corresponding gnulib module is not in use, and which is not
+  dnl guaranteed by C89.
+  gl_WARN_ON_USE_PREPARE([[#include <stdlib.h>
+#if HAVE_SYS_LOADAVG_H
+# include <sys/loadavg.h>
+#endif
+#if HAVE_RANDOM_H
+# include <random.h>
+#endif
+    ]], [atoll canonicalize_file_name getloadavg getsubopt grantpt mkdtemp
+    mkostemp mkostemps mkstemp mkstemps ptsname random_r initstat_r srandom_r
+    setstate_r realpath rpmatch setenv strtod strtoll strtoull unlockpt
+    unsetenv])
+])
+
+AC_DEFUN([gl_STDLIB_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])
+  gl_MODULE_INDICATOR_SET_VARIABLE([$1])
+  dnl Define it also as a C macro, for the benefit of the unit tests.
+  gl_MODULE_INDICATOR_FOR_TESTS([$1])
+])
+
+AC_DEFUN([gl_STDLIB_H_DEFAULTS],
+[
+  GNULIB_ATOLL=0;         AC_SUBST([GNULIB_ATOLL])
+  GNULIB_CALLOC_POSIX=0;  AC_SUBST([GNULIB_CALLOC_POSIX])
+  GNULIB_CANONICALIZE_FILE_NAME=0;  AC_SUBST([GNULIB_CANONICALIZE_FILE_NAME])
+  GNULIB_GETLOADAVG=0;    AC_SUBST([GNULIB_GETLOADAVG])
+  GNULIB_GETSUBOPT=0;     AC_SUBST([GNULIB_GETSUBOPT])
+  GNULIB_GRANTPT=0;       AC_SUBST([GNULIB_GRANTPT])
+  GNULIB_MALLOC_POSIX=0;  AC_SUBST([GNULIB_MALLOC_POSIX])
+  GNULIB_MKDTEMP=0;       AC_SUBST([GNULIB_MKDTEMP])
+  GNULIB_MKOSTEMP=0;      AC_SUBST([GNULIB_MKOSTEMP])
+  GNULIB_MKOSTEMPS=0;     AC_SUBST([GNULIB_MKOSTEMPS])
+  GNULIB_MKSTEMP=0;       AC_SUBST([GNULIB_MKSTEMP])
+  GNULIB_MKSTEMPS=0;      AC_SUBST([GNULIB_MKSTEMPS])
+  GNULIB_PTSNAME=0;       AC_SUBST([GNULIB_PTSNAME])
+  GNULIB_PUTENV=0;        AC_SUBST([GNULIB_PUTENV])
+  GNULIB_RANDOM_R=0;      AC_SUBST([GNULIB_RANDOM_R])
+  GNULIB_REALLOC_POSIX=0; AC_SUBST([GNULIB_REALLOC_POSIX])
+  GNULIB_REALPATH=0;      AC_SUBST([GNULIB_REALPATH])
+  GNULIB_RPMATCH=0;       AC_SUBST([GNULIB_RPMATCH])
+  GNULIB_SETENV=0;        AC_SUBST([GNULIB_SETENV])
+  GNULIB_STRTOD=0;        AC_SUBST([GNULIB_STRTOD])
+  GNULIB_STRTOLL=0;       AC_SUBST([GNULIB_STRTOLL])
+  GNULIB_STRTOULL=0;      AC_SUBST([GNULIB_STRTOULL])
+  GNULIB_UNLOCKPT=0;      AC_SUBST([GNULIB_UNLOCKPT])
+  GNULIB_UNSETENV=0;      AC_SUBST([GNULIB_UNSETENV])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_ATOLL=1;              AC_SUBST([HAVE_ATOLL])
+  HAVE_CALLOC_POSIX=1;       AC_SUBST([HAVE_CALLOC_POSIX])
+  HAVE_CANONICALIZE_FILE_NAME=1;  AC_SUBST([HAVE_CANONICALIZE_FILE_NAME])
+  HAVE_DECL_GETLOADAVG=1;    AC_SUBST([HAVE_DECL_GETLOADAVG])
+  HAVE_GETSUBOPT=1;          AC_SUBST([HAVE_GETSUBOPT])
+  HAVE_GRANTPT=1;            AC_SUBST([HAVE_GRANTPT])
+  HAVE_MALLOC_POSIX=1;       AC_SUBST([HAVE_MALLOC_POSIX])
+  HAVE_MKDTEMP=1;            AC_SUBST([HAVE_MKDTEMP])
+  HAVE_MKOSTEMP=1;           AC_SUBST([HAVE_MKOSTEMP])
+  HAVE_MKOSTEMPS=1;          AC_SUBST([HAVE_MKOSTEMPS])
+  HAVE_MKSTEMP=1;            AC_SUBST([HAVE_MKSTEMP])
+  HAVE_MKSTEMPS=1;           AC_SUBST([HAVE_MKSTEMPS])
+  HAVE_PTSNAME=1;            AC_SUBST([HAVE_PTSNAME])
+  HAVE_RANDOM_R=1;           AC_SUBST([HAVE_RANDOM_R])
+  HAVE_REALLOC_POSIX=1;      AC_SUBST([HAVE_REALLOC_POSIX])
+  HAVE_REALPATH=1;           AC_SUBST([HAVE_REALPATH])
+  HAVE_RPMATCH=1;            AC_SUBST([HAVE_RPMATCH])
+  HAVE_SETENV=1;             AC_SUBST([HAVE_SETENV])
+  HAVE_STRTOD=1;             AC_SUBST([HAVE_STRTOD])
+  HAVE_STRTOLL=1;            AC_SUBST([HAVE_STRTOLL])
+  HAVE_STRTOULL=1;           AC_SUBST([HAVE_STRTOULL])
+  HAVE_STRUCT_RANDOM_DATA=1; AC_SUBST([HAVE_STRUCT_RANDOM_DATA])
+  HAVE_SYS_LOADAVG_H=0;      AC_SUBST([HAVE_SYS_LOADAVG_H])
+  HAVE_UNLOCKPT=1;           AC_SUBST([HAVE_UNLOCKPT])
+  HAVE_UNSETENV=1;           AC_SUBST([HAVE_UNSETENV])
+  REPLACE_CANONICALIZE_FILE_NAME=0;  AC_SUBST([REPLACE_CANONICALIZE_FILE_NAME])
+  REPLACE_MKSTEMP=0;         AC_SUBST([REPLACE_MKSTEMP])
+  REPLACE_PUTENV=0;          AC_SUBST([REPLACE_PUTENV])
+  REPLACE_REALPATH=0;        AC_SUBST([REPLACE_REALPATH])
+  REPLACE_SETENV=0;          AC_SUBST([REPLACE_SETENV])
+  REPLACE_STRTOD=0;          AC_SUBST([REPLACE_STRTOD])
+  REPLACE_UNSETENV=0;        AC_SUBST([REPLACE_UNSETENV])
+])
--- a/gl/m4/strerror.m4
+++ b/gl/m4/strerror.m4
@@ -1,5 +1,5 @@
 # strerror.m4 serial 9
-dnl Copyright (C) 2002, 2007-2008 Free Software Foundation, Inc.
+dnl Copyright (C) 2002, 2007-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
--- a/gl/m4/string_h.m4
+++ b/gl/m4/string_h.m4
@@ -1,11 +1,11 @@
 # Configure a GNU-like replacement for <string.h>.
 
-# Copyright (C) 2007, 2008 Free Software Foundation, Inc.
+# Copyright (C) 2007-2010 Free Software Foundation, Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 6
+# serial 17
 
 # Written by Paul Eggert.
 
@@ -21,17 +21,29 @@ AC_DEFUN([gl_HEADER_STRING_H_BODY],
   AC_REQUIRE([AC_C_RESTRICT])
   AC_REQUIRE([gl_HEADER_STRING_H_DEFAULTS])
   gl_CHECK_NEXT_HEADERS([string.h])
+
+  dnl Check for declarations of anything we want to poison if the
+  dnl corresponding gnulib module is not in use, and which is not
+  dnl guaranteed by C89.
+  gl_WARN_ON_USE_PREPARE([[#include <string.h>
+    ]],
+    [memmem mempcpy memrchr rawmemchr stpcpy stpncpy strchrnul strdup
+     strncat strndup strnlen strpbrk strsep strcasestr strtok_r strsignal
+     strverscmp])
 ])
 
 AC_DEFUN([gl_STRING_MODULE_INDICATOR],
 [
   dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
   AC_REQUIRE([gl_HEADER_STRING_H_DEFAULTS])
-  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
+  gl_MODULE_INDICATOR_SET_VARIABLE([$1])
+  dnl Define it also as a C macro, for the benefit of the unit tests.
+  gl_MODULE_INDICATOR_FOR_TESTS([$1])
 ])
 
 AC_DEFUN([gl_HEADER_STRING_H_DEFAULTS],
 [
+  GNULIB_MEMCHR=0;      AC_SUBST([GNULIB_MEMCHR])
   GNULIB_MEMMEM=0;      AC_SUBST([GNULIB_MEMMEM])
   GNULIB_MEMPCPY=0;     AC_SUBST([GNULIB_MEMPCPY])
   GNULIB_MEMRCHR=0;     AC_SUBST([GNULIB_MEMRCHR])
@@ -40,6 +52,7 @@ AC_DEFUN([gl_HEADER_STRING_H_DEFAULTS],
   GNULIB_STPNCPY=0;     AC_SUBST([GNULIB_STPNCPY])
   GNULIB_STRCHRNUL=0;   AC_SUBST([GNULIB_STRCHRNUL])
   GNULIB_STRDUP=0;      AC_SUBST([GNULIB_STRDUP])
+  GNULIB_STRNCAT=0;     AC_SUBST([GNULIB_STRNCAT])
   GNULIB_STRNDUP=0;     AC_SUBST([GNULIB_STRNDUP])
   GNULIB_STRNLEN=0;     AC_SUBST([GNULIB_STRNLEN])
   GNULIB_STRPBRK=0;     AC_SUBST([GNULIB_STRPBRK])
@@ -63,30 +76,37 @@ AC_DEFUN([gl_HEADER_STRING_H_DEFAULTS],
   GNULIB_MBSTOK_R=0;    AC_SUBST([GNULIB_MBSTOK_R])
   GNULIB_STRERROR=0;    AC_SUBST([GNULIB_STRERROR])
   GNULIB_STRSIGNAL=0;   AC_SUBST([GNULIB_STRSIGNAL])
-  GNULIB_STRVERSCMP=0;   AC_SUBST([GNULIB_STRVERSCMP])
+  GNULIB_STRVERSCMP=0;  AC_SUBST([GNULIB_STRVERSCMP])
+  HAVE_MBSLEN=0;        AC_SUBST([HAVE_MBSLEN])
   dnl Assume proper GNU behavior unless another module says otherwise.
-  HAVE_DECL_MEMMEM=1;		AC_SUBST([HAVE_DECL_MEMMEM])
-  HAVE_MEMPCPY=1;		AC_SUBST([HAVE_MEMPCPY])
-  HAVE_DECL_MEMRCHR=1;		AC_SUBST([HAVE_DECL_MEMRCHR])
-  HAVE_RAWMEMCHR=1;		AC_SUBST([HAVE_RAWMEMCHR])
-  HAVE_STPCPY=1;		AC_SUBST([HAVE_STPCPY])
-  HAVE_STPNCPY=1;		AC_SUBST([HAVE_STPNCPY])
-  HAVE_STRCHRNUL=1;		AC_SUBST([HAVE_STRCHRNUL])
-  HAVE_DECL_STRDUP=1;		AC_SUBST([HAVE_DECL_STRDUP])
-  HAVE_STRNDUP=1;		AC_SUBST([HAVE_STRNDUP])
-  HAVE_DECL_STRNDUP=1;		AC_SUBST([HAVE_DECL_STRNDUP])
-  HAVE_DECL_STRNLEN=1;		AC_SUBST([HAVE_DECL_STRNLEN])
-  HAVE_STRPBRK=1;		AC_SUBST([HAVE_STRPBRK])
-  HAVE_STRSEP=1;		AC_SUBST([HAVE_STRSEP])
-  HAVE_STRCASESTR=1;		AC_SUBST([HAVE_STRCASESTR])
-  HAVE_DECL_STRTOK_R=1;		AC_SUBST([HAVE_DECL_STRTOK_R])
-  HAVE_DECL_STRERROR=1;		AC_SUBST([HAVE_DECL_STRERROR])
-  HAVE_DECL_STRSIGNAL=1;	AC_SUBST([HAVE_DECL_STRSIGNAL])
-  HAVE_STRVERSCMP=1;		AC_SUBST([HAVE_STRVERSCMP])
-  REPLACE_MEMMEM=0;		AC_SUBST([REPLACE_MEMMEM])
-  REPLACE_STRDUP=0;		AC_SUBST([REPLACE_STRDUP])
-  REPLACE_STRSTR=0;		AC_SUBST([REPLACE_STRSTR])
-  REPLACE_STRCASESTR=0;		AC_SUBST([REPLACE_STRCASESTR])
-  REPLACE_STRERROR=0;		AC_SUBST([REPLACE_STRERROR])
-  REPLACE_STRSIGNAL=0;		AC_SUBST([REPLACE_STRSIGNAL])
+  HAVE_MEMCHR=1;                AC_SUBST([HAVE_MEMCHR])
+  HAVE_DECL_MEMMEM=1;           AC_SUBST([HAVE_DECL_MEMMEM])
+  HAVE_MEMPCPY=1;               AC_SUBST([HAVE_MEMPCPY])
+  HAVE_DECL_MEMRCHR=1;          AC_SUBST([HAVE_DECL_MEMRCHR])
+  HAVE_RAWMEMCHR=1;             AC_SUBST([HAVE_RAWMEMCHR])
+  HAVE_STPCPY=1;                AC_SUBST([HAVE_STPCPY])
+  HAVE_STPNCPY=1;               AC_SUBST([HAVE_STPNCPY])
+  HAVE_STRCHRNUL=1;             AC_SUBST([HAVE_STRCHRNUL])
+  HAVE_DECL_STRDUP=1;           AC_SUBST([HAVE_DECL_STRDUP])
+  HAVE_DECL_STRNDUP=1;          AC_SUBST([HAVE_DECL_STRNDUP])
+  HAVE_DECL_STRNLEN=1;          AC_SUBST([HAVE_DECL_STRNLEN])
+  HAVE_STRPBRK=1;               AC_SUBST([HAVE_STRPBRK])
+  HAVE_STRSEP=1;                AC_SUBST([HAVE_STRSEP])
+  HAVE_STRCASESTR=1;            AC_SUBST([HAVE_STRCASESTR])
+  HAVE_DECL_STRTOK_R=1;         AC_SUBST([HAVE_DECL_STRTOK_R])
+  HAVE_DECL_STRSIGNAL=1;        AC_SUBST([HAVE_DECL_STRSIGNAL])
+  HAVE_STRVERSCMP=1;            AC_SUBST([HAVE_STRVERSCMP])
+  REPLACE_MEMCHR=0;             AC_SUBST([REPLACE_MEMCHR])
+  REPLACE_MEMMEM=0;             AC_SUBST([REPLACE_MEMMEM])
+  REPLACE_STPNCPY=0;            AC_SUBST([REPLACE_STPNCPY])
+  REPLACE_STRDUP=0;             AC_SUBST([REPLACE_STRDUP])
+  REPLACE_STRSTR=0;             AC_SUBST([REPLACE_STRSTR])
+  REPLACE_STRCASESTR=0;         AC_SUBST([REPLACE_STRCASESTR])
+  REPLACE_STRERROR=0;           AC_SUBST([REPLACE_STRERROR])
+  REPLACE_STRNCAT=0;            AC_SUBST([REPLACE_STRNCAT])
+  REPLACE_STRNDUP=0;            AC_SUBST([REPLACE_STRNDUP])
+  REPLACE_STRNLEN=0;            AC_SUBST([REPLACE_STRNLEN])
+  REPLACE_STRSIGNAL=0;          AC_SUBST([REPLACE_STRSIGNAL])
+  REPLACE_STRTOK_R=0;           AC_SUBST([REPLACE_STRTOK_R])
+  UNDEFINE_STRTOK_R=0;          AC_SUBST([UNDEFINE_STRTOK_R])
 ])
--- /dev/null
+++ b/gl/m4/symlink.m4
@@ -0,0 +1,38 @@
+# serial 2
+# See if we need to provide symlink replacement.
+
+dnl Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# Written by Eric Blake.
+
+AC_DEFUN([gl_FUNC_SYMLINK],
+[
+  AC_REQUIRE([gl_UNISTD_H_DEFAULTS])
+  AC_CHECK_FUNCS_ONCE([symlink])
+  dnl The best we can do on mingw is provide a dummy that always fails, so
+  dnl that compilation can proceed with fewer ifdefs.  On Solaris 9 and
+  dnl FreeBSD 7.2, we want to fix a bug with trailing slash handling.
+  if test $ac_cv_func_symlink = no; then
+    HAVE_SYMLINK=0
+    AC_LIBOBJ([symlink])
+  else
+    AC_CACHE_CHECK([whether symlink handles trailing slash correctly],
+      [gl_cv_func_symlink_works],
+      [AC_RUN_IFELSE(
+         [AC_LANG_PROGRAM(
+           [[#include <unistd.h>
+]], [[if (!symlink ("a", "conftest.link/")) return 1;
+      if (symlink ("conftest.f", "conftest.lnk2")) return 2;
+      if (!symlink ("a", "conftest.lnk2/")) return 3;]])],
+         [gl_cv_func_symlink_works=yes], [gl_cv_func_symlink_works=no],
+         [gl_cv_func_symlink_works="guessing no"])
+      rm -f conftest.f conftest.link conftest.lnk2])
+    if test "$gl_cv_func_symlink_works" != yes; then
+      REPLACE_SYMLINK=1
+      AC_LIBOBJ([symlink])
+    fi
+  fi
+])
--- /dev/null
+++ b/gl/m4/sys_stat_h.m4
@@ -0,0 +1,82 @@
+# sys_stat_h.m4 serial 24   -*- Autoconf -*-
+dnl Copyright (C) 2006-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Eric Blake.
+dnl Provide a GNU-like <sys/stat.h>.
+
+AC_DEFUN([gl_HEADER_SYS_STAT_H],
+[
+  AC_REQUIRE([gl_SYS_STAT_H_DEFAULTS])
+
+  dnl For the mkdir substitute.
+  AC_REQUIRE([AC_C_INLINE])
+
+  dnl Check for broken stat macros.
+  AC_REQUIRE([AC_HEADER_STAT])
+
+  gl_CHECK_NEXT_HEADERS([sys/stat.h])
+
+  dnl Define types that are supposed to be defined in <sys/types.h> or
+  dnl <sys/stat.h>.
+  AC_CHECK_TYPE([nlink_t], [],
+    [AC_DEFINE([nlink_t], [int],
+       [Define to the type of st_nlink in struct stat, or a supertype.])],
+    [#include <sys/types.h>
+     #include <sys/stat.h>])
+
+  dnl Check for declarations of anything we want to poison if the
+  dnl corresponding gnulib module is not in use.
+  gl_WARN_ON_USE_PREPARE([[#include <sys/stat.h>
+    ]], [fchmodat fstatat futimens lchmod lstat mkdirat mkfifo mkfifoat
+    mknod mknodat stat utimensat])
+]) # gl_HEADER_SYS_STAT_H
+
+AC_DEFUN([gl_SYS_STAT_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_SYS_STAT_H_DEFAULTS])
+  gl_MODULE_INDICATOR_SET_VARIABLE([$1])
+  dnl Define it also as a C macro, for the benefit of the unit tests.
+  gl_MODULE_INDICATOR_FOR_TESTS([$1])
+])
+
+AC_DEFUN([gl_SYS_STAT_H_DEFAULTS],
+[
+  AC_REQUIRE([gl_UNISTD_H_DEFAULTS]) dnl for REPLACE_FCHDIR
+  GNULIB_FCHMODAT=0;    AC_SUBST([GNULIB_FCHMODAT])
+  GNULIB_FSTATAT=0;     AC_SUBST([GNULIB_FSTATAT])
+  GNULIB_FUTIMENS=0;    AC_SUBST([GNULIB_FUTIMENS])
+  GNULIB_LCHMOD=0;      AC_SUBST([GNULIB_LCHMOD])
+  GNULIB_LSTAT=0;       AC_SUBST([GNULIB_LSTAT])
+  GNULIB_MKDIRAT=0;     AC_SUBST([GNULIB_MKDIRAT])
+  GNULIB_MKFIFO=0;      AC_SUBST([GNULIB_MKFIFO])
+  GNULIB_MKFIFOAT=0;    AC_SUBST([GNULIB_MKFIFOAT])
+  GNULIB_MKNOD=0;       AC_SUBST([GNULIB_MKNOD])
+  GNULIB_MKNODAT=0;     AC_SUBST([GNULIB_MKNODAT])
+  GNULIB_STAT=0;        AC_SUBST([GNULIB_STAT])
+  GNULIB_UTIMENSAT=0;   AC_SUBST([GNULIB_UTIMENSAT])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_FCHMODAT=1;      AC_SUBST([HAVE_FCHMODAT])
+  HAVE_FSTATAT=1;       AC_SUBST([HAVE_FSTATAT])
+  HAVE_FUTIMENS=1;      AC_SUBST([HAVE_FUTIMENS])
+  HAVE_LCHMOD=1;        AC_SUBST([HAVE_LCHMOD])
+  HAVE_LSTAT=1;         AC_SUBST([HAVE_LSTAT])
+  HAVE_MKDIRAT=1;       AC_SUBST([HAVE_MKDIRAT])
+  HAVE_MKFIFO=1;        AC_SUBST([HAVE_MKFIFO])
+  HAVE_MKFIFOAT=1;      AC_SUBST([HAVE_MKFIFOAT])
+  HAVE_MKNOD=1;         AC_SUBST([HAVE_MKNOD])
+  HAVE_MKNODAT=1;       AC_SUBST([HAVE_MKNODAT])
+  HAVE_UTIMENSAT=1;     AC_SUBST([HAVE_UTIMENSAT])
+  REPLACE_FSTAT=0;      AC_SUBST([REPLACE_FSTAT])
+  REPLACE_FSTATAT=0;    AC_SUBST([REPLACE_FSTATAT])
+  REPLACE_FUTIMENS=0;   AC_SUBST([REPLACE_FUTIMENS])
+  REPLACE_LSTAT=0;      AC_SUBST([REPLACE_LSTAT])
+  REPLACE_MKDIR=0;      AC_SUBST([REPLACE_MKDIR])
+  REPLACE_MKFIFO=0;     AC_SUBST([REPLACE_MKFIFO])
+  REPLACE_MKNOD=0;      AC_SUBST([REPLACE_MKNOD])
+  REPLACE_STAT=0;       AC_SUBST([REPLACE_STAT])
+  REPLACE_UTIMENSAT=0;  AC_SUBST([REPLACE_UTIMENSAT])
+])
--- /dev/null
+++ b/gl/m4/time_h.m4
@@ -0,0 +1,109 @@
+# Configure a more-standard replacement for <time.h>.
+
+# Copyright (C) 2000-2001, 2003-2007, 2009-2010 Free Software Foundation, Inc.
+
+# serial 2
+
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# Written by Paul Eggert and Jim Meyering.
+
+AC_DEFUN([gl_HEADER_TIME_H],
+[
+  dnl Use AC_REQUIRE here, so that the default behavior below is expanded
+  dnl once only, before all statements that occur in other macros.
+  AC_REQUIRE([gl_HEADER_TIME_H_BODY])
+])
+
+AC_DEFUN([gl_HEADER_TIME_H_BODY],
+[
+  AC_REQUIRE([AC_C_RESTRICT])
+  AC_REQUIRE([gl_HEADER_TIME_H_DEFAULTS])
+  gl_CHECK_NEXT_HEADERS([time.h])
+  AC_REQUIRE([gl_CHECK_TYPE_STRUCT_TIMESPEC])
+])
+
+dnl Define HAVE_STRUCT_TIMESPEC if `struct timespec' is declared
+dnl in time.h, sys/time.h, or pthread.h.
+
+AC_DEFUN([gl_CHECK_TYPE_STRUCT_TIMESPEC],
+[
+  AC_CHECK_HEADERS_ONCE([sys/time.h])
+  AC_CACHE_CHECK([for struct timespec in <time.h>],
+    [gl_cv_sys_struct_timespec_in_time_h],
+    [AC_COMPILE_IFELSE(
+       [AC_LANG_PROGRAM(
+          [[#include <time.h>
+          ]],
+          [[static struct timespec x; x.tv_sec = x.tv_nsec;]])],
+       [gl_cv_sys_struct_timespec_in_time_h=yes],
+       [gl_cv_sys_struct_timespec_in_time_h=no])])
+
+  TIME_H_DEFINES_STRUCT_TIMESPEC=0
+  SYS_TIME_H_DEFINES_STRUCT_TIMESPEC=0
+  PTHREAD_H_DEFINES_STRUCT_TIMESPEC=0
+  if test $gl_cv_sys_struct_timespec_in_time_h = yes; then
+    TIME_H_DEFINES_STRUCT_TIMESPEC=1
+  else
+    AC_CACHE_CHECK([for struct timespec in <sys/time.h>],
+      [gl_cv_sys_struct_timespec_in_sys_time_h],
+      [AC_COMPILE_IFELSE(
+         [AC_LANG_PROGRAM(
+            [[#include <sys/time.h>
+            ]],
+            [[static struct timespec x; x.tv_sec = x.tv_nsec;]])],
+         [gl_cv_sys_struct_timespec_in_sys_time_h=yes],
+         [gl_cv_sys_struct_timespec_in_sys_time_h=no])])
+    if test $gl_cv_sys_struct_timespec_in_sys_time_h = yes; then
+      SYS_TIME_H_DEFINES_STRUCT_TIMESPEC=1
+    else
+      AC_CACHE_CHECK([for struct timespec in <pthread.h>],
+        [gl_cv_sys_struct_timespec_in_pthread_h],
+        [AC_COMPILE_IFELSE(
+           [AC_LANG_PROGRAM(
+              [[#include <pthread.h>
+              ]],
+              [[static struct timespec x; x.tv_sec = x.tv_nsec;]])],
+           [gl_cv_sys_struct_timespec_in_pthread_h=yes],
+           [gl_cv_sys_struct_timespec_in_pthread_h=no])])
+      if test $gl_cv_sys_struct_timespec_in_pthread_h = yes; then
+        PTHREAD_H_DEFINES_STRUCT_TIMESPEC=1
+      fi
+    fi
+  fi
+  AC_SUBST([TIME_H_DEFINES_STRUCT_TIMESPEC])
+  AC_SUBST([SYS_TIME_H_DEFINES_STRUCT_TIMESPEC])
+  AC_SUBST([PTHREAD_H_DEFINES_STRUCT_TIMESPEC])
+])
+
+AC_DEFUN([gl_TIME_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_HEADER_TIME_H_DEFAULTS])
+  gl_MODULE_INDICATOR_SET_VARIABLE([$1])
+  dnl Define it also as a C macro, for the benefit of the unit tests.
+  gl_MODULE_INDICATOR_FOR_TESTS([$1])
+])
+
+AC_DEFUN([gl_HEADER_TIME_H_DEFAULTS],
+[
+  GNULIB_MKTIME=0;                       AC_SUBST([GNULIB_MKTIME])
+  GNULIB_NANOSLEEP=0;                    AC_SUBST([GNULIB_NANOSLEEP])
+  GNULIB_STRPTIME=0;                     AC_SUBST([GNULIB_STRPTIME])
+  GNULIB_TIMEGM=0;                       AC_SUBST([GNULIB_TIMEGM])
+  GNULIB_TIME_R=0;                       AC_SUBST([GNULIB_TIME_R])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_LOCALTIME_R=1;                    AC_SUBST([HAVE_LOCALTIME_R])
+  HAVE_NANOSLEEP=1;                      AC_SUBST([HAVE_NANOSLEEP])
+  HAVE_STRPTIME=1;                       AC_SUBST([HAVE_STRPTIME])
+  HAVE_TIMEGM=1;                         AC_SUBST([HAVE_TIMEGM])
+  dnl If another module says to replace or to not replace, do that.
+  dnl Otherwise, replace only if someone compiles with -DGNULIB_PORTCHECK;
+  dnl this lets maintainers check for portability.
+  REPLACE_LOCALTIME_R=GNULIB_PORTCHECK;  AC_SUBST([REPLACE_LOCALTIME_R])
+  REPLACE_MKTIME=GNULIB_PORTCHECK;       AC_SUBST([REPLACE_MKTIME])
+  REPLACE_NANOSLEEP=GNULIB_PORTCHECK;    AC_SUBST([REPLACE_NANOSLEEP])
+  REPLACE_TIMEGM=GNULIB_PORTCHECK;       AC_SUBST([REPLACE_TIMEGM])
+])
--- a/gl/m4/unistd_h.m4
+++ b/gl/m4/unistd_h.m4
@@ -1,5 +1,5 @@
-# unistd_h.m4 serial 17
-dnl Copyright (C) 2006-2009 Free Software Foundation, Inc.
+# unistd_h.m4 serial 46
+dnl Copyright (C) 2006-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
@@ -11,6 +11,7 @@ AC_DEFUN([gl_UNISTD_H],
   dnl Use AC_REQUIRE here, so that the default behavior below is expanded
   dnl once only, before all statements that occur in other macros.
   AC_REQUIRE([gl_UNISTD_H_DEFAULTS])
+  AC_REQUIRE([AC_C_INLINE])
 
   gl_CHECK_NEXT_HEADERS([unistd.h])
 
@@ -21,13 +22,34 @@ AC_DEFUN([gl_UNISTD_H],
     HAVE_UNISTD_H=0
   fi
   AC_SUBST([HAVE_UNISTD_H])
+
+  dnl Check for declarations of anything we want to poison if the
+  dnl corresponding gnulib module is not in use.
+  gl_WARN_ON_USE_PREPARE([[#include <unistd.h>
+/* Some systems declare various items in the wrong headers.  */
+#ifndef __GLIBC__
+# include <fcntl.h>
+# include <stdio.h>
+# include <stdlib.h>
+# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+#  include <io.h>
+# endif
+#endif
+    ]], [chown dup2 dup3 environ euidaccess faccessat fchdir fchownat
+    fsync ftruncate getcwd getdomainname getdtablesize getgroups
+    gethostname getlogin getlogin_r getpagesize getusershell setusershell
+    endusershell lchown link linkat lseek pipe2 pread pwrite readlink
+    readlinkat rmdir sleep symlink symlinkat ttyname_r unlink unlinkat
+    usleep])
 ])
 
 AC_DEFUN([gl_UNISTD_MODULE_INDICATOR],
 [
   dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
   AC_REQUIRE([gl_UNISTD_H_DEFAULTS])
-  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
+  gl_MODULE_INDICATOR_SET_VARIABLE([$1])
+  dnl Define it also as a C macro, for the benefit of the unit tests.
+  gl_MODULE_INDICATOR_FOR_TESTS([$1])
 ])
 
 AC_DEFUN([gl_UNISTD_H_DEFAULTS],
@@ -35,49 +57,103 @@ AC_DEFUN([gl_UNISTD_H_DEFAULTS],
   GNULIB_CHOWN=0;            AC_SUBST([GNULIB_CHOWN])
   GNULIB_CLOSE=0;            AC_SUBST([GNULIB_CLOSE])
   GNULIB_DUP2=0;             AC_SUBST([GNULIB_DUP2])
+  GNULIB_DUP3=0;             AC_SUBST([GNULIB_DUP3])
   GNULIB_ENVIRON=0;          AC_SUBST([GNULIB_ENVIRON])
   GNULIB_EUIDACCESS=0;       AC_SUBST([GNULIB_EUIDACCESS])
+  GNULIB_FACCESSAT=0;        AC_SUBST([GNULIB_FACCESSAT])
   GNULIB_FCHDIR=0;           AC_SUBST([GNULIB_FCHDIR])
+  GNULIB_FCHOWNAT=0;         AC_SUBST([GNULIB_FCHOWNAT])
   GNULIB_FSYNC=0;            AC_SUBST([GNULIB_FSYNC])
   GNULIB_FTRUNCATE=0;        AC_SUBST([GNULIB_FTRUNCATE])
   GNULIB_GETCWD=0;           AC_SUBST([GNULIB_GETCWD])
   GNULIB_GETDOMAINNAME=0;    AC_SUBST([GNULIB_GETDOMAINNAME])
   GNULIB_GETDTABLESIZE=0;    AC_SUBST([GNULIB_GETDTABLESIZE])
+  GNULIB_GETGROUPS=0;        AC_SUBST([GNULIB_GETGROUPS])
   GNULIB_GETHOSTNAME=0;      AC_SUBST([GNULIB_GETHOSTNAME])
+  GNULIB_GETLOGIN=0;         AC_SUBST([GNULIB_GETLOGIN])
   GNULIB_GETLOGIN_R=0;       AC_SUBST([GNULIB_GETLOGIN_R])
   GNULIB_GETPAGESIZE=0;      AC_SUBST([GNULIB_GETPAGESIZE])
   GNULIB_GETUSERSHELL=0;     AC_SUBST([GNULIB_GETUSERSHELL])
   GNULIB_LCHOWN=0;           AC_SUBST([GNULIB_LCHOWN])
   GNULIB_LINK=0;             AC_SUBST([GNULIB_LINK])
+  GNULIB_LINKAT=0;           AC_SUBST([GNULIB_LINKAT])
   GNULIB_LSEEK=0;            AC_SUBST([GNULIB_LSEEK])
+  GNULIB_PIPE2=0;            AC_SUBST([GNULIB_PIPE2])
+  GNULIB_PREAD=0;            AC_SUBST([GNULIB_PREAD])
+  GNULIB_PWRITE=0;           AC_SUBST([GNULIB_PWRITE])
   GNULIB_READLINK=0;         AC_SUBST([GNULIB_READLINK])
+  GNULIB_READLINKAT=0;       AC_SUBST([GNULIB_READLINKAT])
+  GNULIB_RMDIR=0;            AC_SUBST([GNULIB_RMDIR])
   GNULIB_SLEEP=0;            AC_SUBST([GNULIB_SLEEP])
+  GNULIB_SYMLINK=0;          AC_SUBST([GNULIB_SYMLINK])
+  GNULIB_SYMLINKAT=0;        AC_SUBST([GNULIB_SYMLINKAT])
+  GNULIB_TTYNAME_R=0;        AC_SUBST([GNULIB_TTYNAME_R])
+  GNULIB_UNISTD_H_GETOPT=0;  AC_SUBST([GNULIB_UNISTD_H_GETOPT])
   GNULIB_UNISTD_H_SIGPIPE=0; AC_SUBST([GNULIB_UNISTD_H_SIGPIPE])
+  GNULIB_UNLINK=0;           AC_SUBST([GNULIB_UNLINK])
+  GNULIB_UNLINKAT=0;         AC_SUBST([GNULIB_UNLINKAT])
+  GNULIB_USLEEP=0;           AC_SUBST([GNULIB_USLEEP])
   GNULIB_WRITE=0;            AC_SUBST([GNULIB_WRITE])
   dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_CHOWN=1;           AC_SUBST([HAVE_CHOWN])
   HAVE_DUP2=1;            AC_SUBST([HAVE_DUP2])
+  HAVE_DUP3=1;            AC_SUBST([HAVE_DUP3])
   HAVE_EUIDACCESS=1;      AC_SUBST([HAVE_EUIDACCESS])
+  HAVE_FACCESSAT=1;       AC_SUBST([HAVE_FACCESSAT])
+  HAVE_FCHDIR=1;          AC_SUBST([HAVE_FCHDIR])
+  HAVE_FCHOWNAT=1;        AC_SUBST([HAVE_FCHOWNAT])
   HAVE_FSYNC=1;           AC_SUBST([HAVE_FSYNC])
   HAVE_FTRUNCATE=1;       AC_SUBST([HAVE_FTRUNCATE])
   HAVE_GETDOMAINNAME=1;   AC_SUBST([HAVE_GETDOMAINNAME])
   HAVE_GETDTABLESIZE=1;   AC_SUBST([HAVE_GETDTABLESIZE])
+  HAVE_GETGROUPS=1;       AC_SUBST([HAVE_GETGROUPS])
   HAVE_GETHOSTNAME=1;     AC_SUBST([HAVE_GETHOSTNAME])
+  HAVE_GETLOGIN=1;        AC_SUBST([HAVE_GETLOGIN])
   HAVE_GETPAGESIZE=1;     AC_SUBST([HAVE_GETPAGESIZE])
-  HAVE_GETUSERSHELL=1;    AC_SUBST([HAVE_GETUSERSHELL])
+  HAVE_LCHOWN=1;          AC_SUBST([HAVE_LCHOWN])
   HAVE_LINK=1;            AC_SUBST([HAVE_LINK])
+  HAVE_LINKAT=1;          AC_SUBST([HAVE_LINKAT])
+  HAVE_PIPE2=1;           AC_SUBST([HAVE_PIPE2])
+  HAVE_PREAD=1;           AC_SUBST([HAVE_PREAD])
+  HAVE_PWRITE=1;          AC_SUBST([HAVE_PWRITE])
   HAVE_READLINK=1;        AC_SUBST([HAVE_READLINK])
+  HAVE_READLINKAT=1;      AC_SUBST([HAVE_READLINKAT])
   HAVE_SLEEP=1;           AC_SUBST([HAVE_SLEEP])
+  HAVE_SYMLINK=1;         AC_SUBST([HAVE_SYMLINK])
+  HAVE_SYMLINKAT=1;       AC_SUBST([HAVE_SYMLINKAT])
+  HAVE_TTYNAME_R=1;       AC_SUBST([HAVE_TTYNAME_R])
+  HAVE_UNLINKAT=1;        AC_SUBST([HAVE_UNLINKAT])
+  HAVE_USLEEP=1;          AC_SUBST([HAVE_USLEEP])
   HAVE_DECL_ENVIRON=1;    AC_SUBST([HAVE_DECL_ENVIRON])
   HAVE_DECL_GETLOGIN_R=1; AC_SUBST([HAVE_DECL_GETLOGIN_R])
+  HAVE_DECL_GETPAGESIZE=1; AC_SUBST([HAVE_DECL_GETPAGESIZE])
+  HAVE_DECL_GETUSERSHELL=1; AC_SUBST([HAVE_DECL_GETUSERSHELL])
   HAVE_OS_H=0;            AC_SUBST([HAVE_OS_H])
   HAVE_SYS_PARAM_H=0;     AC_SUBST([HAVE_SYS_PARAM_H])
   REPLACE_CHOWN=0;        AC_SUBST([REPLACE_CHOWN])
   REPLACE_CLOSE=0;        AC_SUBST([REPLACE_CLOSE])
-  REPLACE_FCHDIR=0;       AC_SUBST([REPLACE_FCHDIR])
+  REPLACE_DUP=0;          AC_SUBST([REPLACE_DUP])
+  REPLACE_DUP2=0;         AC_SUBST([REPLACE_DUP2])
+  REPLACE_FCHOWNAT=0;     AC_SUBST([REPLACE_FCHOWNAT])
   REPLACE_GETCWD=0;       AC_SUBST([REPLACE_GETCWD])
+  REPLACE_GETGROUPS=0;    AC_SUBST([REPLACE_GETGROUPS])
   REPLACE_GETPAGESIZE=0;  AC_SUBST([REPLACE_GETPAGESIZE])
   REPLACE_LCHOWN=0;       AC_SUBST([REPLACE_LCHOWN])
+  REPLACE_LINK=0;         AC_SUBST([REPLACE_LINK])
+  REPLACE_LINKAT=0;       AC_SUBST([REPLACE_LINKAT])
   REPLACE_LSEEK=0;        AC_SUBST([REPLACE_LSEEK])
+  REPLACE_PREAD=0;        AC_SUBST([REPLACE_PREAD])
+  REPLACE_PWRITE=0;       AC_SUBST([REPLACE_PWRITE])
+  REPLACE_READLINK=0;     AC_SUBST([REPLACE_READLINK])
+  REPLACE_RMDIR=0;        AC_SUBST([REPLACE_RMDIR])
+  REPLACE_SLEEP=0;        AC_SUBST([REPLACE_SLEEP])
+  REPLACE_SYMLINK=0;      AC_SUBST([REPLACE_SYMLINK])
+  REPLACE_TTYNAME_R=0;    AC_SUBST([REPLACE_TTYNAME_R])
+  REPLACE_UNLINK=0;       AC_SUBST([REPLACE_UNLINK])
+  REPLACE_UNLINKAT=0;     AC_SUBST([REPLACE_UNLINKAT])
+  REPLACE_USLEEP=0;       AC_SUBST([REPLACE_USLEEP])
   REPLACE_WRITE=0;        AC_SUBST([REPLACE_WRITE])
   UNISTD_H_HAVE_WINSOCK2_H=0; AC_SUBST([UNISTD_H_HAVE_WINSOCK2_H])
+  UNISTD_H_HAVE_WINSOCK2_H_AND_USE_SOCKETS=0;
+                           AC_SUBST([UNISTD_H_HAVE_WINSOCK2_H_AND_USE_SOCKETS])
 ])
--- a/gl/m4/version-etc.m4
+++ b/gl/m4/version-etc.m4
@@ -1,5 +1,5 @@
 # version-etc.m4 serial 1
-# Copyright (C) 2009 Free Software Foundation, Inc.
+# Copyright (C) 2009-2010 Free Software Foundation, Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -11,8 +11,8 @@ m4_define([gl_VERSION_ETC_FLAG],
   AC_ARG_WITH([$1], [AS_HELP_STRING([--with-$1], [$2])],
     [dnl
       case $withval in
-	yes|no) ;;
-	*) AC_DEFINE_UNQUOTED(AS_TR_CPP([PACKAGE_$1]), ["$withval"], [$2]) ;;
+        yes|no) ;;
+        *) AC_DEFINE_UNQUOTED(AS_TR_CPP([PACKAGE_$1]), ["$withval"], [$2]) ;;
       esac
     ])
 ])
@@ -20,11 +20,11 @@ m4_define([gl_VERSION_ETC_FLAG],
 AC_DEFUN([gl_VERSION_ETC],
 [dnl
   gl_VERSION_ETC_FLAG([packager],
-		      [String identifying the packager of this software])
+                      [String identifying the packager of this software])
   gl_VERSION_ETC_FLAG([packager-version],
-		      [Packager-specific version information])
+                      [Packager-specific version information])
   gl_VERSION_ETC_FLAG([packager-bug-reports],
-		      [Packager info for bug reports (URL/e-mail/...)])
+                      [Packager info for bug reports (URL/e-mail/...)])
   if test "X$with_packager" = "X" && \
      test "X$with_packager_version$with_packager_bug_reports" != "X"
   then
--- /dev/null
+++ b/gl/m4/warn-on-use.m4
@@ -0,0 +1,45 @@
+# warn-on-use.m4 serial 2
+dnl Copyright (C) 2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# gl_WARN_ON_USE_PREPARE(INCLUDES, NAMES)
+# ---------------------------------------
+# For each whitespace-separated element in the list of NAMES, define
+# HAVE_RAW_DECL_name if the function has a declaration among INCLUDES
+# even after being undefined as a macro.
+#
+# See warn-on-use.h for some hints on how to poison function names, as
+# well as ideas on poisoning global variables and macros.  NAMES may
+# include global variables, but remember that only functions work with
+# _GL_WARN_ON_USE.  Typically, INCLUDES only needs to list a single
+# header, but if the replacement header pulls in other headers because
+# some systems declare functions in the wrong header, then INCLUDES
+# should do likewise.
+#
+# If you assume C89, then it is generally safe to assume declarations
+# for functions declared in that standard (such as gets) without
+# needing gl_WARN_ON_USE_PREPARE.
+AC_DEFUN([gl_WARN_ON_USE_PREPARE],
+[
+  m4_foreach_w([gl_decl], [$2],
+    [AH_TEMPLATE([HAVE_RAW_DECL_]AS_TR_CPP(m4_defn([gl_decl])),
+      [Define to 1 if ]m4_defn([gl_decl])[ is declared even after
+       undefining macros.])])dnl
+  for gl_func in m4_flatten([$2]); do
+    AS_VAR_PUSHDEF([gl_Symbol], [gl_cv_have_raw_decl_$gl_func])dnl
+    AC_CACHE_CHECK([whether $gl_func is declared without a macro],
+      gl_Symbol,
+      [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([$1],
+[@%:@undef $gl_func
+  (void) $gl_func;])],
+        [AS_VAR_SET(gl_Symbol, [yes])], [AS_VAR_SET(gl_Symbol, [no])])])
+     AS_VAR_IF(gl_Symbol, [yes],
+       [AC_DEFINE_UNQUOTED(AS_TR_CPP([HAVE_RAW_DECL_$gl_func]), [1])
+       dnl shortcut - if the raw declaration exists, then set a cache
+       dnl variable to allow skipping any later AC_CHECK_DECL efforts
+       eval ac_cv_have_decl_$gl_func=yes])
+    AS_VAR_POPDEF([gl_Symbol])dnl
+  done
+])
--- a/gl/m4/warnings.m4
+++ b/gl/m4/warnings.m4
@@ -1,19 +1,11 @@
 # warnings.m4 serial 2
-dnl Copyright (C) 2008 Free Software Foundation, Inc.
+dnl Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
 
 dnl From Simon Josefsson
 
-# gl_AS_VAR_IF(VAR, VALUE, [IF-MATCH], [IF-NOT-MATCH])
-# ----------------------------------------------------
-# Provide the functionality of AS_VAR_IF if Autoconf does not have it.
-m4_ifdef([AS_VAR_IF],
-[m4_copy([AS_VAR_IF], [gl_AS_VAR_IF])],
-[m4_define([gl_AS_VAR_IF],
-[AS_IF([test x"AS_VAR_GET([$1])" = x""$2], [$3], [$4])])])
-
 # gl_AS_VAR_APPEND(VAR, VALUE)
 # ----------------------------
 # Provide the functionality of AS_VAR_APPEND if Autoconf does not have it.
@@ -33,11 +25,11 @@ AC_CACHE_CHECK([whether compiler handles
   CPPFLAGS="${CPPFLAGS} $1"
   AC_PREPROC_IFELSE([AC_LANG_PROGRAM([])],
                     [AS_VAR_SET([gl_Warn], [yes])],
-		    [AS_VAR_SET([gl_Warn], [no])])
+                    [AS_VAR_SET([gl_Warn], [no])])
   CPPFLAGS="$save_CPPFLAGS"
 ])
 AS_VAR_PUSHDEF([gl_Flags], m4_if([$2], [], [[WARN_CFLAGS]], [[$2]]))dnl
-gl_AS_VAR_IF([gl_Warn], [yes], [gl_AS_VAR_APPEND([gl_Flags], [" $1"])])
+AS_VAR_IF([gl_Warn], [yes], [gl_AS_VAR_APPEND([gl_Flags], [" $1"])])
 AS_VAR_POPDEF([gl_Flags])dnl
 AS_VAR_POPDEF([gl_Warn])dnl
 m4_ifval([$2], [AS_LITERAL_IF([$2], [AC_SUBST([$2])], [])])dnl
--- /dev/null
+++ b/gl/m4/wchar_h.m4
@@ -0,0 +1,152 @@
+dnl A placeholder for ISO C99 <wchar.h>, for platforms that have issues.
+
+dnl Copyright (C) 2007-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Written by Eric Blake.
+
+# wchar_h.m4 serial 33
+
+AC_DEFUN([gl_WCHAR_H],
+[
+  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])
+  AC_REQUIRE([gl_WCHAR_H_INLINE_OK])
+  dnl Prepare for creating substitute <wchar.h>.
+  dnl Check for <wchar.h> (missing in Linux uClibc when built without wide
+  dnl character support).
+  dnl <wchar.h> is always overridden, because of GNULIB_POSIXCHECK.
+  AC_CHECK_HEADERS_ONCE([wchar.h])
+  gl_CHECK_NEXT_HEADERS([wchar.h])
+  if test $ac_cv_header_wchar_h = yes; then
+    HAVE_WCHAR_H=1
+  else
+    HAVE_WCHAR_H=0
+  fi
+  AC_SUBST([HAVE_WCHAR_H])
+
+  AC_REQUIRE([gt_TYPE_WINT_T])
+  if test $gt_cv_c_wint_t = yes; then
+    HAVE_WINT_T=1
+  else
+    HAVE_WINT_T=0
+  fi
+  AC_SUBST([HAVE_WINT_T])
+
+  dnl Check for declarations of anything we want to poison if the
+  dnl corresponding gnulib module is not in use.
+  gl_WARN_ON_USE_PREPARE([[
+/* Some systems require additional headers.  */
+#ifndef __GLIBC__
+# include <stddef.h>
+# include <stdio.h>
+# include <time.h>
+#endif
+#include <wchar.h>
+    ]], [btowc wctob mbsinit mbrtowc mbrlen mbsrtowcs mbsnrtowcs wcrtomb
+    wcsrtombs wcsnrtombs wcwidth])
+])
+
+dnl Check whether <wchar.h> is usable at all.
+AC_DEFUN([gl_WCHAR_H_INLINE_OK],
+[
+  dnl Test whether <wchar.h> suffers due to the transition from '__inline' to
+  dnl 'gnu_inline'. See <http://sourceware.org/bugzilla/show_bug.cgi?id=4022>
+  dnl and <http://gcc.gnu.org/bugzilla/show_bug.cgi?id=42440>. In summary,
+  dnl glibc version 2.5 or older, together with gcc version 4.3 or newer and
+  dnl the option -std=c99 or -std=gnu99, leads to a broken <wchar.h>.
+  AC_CACHE_CHECK([whether <wchar.h> uses 'inline' correctly],
+    [gl_cv_header_wchar_h_correct_inline],
+    [gl_cv_header_wchar_h_correct_inline=yes
+     AC_LANG_CONFTEST([
+       AC_LANG_SOURCE([[#define wcstod renamed_wcstod
+#include <wchar.h>
+extern int zero (void);
+int main () { return zero(); }
+]])])
+     if AC_TRY_EVAL([ac_compile]); then
+       mv conftest.$ac_objext conftest1.$ac_objext
+       AC_LANG_CONFTEST([
+         AC_LANG_SOURCE([[#define wcstod renamed_wcstod
+#include <wchar.h>
+int zero (void) { return 0; }
+]])])
+       if AC_TRY_EVAL([ac_compile]); then
+         mv conftest.$ac_objext conftest2.$ac_objext
+         if $CC -o conftest$ac_exeext $CFLAGS $LDFLAGS conftest1.$ac_objext conftest2.$ac_objext $LIBS >&AS_MESSAGE_LOG_FD 2>&1; then
+           :
+         else
+           gl_cv_header_wchar_h_correct_inline=no
+         fi
+       fi
+     fi
+     rm -f conftest1.$ac_objext conftest2.$ac_objext conftest$ac_exeext
+    ])
+  if test $gl_cv_header_wchar_h_correct_inline = no; then
+    AC_MSG_ERROR([<wchar.h> cannot be used with this compiler ($CC $CFLAGS $CPPFLAGS).
+This is a known interoperability problem of glibc <= 2.5 with gcc >= 4.3 in
+C99 mode. You have four options:
+  - Add the flag -fgnu89-inline to CC and reconfigure, or
+  - Fix your include files, using parts of
+    <http://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b037a293a48718af30d706c2e18c929d0e69a621>, or
+  - Use a gcc version older than 4.3, or
+  - Don't use the flags -std=c99 or -std=gnu99.
+Configuration aborted.])
+  fi
+])
+
+dnl Unconditionally enables the replacement of <wchar.h>.
+AC_DEFUN([gl_REPLACE_WCHAR_H],
+[
+  dnl This is a no-op, because <wchar.h> is always overridden.
+  :
+])
+
+AC_DEFUN([gl_WCHAR_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])
+  gl_MODULE_INDICATOR_SET_VARIABLE([$1])
+  dnl Define it also as a C macro, for the benefit of the unit tests.
+  gl_MODULE_INDICATOR_FOR_TESTS([$1])
+])
+
+AC_DEFUN([gl_WCHAR_H_DEFAULTS],
+[
+  GNULIB_BTOWC=0;      AC_SUBST([GNULIB_BTOWC])
+  GNULIB_WCTOB=0;      AC_SUBST([GNULIB_WCTOB])
+  GNULIB_MBSINIT=0;    AC_SUBST([GNULIB_MBSINIT])
+  GNULIB_MBRTOWC=0;    AC_SUBST([GNULIB_MBRTOWC])
+  GNULIB_MBRLEN=0;     AC_SUBST([GNULIB_MBRLEN])
+  GNULIB_MBSRTOWCS=0;  AC_SUBST([GNULIB_MBSRTOWCS])
+  GNULIB_MBSNRTOWCS=0; AC_SUBST([GNULIB_MBSNRTOWCS])
+  GNULIB_WCRTOMB=0;    AC_SUBST([GNULIB_WCRTOMB])
+  GNULIB_WCSRTOMBS=0;  AC_SUBST([GNULIB_WCSRTOMBS])
+  GNULIB_WCSNRTOMBS=0; AC_SUBST([GNULIB_WCSNRTOMBS])
+  GNULIB_WCWIDTH=0;    AC_SUBST([GNULIB_WCWIDTH])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_BTOWC=1;         AC_SUBST([HAVE_BTOWC])
+  HAVE_MBSINIT=1;       AC_SUBST([HAVE_MBSINIT])
+  HAVE_MBRTOWC=1;       AC_SUBST([HAVE_MBRTOWC])
+  HAVE_MBRLEN=1;        AC_SUBST([HAVE_MBRLEN])
+  HAVE_MBSRTOWCS=1;     AC_SUBST([HAVE_MBSRTOWCS])
+  HAVE_MBSNRTOWCS=1;    AC_SUBST([HAVE_MBSNRTOWCS])
+  HAVE_WCRTOMB=1;       AC_SUBST([HAVE_WCRTOMB])
+  HAVE_WCSRTOMBS=1;     AC_SUBST([HAVE_WCSRTOMBS])
+  HAVE_WCSNRTOMBS=1;    AC_SUBST([HAVE_WCSNRTOMBS])
+  HAVE_DECL_WCTOB=1;    AC_SUBST([HAVE_DECL_WCTOB])
+  HAVE_DECL_WCWIDTH=1;  AC_SUBST([HAVE_DECL_WCWIDTH])
+  REPLACE_MBSTATE_T=0;  AC_SUBST([REPLACE_MBSTATE_T])
+  REPLACE_BTOWC=0;      AC_SUBST([REPLACE_BTOWC])
+  REPLACE_WCTOB=0;      AC_SUBST([REPLACE_WCTOB])
+  REPLACE_MBSINIT=0;    AC_SUBST([REPLACE_MBSINIT])
+  REPLACE_MBRTOWC=0;    AC_SUBST([REPLACE_MBRTOWC])
+  REPLACE_MBRLEN=0;     AC_SUBST([REPLACE_MBRLEN])
+  REPLACE_MBSRTOWCS=0;  AC_SUBST([REPLACE_MBSRTOWCS])
+  REPLACE_MBSNRTOWCS=0; AC_SUBST([REPLACE_MBSNRTOWCS])
+  REPLACE_WCRTOMB=0;    AC_SUBST([REPLACE_WCRTOMB])
+  REPLACE_WCSRTOMBS=0;  AC_SUBST([REPLACE_WCSRTOMBS])
+  REPLACE_WCSNRTOMBS=0; AC_SUBST([REPLACE_WCSNRTOMBS])
+  REPLACE_WCWIDTH=0;    AC_SUBST([REPLACE_WCWIDTH])
+])
--- /dev/null
+++ b/gl/m4/wchar_t.m4
@@ -0,0 +1,20 @@
+# wchar_t.m4 serial 3 (gettext-0.18)
+dnl Copyright (C) 2002-2003, 2008-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+dnl Test whether <stddef.h> has the 'wchar_t' type.
+dnl Prerequisite: AC_PROG_CC
+
+AC_DEFUN([gt_TYPE_WCHAR_T],
+[
+  AC_CACHE_CHECK([for wchar_t], [gt_cv_c_wchar_t],
+    [AC_TRY_COMPILE([#include <stddef.h>
+       wchar_t foo = (wchar_t)'\0';], ,
+       [gt_cv_c_wchar_t=yes], [gt_cv_c_wchar_t=no])])
+  if test $gt_cv_c_wchar_t = yes; then
+    AC_DEFINE([HAVE_WCHAR_T], [1], [Define if you have the 'wchar_t' type.])
+  fi
+])
--- /dev/null
+++ b/gl/m4/wint_t.m4
@@ -0,0 +1,28 @@
+# wint_t.m4 serial 4 (gettext-0.18)
+dnl Copyright (C) 2003, 2007-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+dnl Test whether <wchar.h> has the 'wint_t' type.
+dnl Prerequisite: AC_PROG_CC
+
+AC_DEFUN([gt_TYPE_WINT_T],
+[
+  AC_CACHE_CHECK([for wint_t], [gt_cv_c_wint_t],
+    [AC_TRY_COMPILE([
+/* Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
+   <wchar.h>.
+   BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be included
+   before <wchar.h>.  */
+#include <stddef.h>
+#include <stdio.h>
+#include <time.h>
+#include <wchar.h>
+       wint_t foo = (wchar_t)'\0';], ,
+       [gt_cv_c_wint_t=yes], [gt_cv_c_wint_t=no])])
+  if test $gt_cv_c_wint_t = yes; then
+    AC_DEFINE([HAVE_WINT_T], [1], [Define if you have the 'wint_t' type.])
+  fi
+])
--- a/gl/progname.c
+++ b/gl/progname.c
@@ -1,6 +1,6 @@
 /* Program name management.
-   Copyright (C) 2001-2003, 2005-2009 Free Software Foundation, Inc.
-   Written by Bruno Haible <haible@clisp.cons.org>, 2001.
+   Copyright (C) 2001-2003, 2005-2010 Free Software Foundation, Inc.
+   Written by Bruno Haible <bruno@clisp.org>, 2001.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -22,6 +22,9 @@
 #undef ENABLE_RELOCATABLE /* avoid defining set_program_name as a macro */
 #include "progname.h"
 
+#include <errno.h> /* get program_invocation_name declaration */
+#include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 
 
@@ -29,7 +32,9 @@
    To be initialized by main().  */
 const char *program_name = NULL;
 
-/* Set program_name, based on argv[0].  */
+/* Set program_name, based on argv[0].
+   argv0 must be a string allocated with indefinite extent, and must not be
+   modified after this call.  */
 void
 set_program_name (const char *argv0)
 {
@@ -41,13 +46,30 @@ set_program_name (const char *argv0)
   const char *slash;
   const char *base;
 
+  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL
+     argv[0].  */
+  if (argv0 == NULL)
+    {
+      /* It's a bug in the invoking program.  Help diagnosing it.  */
+      fputs ("A NULL argv[0] was passed through an exec system call.\n",
+             stderr);
+      abort ();
+    }
+
   slash = strrchr (argv0, '/');
   base = (slash != NULL ? slash + 1 : argv0);
   if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
     {
       argv0 = base;
       if (strncmp (base, "lt-", 3) == 0)
-	argv0 = base + 3;
+        {
+          argv0 = base + 3;
+          /* On glibc systems, remove the "lt-" prefix from the variable
+             program_invocation_short_name.  */
+#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME
+          program_invocation_short_name = (char *) argv0;
+#endif
+        }
     }
 
   /* But don't strip off a leading <dirname>/ in general, because when the user
@@ -60,4 +82,11 @@ set_program_name (const char *argv0)
    */
 
   program_name = argv0;
+
+  /* On glibc systems, the error() function comes from libc and uses the
+     variable program_invocation_name, not program_name.  So set this variable
+     as well.  */
+#if HAVE_DECL_PROGRAM_INVOCATION_NAME
+  program_invocation_name = (char *) argv0;
+#endif
 }
--- a/gl/progname.h
+++ b/gl/progname.h
@@ -1,6 +1,6 @@
 /* Program name management.
-   Copyright (C) 2001-2004, 2006 Free Software Foundation, Inc.
-   Written by Bruno Haible <haible@clisp.cons.org>, 2001.
+   Copyright (C) 2001-2004, 2006, 2009-2010 Free Software Foundation, Inc.
+   Written by Bruno Haible <bruno@clisp.org>, 2001.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -31,16 +31,18 @@ extern "C" {
 /* String containing name the program is called with.  */
 extern const char *program_name;
 
-/* Set program_name, based on argv[0].  */
+/* Set program_name, based on argv[0].
+   argv0 must be a string allocated with indefinite extent, and must not be
+   modified after this call.  */
 extern void set_program_name (const char *argv0);
 
-#if defined(ENABLE_RELOCATABLE) && ENABLE_RELOCATABLE
+#if ENABLE_RELOCATABLE
 
 /* Set program_name, based on argv[0], and original installation prefix and
    directory, for relocatability.  */
 extern void set_program_name_and_installdir (const char *argv0,
-					     const char *orig_installprefix,
-					     const char *orig_installdir);
+                                             const char *orig_installprefix,
+                                             const char *orig_installdir);
 #undef set_program_name
 #define set_program_name(ARG0) \
   set_program_name_and_installdir (ARG0, INSTALLPREFIX, INSTALLDIR)
--- a/gl/stdarg.in.h
+++ b/gl/stdarg.in.h
@@ -1,5 +1,5 @@
 /* Substitute for and wrapper around <stdarg.h>.
-   Copyright (C) 2008 Free Software Foundation, Inc.
+   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
--- /dev/null
+++ b/gl/stddef.in.h
@@ -0,0 +1,86 @@
+/* A substitute for POSIX 2008 <stddef.h>, for platforms that have issues.
+
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Written by Eric Blake.  */
+
+/*
+ * POSIX 2008 <stddef.h> for platforms that have issues.
+ * <http://www.opengroup.org/susv3xbd/stddef.h.html>
+ */
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+#if defined __need_wchar_t || defined __need_size_t  \
+  || defined __need_ptrdiff_t || defined __need_NULL \
+  || defined __need_wint_t
+/* Special invocation convention inside gcc header files.  In
+   particular, gcc provides a version of <stddef.h> that blindly
+   redefines NULL even when __need_wint_t was defined, even though
+   wint_t is not normally provided by <stddef.h>.  Hence, we must
+   remember if special invocation has ever been used to obtain wint_t,
+   in which case we need to clean up NULL yet again.  */
+
+# if !(defined _GL_STDDEF_H && defined _GL_STDDEF_WINT_T)
+#  ifdef __need_wint_t
+#   undef _GL_STDDEF_H
+#   define _GL_STDDEF_WINT_T
+#  endif
+#  @INCLUDE_NEXT@ @NEXT_STDDEF_H@
+# endif
+
+#else
+/* Normal invocation convention.  */
+
+# ifndef _GL_STDDEF_H
+
+/* The include_next requires a split double-inclusion guard.  */
+
+#  @INCLUDE_NEXT@ @NEXT_STDDEF_H@
+
+#  ifndef _GL_STDDEF_H
+#   define _GL_STDDEF_H
+
+/* On NetBSD 5.0, the definition of NULL lacks proper parentheses.  */
+#if @REPLACE_NULL@
+# undef NULL
+# ifdef __cplusplus
+   /* ISO C++ says that the macro NULL must expand to an integer constant
+      expression, hence '((void *) 0)' is not allowed in C++.  */
+#  if __GNUG__ >= 3
+    /* GNU C++ has a __null macro that behaves like an integer ('int' or
+       'long') but has the same size as a pointer.  Use that, to avoid
+       warnings.  */
+#   define NULL __null
+#  else
+#   define NULL 0L
+#  endif
+# else
+#  define NULL ((void *) 0)
+# endif
+#endif
+
+/* Some platforms lack wchar_t.  */
+#if !@HAVE_WCHAR_T@
+# define wchar_t int
+#endif
+
+#  endif /* _GL_STDDEF_H */
+# endif /* _GL_STDDEF_H */
+#endif /* __need_XXX */
--- a/gl/strerror.c
+++ b/gl/strerror.c
@@ -1,6 +1,6 @@
 /* strerror.c --- POSIX compatible system error routine
 
-   Copyright (C) 2007-2009 Free Software Foundation, Inc.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -32,6 +32,9 @@
 
 # include "intprops.h"
 
+/* Use the system functions, not the gnulib overrides in this file.  */
+# undef sprintf
+
 # undef strerror
 # if ! HAVE_DECL_STRERROR
 #  define strerror(n) NULL
@@ -313,7 +316,13 @@ rpl_strerror (int n)
       break;
 # endif
 
-# if GNULIB_defined_
+# if GNULIB_defined_ESTALE
+    case ESTALE:
+      msg = "Stale NFS file handle";
+      break;
+# endif
+
+# if GNULIB_defined_ECANCELED
     case ECANCELED:
       msg = "Operation canceled";
       break;
@@ -328,10 +337,10 @@ rpl_strerror (int n)
 
     if (result == NULL || result[0] == '\0')
       {
-	static char const fmt[] = "Unknown error (%d)";
-	static char msg_buf[sizeof fmt + INT_STRLEN_BOUND (n)];
-	sprintf (msg_buf, fmt, n);
-	return msg_buf;
+        static char const fmt[] = "Unknown error (%d)";
+        static char msg_buf[sizeof fmt + INT_STRLEN_BOUND (n)];
+        sprintf (msg_buf, fmt, n);
+        return msg_buf;
       }
 
     return result;
--- a/gl/string.in.h
+++ b/gl/string.in.h
@@ -1,6 +1,6 @@
 /* A GNU-like <string.h>.
 
-   Copyright (C) 1995-1996, 2001-2008 Free Software Foundation, Inc.
+   Copyright (C) 1995-1996, 2001-2010 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -28,73 +28,156 @@
 #ifndef _GL_STRING_H
 #define _GL_STRING_H
 
+/* NetBSD 5.0 mis-defines NULL.  */
+#include <stddef.h>
+
+/* MirBSD defines mbslen as a macro.  */
+#if @GNULIB_MBSLEN@ && defined __MirBSD__
+# include <wchar.h>
+#endif
 
 #ifndef __attribute__
 /* This feature is available in gcc versions 2.5 and later.  */
 # if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5)
 #  define __attribute__(Spec) /* empty */
 # endif
+#endif
 /* The attribute __pure__ was added in gcc 2.96.  */
-# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
-#  define __pure__ /* empty */
-# endif
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)
+# define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
+#else
+# define _GL_ATTRIBUTE_PURE /* empty */
 #endif
 
 
-/* The definition of GL_LINK_WARNING is copied here.  */
-
-
-#ifdef __cplusplus
-extern "C" {
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+
+
+/* Return the first instance of C within N bytes of S, or NULL.  */
+#if @GNULIB_MEMCHR@
+# if @REPLACE_MEMCHR@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define memchr rpl_memchr
+#  endif
+_GL_FUNCDECL_RPL (memchr, void *, (void const *__s, int __c, size_t __n)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (memchr, void *, (void const *__s, int __c, size_t __n));
+# else
+#  if ! @HAVE_MEMCHR@
+_GL_FUNCDECL_SYS (memchr, void *, (void const *__s, int __c, size_t __n)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+#  endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C" { const void * std::memchr (const void *, int, size_t); }
+       extern "C++" { void * std::memchr (void *, int, size_t); }  */
+_GL_CXXALIAS_SYS_CAST2 (memchr,
+                        void *, (void const *__s, int __c, size_t __n),
+                        void const *, (void const *__s, int __c, size_t __n));
+# endif
+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 10 \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (memchr, void *, (void *__s, int __c, size_t __n));
+_GL_CXXALIASWARN1 (memchr, void const *,
+                   (void const *__s, int __c, size_t __n));
+# else
+_GL_CXXALIASWARN (memchr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef memchr
+/* Assume memchr is always declared.  */
+_GL_WARN_ON_USE (memchr, "memchr has platform-specific bugs - "
+                 "use gnulib module memchr for portability" );
 #endif
 
-
 /* Return the first occurrence of NEEDLE in HAYSTACK.  */
 #if @GNULIB_MEMMEM@
 # if @REPLACE_MEMMEM@
-#  define memmem rpl_memmem
-# endif
-# if ! @HAVE_DECL_MEMMEM@ || @REPLACE_MEMMEM@
-extern void *memmem (void const *__haystack, size_t __haystack_len,
-		     void const *__needle, size_t __needle_len)
-  __attribute__ ((__pure__));
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define memmem rpl_memmem
+#  endif
+_GL_FUNCDECL_RPL (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 3)));
+_GL_CXXALIAS_RPL (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len));
+# else
+#  if ! @HAVE_DECL_MEMMEM@
+_GL_FUNCDECL_SYS (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 3)));
+#  endif
+_GL_CXXALIAS_SYS (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len));
 # endif
+_GL_CXXALIASWARN (memmem);
 #elif defined GNULIB_POSIXCHECK
 # undef memmem
-# define memmem(a,al,b,bl) \
-    (GL_LINK_WARNING ("memmem is unportable and often quadratic - " \
-                      "use gnulib module memmem-simple for portability, " \
-                      "and module memmem for speed" ), \
-     memmem (a, al, b, bl))
+# if HAVE_RAW_DECL_MEMMEM
+_GL_WARN_ON_USE (memmem, "memmem is unportable and often quadratic - "
+                 "use gnulib module memmem-simple for portability, "
+                 "and module memmem for speed" );
+# endif
 #endif
 
 /* Copy N bytes of SRC to DEST, return pointer to bytes after the
    last written byte.  */
 #if @GNULIB_MEMPCPY@
 # if ! @HAVE_MEMPCPY@
-extern void *mempcpy (void *restrict __dest, void const *restrict __src,
-		      size_t __n);
-# endif
+_GL_FUNCDECL_SYS (mempcpy, void *,
+                  (void *restrict __dest, void const *restrict __src,
+                   size_t __n)
+                  _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (mempcpy, void *,
+                  (void *restrict __dest, void const *restrict __src,
+                   size_t __n));
+_GL_CXXALIASWARN (mempcpy);
 #elif defined GNULIB_POSIXCHECK
 # undef mempcpy
-# define mempcpy(a,b,n) \
-    (GL_LINK_WARNING ("mempcpy is unportable - " \
-                      "use gnulib module mempcpy for portability"), \
-     mempcpy (a, b, n))
+# if HAVE_RAW_DECL_MEMPCPY
+_GL_WARN_ON_USE (mempcpy, "mempcpy is unportable - "
+                 "use gnulib module mempcpy for portability");
+# endif
 #endif
 
 /* Search backwards through a block for a byte (specified as an int).  */
 #if @GNULIB_MEMRCHR@
 # if ! @HAVE_DECL_MEMRCHR@
-extern void *memrchr (void const *, int, size_t)
-  __attribute__ ((__pure__));
+_GL_FUNCDECL_SYS (memrchr, void *, (void const *, int, size_t)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const void * std::memrchr (const void *, int, size_t); }
+       extern "C++" { void * std::memrchr (void *, int, size_t); }  */
+_GL_CXXALIAS_SYS_CAST2 (memrchr,
+                        void *, (void const *, int, size_t),
+                        void const *, (void const *, int, size_t));
+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 10 \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (memrchr, void *, (void *, int, size_t));
+_GL_CXXALIASWARN1 (memrchr, void const *, (void const *, int, size_t));
+# else
+_GL_CXXALIASWARN (memrchr);
 # endif
 #elif defined GNULIB_POSIXCHECK
 # undef memrchr
-# define memrchr(a,b,c) \
-    (GL_LINK_WARNING ("memrchr is unportable - " \
-                      "use gnulib module memrchr for portability"), \
-     memrchr (a, b, c))
+# if HAVE_RAW_DECL_MEMRCHR
+_GL_WARN_ON_USE (memrchr, "memrchr is unportable - "
+                 "use gnulib module memrchr for portability");
+# endif
 #endif
 
 /* Find the first occurrence of C in S.  More efficient than
@@ -102,119 +185,221 @@ extern void *memrchr (void const *, int,
    occur within N bytes.  */
 #if @GNULIB_RAWMEMCHR@
 # if ! @HAVE_RAWMEMCHR@
-extern void *rawmemchr (void const *__s, int __c_in)
-  __attribute__ ((__pure__));
+_GL_FUNCDECL_SYS (rawmemchr, void *, (void const *__s, int __c_in)
+                                     _GL_ATTRIBUTE_PURE
+                                     _GL_ARG_NONNULL ((1)));
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const void * std::rawmemchr (const void *, int); }
+       extern "C++" { void * std::rawmemchr (void *, int); }  */
+_GL_CXXALIAS_SYS_CAST2 (rawmemchr,
+                        void *, (void const *__s, int __c_in),
+                        void const *, (void const *__s, int __c_in));
+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 10 \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (rawmemchr, void *, (void *__s, int __c_in));
+_GL_CXXALIASWARN1 (rawmemchr, void const *, (void const *__s, int __c_in));
+# else
+_GL_CXXALIASWARN (rawmemchr);
 # endif
 #elif defined GNULIB_POSIXCHECK
 # undef rawmemchr
-# define rawmemchr(a,b) \
-    (GL_LINK_WARNING ("rawmemchr is unportable - " \
-                      "use gnulib module rawmemchr for portability"), \
-     rawmemchr (a, b))
+# if HAVE_RAW_DECL_RAWMEMCHR
+_GL_WARN_ON_USE (rawmemchr, "rawmemchr is unportable - "
+                 "use gnulib module rawmemchr for portability");
+# endif
 #endif
 
 /* Copy SRC to DST, returning the address of the terminating '\0' in DST.  */
 #if @GNULIB_STPCPY@
 # if ! @HAVE_STPCPY@
-extern char *stpcpy (char *restrict __dst, char const *restrict __src);
-# endif
+_GL_FUNCDECL_SYS (stpcpy, char *,
+                  (char *restrict __dst, char const *restrict __src)
+                  _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (stpcpy, char *,
+                  (char *restrict __dst, char const *restrict __src));
+_GL_CXXALIASWARN (stpcpy);
 #elif defined GNULIB_POSIXCHECK
 # undef stpcpy
-# define stpcpy(a,b) \
-    (GL_LINK_WARNING ("stpcpy is unportable - " \
-                      "use gnulib module stpcpy for portability"), \
-     stpcpy (a, b))
+# if HAVE_RAW_DECL_STPCPY
+_GL_WARN_ON_USE (stpcpy, "stpcpy is unportable - "
+                 "use gnulib module stpcpy for portability");
+# endif
 #endif
 
 /* Copy no more than N bytes of SRC to DST, returning a pointer past the
    last non-NUL byte written into DST.  */
 #if @GNULIB_STPNCPY@
-# if ! @HAVE_STPNCPY@
-#  define stpncpy gnu_stpncpy
-extern char *stpncpy (char *restrict __dst, char const *restrict __src,
-		      size_t __n);
+# if @REPLACE_STPNCPY@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define stpncpy rpl_stpncpy
+#  endif
+_GL_FUNCDECL_RPL (stpncpy, char *,
+                  (char *restrict __dst, char const *restrict __src,
+                   size_t __n)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (stpncpy, char *,
+                  (char *restrict __dst, char const *restrict __src,
+                   size_t __n));
+# else
+#  if ! @HAVE_STPNCPY@
+_GL_FUNCDECL_SYS (stpncpy, char *,
+                  (char *restrict __dst, char const *restrict __src,
+                   size_t __n)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (stpncpy, char *,
+                  (char *restrict __dst, char const *restrict __src,
+                   size_t __n));
 # endif
+_GL_CXXALIASWARN (stpncpy);
 #elif defined GNULIB_POSIXCHECK
 # undef stpncpy
-# define stpncpy(a,b,n) \
-    (GL_LINK_WARNING ("stpncpy is unportable - " \
-                      "use gnulib module stpncpy for portability"), \
-     stpncpy (a, b, n))
+# if HAVE_RAW_DECL_STPNCPY
+_GL_WARN_ON_USE (stpncpy, "stpncpy is unportable - "
+                 "use gnulib module stpncpy for portability");
+# endif
 #endif
 
 #if defined GNULIB_POSIXCHECK
 /* strchr() does not work with multibyte strings if the locale encoding is
    GB18030 and the character to be searched is a digit.  */
 # undef strchr
-# define strchr(s,c) \
-    (GL_LINK_WARNING ("strchr cannot work correctly on character strings " \
-                      "in some multibyte locales - " \
-                      "use mbschr if you care about internationalization"), \
-     strchr (s, c))
+/* Assume strchr is always declared.  */
+_GL_WARN_ON_USE (strchr, "strchr cannot work correctly on character strings "
+                 "in some multibyte locales - "
+                 "use mbschr if you care about internationalization");
 #endif
 
 /* Find the first occurrence of C in S or the final NUL byte.  */
 #if @GNULIB_STRCHRNUL@
 # if ! @HAVE_STRCHRNUL@
-extern char *strchrnul (char const *__s, int __c_in)
-  __attribute__ ((__pure__));
+_GL_FUNCDECL_SYS (strchrnul, char *, (char const *__s, int __c_in)
+                                     _GL_ATTRIBUTE_PURE
+                                     _GL_ARG_NONNULL ((1)));
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const char * std::strchrnul (const char *, int); }
+       extern "C++" { char * std::strchrnul (char *, int); }  */
+_GL_CXXALIAS_SYS_CAST2 (strchrnul,
+                        char *, (char const *__s, int __c_in),
+                        char const *, (char const *__s, int __c_in));
+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 10 \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (strchrnul, char *, (char *__s, int __c_in));
+_GL_CXXALIASWARN1 (strchrnul, char const *, (char const *__s, int __c_in));
+# else
+_GL_CXXALIASWARN (strchrnul);
 # endif
 #elif defined GNULIB_POSIXCHECK
 # undef strchrnul
-# define strchrnul(a,b) \
-    (GL_LINK_WARNING ("strchrnul is unportable - " \
-                      "use gnulib module strchrnul for portability"), \
-     strchrnul (a, b))
+# if HAVE_RAW_DECL_STRCHRNUL
+_GL_WARN_ON_USE (strchrnul, "strchrnul is unportable - "
+                 "use gnulib module strchrnul for portability");
+# endif
 #endif
 
 /* Duplicate S, returning an identical malloc'd string.  */
 #if @GNULIB_STRDUP@
 # if @REPLACE_STRDUP@
-#  undef strdup
-#  define strdup rpl_strdup
-# endif
-# if !(@HAVE_DECL_STRDUP@ || defined strdup) || @REPLACE_STRDUP@
-extern char *strdup (char const *__s);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strdup
+#   define strdup rpl_strdup
+#  endif
+_GL_FUNCDECL_RPL (strdup, char *, (char const *__s) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strdup, char *, (char const *__s));
+# else
+#  if !(@HAVE_DECL_STRDUP@ || defined strdup)
+_GL_FUNCDECL_SYS (strdup, char *, (char const *__s) _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strdup, char *, (char const *__s));
 # endif
+_GL_CXXALIASWARN (strdup);
 #elif defined GNULIB_POSIXCHECK
 # undef strdup
-# define strdup(a) \
-    (GL_LINK_WARNING ("strdup is unportable - " \
-                      "use gnulib module strdup for portability"), \
-     strdup (a))
+# if HAVE_RAW_DECL_STRDUP
+_GL_WARN_ON_USE (strdup, "strdup is unportable - "
+                 "use gnulib module strdup for portability");
+# endif
+#endif
+
+/* Append no more than N characters from SRC onto DEST.  */
+#if @GNULIB_STRNCAT@
+# if @REPLACE_STRNCAT@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strncat
+#   define strncat rpl_strncat
+#  endif
+_GL_FUNCDECL_RPL (strncat, char *, (char *dest, const char *src, size_t n)
+                                   _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (strncat, char *, (char *dest, const char *src, size_t n));
+# else
+_GL_CXXALIAS_SYS (strncat, char *, (char *dest, const char *src, size_t n));
+# endif
+_GL_CXXALIASWARN (strncat);
+#elif defined GNULIB_POSIXCHECK
+# undef strncat
+# if HAVE_RAW_DECL_STRNCAT
+_GL_WARN_ON_USE (strncat, "strncat is unportable - "
+                 "use gnulib module strncat for portability");
+# endif
 #endif
 
 /* Return a newly allocated copy of at most N bytes of STRING.  */
 #if @GNULIB_STRNDUP@
-# if ! @HAVE_STRNDUP@
-#  undef strndup
-#  define strndup rpl_strndup
-# endif
-# if ! @HAVE_STRNDUP@ || ! @HAVE_DECL_STRNDUP@
-extern char *strndup (char const *__string, size_t __n);
+# if @REPLACE_STRNDUP@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strndup
+#   define strndup rpl_strndup
+#  endif
+_GL_FUNCDECL_RPL (strndup, char *, (char const *__string, size_t __n)
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strndup, char *, (char const *__string, size_t __n));
+# else
+#  if ! @HAVE_DECL_STRNDUP@
+_GL_FUNCDECL_SYS (strndup, char *, (char const *__string, size_t __n)
+                                   _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strndup, char *, (char const *__string, size_t __n));
 # endif
+_GL_CXXALIASWARN (strndup);
 #elif defined GNULIB_POSIXCHECK
 # undef strndup
-# define strndup(a,n) \
-    (GL_LINK_WARNING ("strndup is unportable - " \
-                      "use gnulib module strndup for portability"), \
-     strndup (a, n))
+# if HAVE_RAW_DECL_STRNDUP
+_GL_WARN_ON_USE (strndup, "strndup is unportable - "
+                 "use gnulib module strndup for portability");
+# endif
 #endif
 
 /* Find the length (number of bytes) of STRING, but scan at most
    MAXLEN bytes.  If no '\0' terminator is found in that many bytes,
    return MAXLEN.  */
 #if @GNULIB_STRNLEN@
-# if ! @HAVE_DECL_STRNLEN@
-extern size_t strnlen (char const *__string, size_t __maxlen)
-  __attribute__ ((__pure__));
+# if @REPLACE_STRNLEN@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strnlen
+#   define strnlen rpl_strnlen
+#  endif
+_GL_FUNCDECL_RPL (strnlen, size_t, (char const *__string, size_t __maxlen)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strnlen, size_t, (char const *__string, size_t __maxlen));
+# else
+#  if ! @HAVE_DECL_STRNLEN@
+_GL_FUNCDECL_SYS (strnlen, size_t, (char const *__string, size_t __maxlen)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strnlen, size_t, (char const *__string, size_t __maxlen));
 # endif
+_GL_CXXALIASWARN (strnlen);
 #elif defined GNULIB_POSIXCHECK
 # undef strnlen
-# define strnlen(a,n) \
-    (GL_LINK_WARNING ("strnlen is unportable - " \
-                      "use gnulib module strnlen for portability"), \
-     strnlen (a, n))
+# if HAVE_RAW_DECL_STRNLEN
+_GL_WARN_ON_USE (strnlen, "strnlen is unportable - "
+                 "use gnulib module strnlen for portability");
+# endif
 #endif
 
 #if defined GNULIB_POSIXCHECK
@@ -223,18 +408,32 @@ extern size_t strnlen (char const *__str
    locale encoding is GB18030 and one of the characters to be searched is a
    digit.  */
 # undef strcspn
-# define strcspn(s,a) \
-    (GL_LINK_WARNING ("strcspn cannot work correctly on character strings " \
-                      "in multibyte locales - " \
-                      "use mbscspn if you care about internationalization"), \
-     strcspn (s, a))
+/* Assume strcspn is always declared.  */
+_GL_WARN_ON_USE (strcspn, "strcspn cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbscspn if you care about internationalization");
 #endif
 
 /* Find the first occurrence in S of any character in ACCEPT.  */
 #if @GNULIB_STRPBRK@
 # if ! @HAVE_STRPBRK@
-extern char *strpbrk (char const *__s, char const *__accept)
-  __attribute__ ((__pure__));
+_GL_FUNCDECL_SYS (strpbrk, char *, (char const *__s, char const *__accept)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1, 2)));
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C" { const char * strpbrk (const char *, const char *); }
+       extern "C++" { char * strpbrk (char *, const char *); }  */
+_GL_CXXALIAS_SYS_CAST2 (strpbrk,
+                        char *, (char const *__s, char const *__accept),
+                        const char *, (char const *__s, char const *__accept));
+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 10 \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (strpbrk, char *, (char *__s, char const *__accept));
+_GL_CXXALIASWARN1 (strpbrk, char const *,
+                   (char const *__s, char const *__accept));
+# else
+_GL_CXXALIASWARN (strpbrk);
 # endif
 # if defined GNULIB_POSIXCHECK
 /* strpbrk() assumes the second argument is a list of single-byte characters.
@@ -242,40 +441,36 @@ extern char *strpbrk (char const *__s, c
    locale encoding is GB18030 and one of the characters to be searched is a
    digit.  */
 #  undef strpbrk
-#  define strpbrk(s,a) \
-     (GL_LINK_WARNING ("strpbrk cannot work correctly on character strings " \
-                       "in multibyte locales - " \
-                       "use mbspbrk if you care about internationalization"), \
-      strpbrk (s, a))
+_GL_WARN_ON_USE (strpbrk, "strpbrk cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbspbrk if you care about internationalization");
 # endif
 #elif defined GNULIB_POSIXCHECK
 # undef strpbrk
-# define strpbrk(s,a) \
-    (GL_LINK_WARNING ("strpbrk is unportable - " \
-                      "use gnulib module strpbrk for portability"), \
-     strpbrk (s, a))
+# if HAVE_RAW_DECL_STRPBRK
+_GL_WARN_ON_USE (strpbrk, "strpbrk is unportable - "
+                 "use gnulib module strpbrk for portability");
+# endif
 #endif
 
 #if defined GNULIB_POSIXCHECK
 /* strspn() assumes the second argument is a list of single-byte characters.
    Even in this simple case, it cannot work with multibyte strings.  */
 # undef strspn
-# define strspn(s,a) \
-    (GL_LINK_WARNING ("strspn cannot work correctly on character strings " \
-                      "in multibyte locales - " \
-                      "use mbsspn if you care about internationalization"), \
-     strspn (s, a))
+/* Assume strspn is always declared.  */
+_GL_WARN_ON_USE (strspn, "strspn cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbsspn if you care about internationalization");
 #endif
 
 #if defined GNULIB_POSIXCHECK
 /* strrchr() does not work with multibyte strings if the locale encoding is
    GB18030 and the character to be searched is a digit.  */
 # undef strrchr
-# define strrchr(s,c) \
-    (GL_LINK_WARNING ("strrchr cannot work correctly on character strings " \
-                      "in some multibyte locales - " \
-                      "use mbsrchr if you care about internationalization"), \
-     strrchr (s, c))
+/* Assume strrchr is always declared.  */
+_GL_WARN_ON_USE (strrchr, "strrchr cannot work correctly on character strings "
+                 "in some multibyte locales - "
+                 "use mbsrchr if you care about internationalization");
 #endif
 
 /* Search the next delimiter (char listed in DELIM) starting at *STRINGP.
@@ -296,29 +491,51 @@ extern char *strpbrk (char const *__s, c
    See also strtok_r().  */
 #if @GNULIB_STRSEP@
 # if ! @HAVE_STRSEP@
-extern char *strsep (char **restrict __stringp, char const *restrict __delim);
-# endif
+_GL_FUNCDECL_SYS (strsep, char *,
+                  (char **restrict __stringp, char const *restrict __delim)
+                  _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (strsep, char *,
+                  (char **restrict __stringp, char const *restrict __delim));
+_GL_CXXALIASWARN (strsep);
 # if defined GNULIB_POSIXCHECK
 #  undef strsep
-#  define strsep(s,d) \
-     (GL_LINK_WARNING ("strsep cannot work correctly on character strings " \
-                       "in multibyte locales - " \
-                       "use mbssep if you care about internationalization"), \
-      strsep (s, d))
+_GL_WARN_ON_USE (strsep, "strsep cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbssep if you care about internationalization");
 # endif
 #elif defined GNULIB_POSIXCHECK
 # undef strsep
-# define strsep(s,d) \
-    (GL_LINK_WARNING ("strsep is unportable - " \
-                      "use gnulib module strsep for portability"), \
-     strsep (s, d))
+# if HAVE_RAW_DECL_STRSEP
+_GL_WARN_ON_USE (strsep, "strsep is unportable - "
+                 "use gnulib module strsep for portability");
+# endif
 #endif
 
 #if @GNULIB_STRSTR@
 # if @REPLACE_STRSTR@
-#  define strstr rpl_strstr
-char *strstr (const char *haystack, const char *needle)
-  __attribute__ ((__pure__));
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strstr rpl_strstr
+#  endif
+_GL_FUNCDECL_RPL (strstr, char *, (const char *haystack, const char *needle)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (strstr, char *, (const char *haystack, const char *needle));
+# else
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const char * strstr (const char *, const char *); }
+       extern "C++" { char * strstr (char *, const char *); }  */
+_GL_CXXALIAS_SYS_CAST2 (strstr,
+                        char *, (const char *haystack, const char *needle),
+                        const char *, (const char *haystack, const char *needle));
+# endif
+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 10 \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (strstr, char *, (char *haystack, const char *needle));
+_GL_CXXALIASWARN1 (strstr, const char *,
+                   (const char *haystack, const char *needle));
+# else
+_GL_CXXALIASWARN (strstr);
 # endif
 #elif defined GNULIB_POSIXCHECK
 /* strstr() does not work with multibyte strings if the locale encoding is
@@ -326,48 +543,72 @@ char *strstr (const char *haystack, cons
    POSIX says that it operates on "strings", and "string" in POSIX is defined
    as a sequence of bytes, not of characters.  */
 # undef strstr
-# define strstr(a,b) \
-    (GL_LINK_WARNING ("strstr is quadratic on many systems, and cannot " \
-                      "work correctly on character strings in most "    \
-                      "multibyte locales - " \
-                      "use mbsstr if you care about internationalization, " \
-                      "or use strstr if you care about speed"), \
-     strstr (a, b))
+/* Assume strstr is always declared.  */
+_GL_WARN_ON_USE (strstr, "strstr is quadratic on many systems, and cannot "
+                 "work correctly on character strings in most "
+                 "multibyte locales - "
+                 "use mbsstr if you care about internationalization, "
+                 "or use strstr if you care about speed");
 #endif
 
 /* Find the first occurrence of NEEDLE in HAYSTACK, using case-insensitive
    comparison.  */
 #if @GNULIB_STRCASESTR@
 # if @REPLACE_STRCASESTR@
-#  define strcasestr rpl_strcasestr
-# endif
-# if ! @HAVE_STRCASESTR@ || @REPLACE_STRCASESTR@
-extern char *strcasestr (const char *haystack, const char *needle)
-  __attribute__ ((__pure__));
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strcasestr rpl_strcasestr
+#  endif
+_GL_FUNCDECL_RPL (strcasestr, char *,
+                  (const char *haystack, const char *needle)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (strcasestr, char *,
+                  (const char *haystack, const char *needle));
+# else
+#  if ! @HAVE_STRCASESTR@
+_GL_FUNCDECL_SYS (strcasestr, char *,
+                  (const char *haystack, const char *needle)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const char * strcasestr (const char *, const char *); }
+       extern "C++" { char * strcasestr (char *, const char *); }  */
+_GL_CXXALIAS_SYS_CAST2 (strcasestr,
+                        char *, (const char *haystack, const char *needle),
+                        const char *, (const char *haystack, const char *needle));
+# endif
+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 10 \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (strcasestr, char *, (char *haystack, const char *needle));
+_GL_CXXALIASWARN1 (strcasestr, const char *,
+                   (const char *haystack, const char *needle));
+# else
+_GL_CXXALIASWARN (strcasestr);
 # endif
 #elif defined GNULIB_POSIXCHECK
 /* strcasestr() does not work with multibyte strings:
    It is a glibc extension, and glibc implements it only for unibyte
    locales.  */
 # undef strcasestr
-# define strcasestr(a,b) \
-    (GL_LINK_WARNING ("strcasestr does work correctly on character strings " \
-                      "in multibyte locales - " \
-                      "use mbscasestr if you care about " \
-                      "internationalization, or use c-strcasestr if you want " \
-                      "a locale independent function"), \
-     strcasestr (a, b))
+# if HAVE_RAW_DECL_STRCASESTR
+_GL_WARN_ON_USE (strcasestr, "strcasestr does work correctly on character "
+                 "strings in multibyte locales - "
+                 "use mbscasestr if you care about "
+                 "internationalization, or use c-strcasestr if you want "
+                 "a locale independent function");
+# endif
 #endif
 
 /* Parse S into tokens separated by characters in DELIM.
    If S is NULL, the saved pointer in SAVE_PTR is used as
    the next starting point.  For example:
-	char s[] = "-abc-=-def";
-	char *sp;
-	x = strtok_r(s, "-", &sp);	// x = "abc", sp = "=-def"
-	x = strtok_r(NULL, "-=", &sp);	// x = "def", sp = NULL
-	x = strtok_r(NULL, "=", &sp);	// x = NULL
-		// s = "abc\0-def\0"
+        char s[] = "-abc-=-def";
+        char *sp;
+        x = strtok_r(s, "-", &sp);      // x = "abc", sp = "=-def"
+        x = strtok_r(NULL, "-=", &sp);  // x = "def", sp = NULL
+        x = strtok_r(NULL, "=", &sp);   // x = NULL
+                // s = "abc\0-def\0"
 
    This is a variant of strtok() that is multithread-safe.
 
@@ -382,24 +623,44 @@ extern char *strcasestr (const char *hay
 
    See also strsep().  */
 #if @GNULIB_STRTOK_R@
-# if ! @HAVE_DECL_STRTOK_R@
-extern char *strtok_r (char *restrict s, char const *restrict delim,
-		       char **restrict save_ptr);
+# if @REPLACE_STRTOK_R@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strtok_r
+#   define strtok_r rpl_strtok_r
+#  endif
+_GL_FUNCDECL_RPL (strtok_r, char *,
+                  (char *restrict s, char const *restrict delim,
+                   char **restrict save_ptr)
+                  _GL_ARG_NONNULL ((2, 3)));
+_GL_CXXALIAS_RPL (strtok_r, char *,
+                  (char *restrict s, char const *restrict delim,
+                   char **restrict save_ptr));
+# else
+#  if @UNDEFINE_STRTOK_R@ || defined GNULIB_POSIXCHECK
+#   undef strtok_r
+#  endif
+#  if ! @HAVE_DECL_STRTOK_R@
+_GL_FUNCDECL_SYS (strtok_r, char *,
+                  (char *restrict s, char const *restrict delim,
+                   char **restrict save_ptr)
+                  _GL_ARG_NONNULL ((2, 3)));
+#  endif
+_GL_CXXALIAS_SYS (strtok_r, char *,
+                  (char *restrict s, char const *restrict delim,
+                   char **restrict save_ptr));
 # endif
+_GL_CXXALIASWARN (strtok_r);
 # if defined GNULIB_POSIXCHECK
-#  undef strtok_r
-#  define strtok_r(s,d,p) \
-     (GL_LINK_WARNING ("strtok_r cannot work correctly on character strings " \
-                       "in multibyte locales - " \
-                       "use mbstok_r if you care about internationalization"), \
-      strtok_r (s, d, p))
+_GL_WARN_ON_USE (strtok_r, "strtok_r cannot work correctly on character "
+                 "strings in multibyte locales - "
+                 "use mbstok_r if you care about internationalization");
 # endif
 #elif defined GNULIB_POSIXCHECK
 # undef strtok_r
-# define strtok_r(s,d,p) \
-    (GL_LINK_WARNING ("strtok_r is unportable - " \
-                      "use gnulib module strtok_r for portability"), \
-     strtok_r (s, d, p))
+# if HAVE_RAW_DECL_STRTOK_R
+_GL_WARN_ON_USE (strtok_r, "strtok_r is unportable - "
+                 "use gnulib module strtok_r for portability");
+# endif
 #endif
 
 
@@ -409,13 +670,27 @@ extern char *strtok_r (char *restrict s,
 #if @GNULIB_MBSLEN@
 /* Return the number of multibyte characters in the character string STRING.
    This considers multibyte characters, unlike strlen, which counts bytes.  */
-extern size_t mbslen (const char *string);
+# ifdef __MirBSD__  /* MirBSD defines mbslen as a macro.  Override it.  */
+#  undef mbslen
+# endif
+# if @HAVE_MBSLEN@  /* AIX, OSF/1, MirBSD define mbslen already in libc.  */
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbslen rpl_mbslen
+#  endif
+_GL_FUNCDECL_RPL (mbslen, size_t, (const char *string) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mbslen, size_t, (const char *string));
+# else
+_GL_FUNCDECL_SYS (mbslen, size_t, (const char *string) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (mbslen, size_t, (const char *string));
+# endif
+_GL_CXXALIASWARN (mbslen);
 #endif
 
 #if @GNULIB_MBSNLEN@
 /* Return the number of multibyte characters in the character string starting
    at STRING and ending at STRING + LEN.  */
-extern size_t mbsnlen (const char *string, size_t len);
+_GL_EXTERN_C size_t mbsnlen (const char *string, size_t len)
+     _GL_ARG_NONNULL ((1));
 #endif
 
 #if @GNULIB_MBSCHR@
@@ -423,8 +698,19 @@ extern size_t mbsnlen (const char *strin
    and return a pointer to it.  Return NULL if C is not found in STRING.
    Unlike strchr(), this function works correctly in multibyte locales with
    encodings such as GB18030.  */
-# define mbschr rpl_mbschr /* avoid collision with HP-UX function */
-extern char * mbschr (const char *string, int c);
+# if defined __hpux
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbschr rpl_mbschr /* avoid collision with HP-UX function */
+#  endif
+_GL_FUNCDECL_RPL (mbschr, char *, (const char *string, int c)
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mbschr, char *, (const char *string, int c));
+# else
+_GL_FUNCDECL_SYS (mbschr, char *, (const char *string, int c)
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (mbschr, char *, (const char *string, int c));
+# endif
+_GL_CXXALIASWARN (mbschr);
 #endif
 
 #if @GNULIB_MBSRCHR@
@@ -432,8 +718,19 @@ extern char * mbschr (const char *string
    and return a pointer to it.  Return NULL if C is not found in STRING.
    Unlike strrchr(), this function works correctly in multibyte locales with
    encodings such as GB18030.  */
-# define mbsrchr rpl_mbsrchr /* avoid collision with HP-UX function */
-extern char * mbsrchr (const char *string, int c);
+# if defined __hpux
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbsrchr rpl_mbsrchr /* avoid collision with HP-UX function */
+#  endif
+_GL_FUNCDECL_RPL (mbsrchr, char *, (const char *string, int c)
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mbsrchr, char *, (const char *string, int c));
+# else
+_GL_FUNCDECL_SYS (mbsrchr, char *, (const char *string, int c)
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (mbsrchr, char *, (const char *string, int c));
+# endif
+_GL_CXXALIASWARN (mbsrchr);
 #endif
 
 #if @GNULIB_MBSSTR@
@@ -441,7 +738,8 @@ extern char * mbsrchr (const char *strin
    string HAYSTACK.  Return NULL if NEEDLE is not found in HAYSTACK.
    Unlike strstr(), this function works correctly in multibyte locales with
    encodings different from UTF-8.  */
-extern char * mbsstr (const char *haystack, const char *needle);
+_GL_EXTERN_C char * mbsstr (const char *haystack, const char *needle)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSCASECMP@
@@ -451,7 +749,8 @@ extern char * mbsstr (const char *haysta
    Note: This function may, in multibyte locales, return 0 for strings of
    different lengths!
    Unlike strcasecmp(), this function works correctly in multibyte locales.  */
-extern int mbscasecmp (const char *s1, const char *s2);
+_GL_EXTERN_C int mbscasecmp (const char *s1, const char *s2)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSNCASECMP@
@@ -464,7 +763,8 @@ extern int mbscasecmp (const char *s1, c
    of different lengths!
    Unlike strncasecmp(), this function works correctly in multibyte locales.
    But beware that N is not a byte count but a character count!  */
-extern int mbsncasecmp (const char *s1, const char *s2, size_t n);
+_GL_EXTERN_C int mbsncasecmp (const char *s1, const char *s2, size_t n)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSPCASECMP@
@@ -477,7 +777,8 @@ extern int mbsncasecmp (const char *s1,
    smaller length than PREFIX!
    Unlike strncasecmp(), this function works correctly in multibyte
    locales.  */
-extern char * mbspcasecmp (const char *string, const char *prefix);
+_GL_EXTERN_C char * mbspcasecmp (const char *string, const char *prefix)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSCASESTR@
@@ -486,7 +787,8 @@ extern char * mbspcasecmp (const char *s
    Note: This function may, in multibyte locales, return success even if
    strlen (haystack) < strlen (needle) !
    Unlike strcasestr(), this function works correctly in multibyte locales.  */
-extern char * mbscasestr (const char *haystack, const char *needle);
+_GL_EXTERN_C char * mbscasestr (const char *haystack, const char *needle)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSCSPN@
@@ -495,7 +797,8 @@ extern char * mbscasestr (const char *ha
    beginning of the string to this occurrence, or to the end of the string
    if none exists.
    Unlike strcspn(), this function works correctly in multibyte locales.  */
-extern size_t mbscspn (const char *string, const char *accept);
+_GL_EXTERN_C size_t mbscspn (const char *string, const char *accept)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSPBRK@
@@ -503,8 +806,19 @@ extern size_t mbscspn (const char *strin
    in the character string ACCEPT.  Return the pointer to it, or NULL if none
    exists.
    Unlike strpbrk(), this function works correctly in multibyte locales.  */
-# define mbspbrk rpl_mbspbrk /* avoid collision with HP-UX function */
-extern char * mbspbrk (const char *string, const char *accept);
+# if defined __hpux
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbspbrk rpl_mbspbrk /* avoid collision with HP-UX function */
+#  endif
+_GL_FUNCDECL_RPL (mbspbrk, char *, (const char *string, const char *accept)
+                                   _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (mbspbrk, char *, (const char *string, const char *accept));
+# else
+_GL_FUNCDECL_SYS (mbspbrk, char *, (const char *string, const char *accept)
+                                   _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_SYS (mbspbrk, char *, (const char *string, const char *accept));
+# endif
+_GL_CXXALIASWARN (mbspbrk);
 #endif
 
 #if @GNULIB_MBSSPN@
@@ -513,7 +827,8 @@ extern char * mbspbrk (const char *strin
    beginning of the string to this occurrence, or to the end of the string
    if none exists.
    Unlike strspn(), this function works correctly in multibyte locales.  */
-extern size_t mbsspn (const char *string, const char *reject);
+_GL_EXTERN_C size_t mbsspn (const char *string, const char *reject)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSSEP@
@@ -531,7 +846,8 @@ extern size_t mbsspn (const char *string
    Caveat: The identity of the delimiting character is lost.
 
    See also mbstok_r().  */
-extern char * mbssep (char **stringp, const char *delim);
+_GL_EXTERN_C char * mbssep (char **stringp, const char *delim)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSTOK_R@
@@ -539,67 +855,81 @@ extern char * mbssep (char **stringp, co
    the character string DELIM.
    If STRING is NULL, the saved pointer in SAVE_PTR is used as
    the next starting point.  For example:
-	char s[] = "-abc-=-def";
-	char *sp;
-	x = mbstok_r(s, "-", &sp);	// x = "abc", sp = "=-def"
-	x = mbstok_r(NULL, "-=", &sp);	// x = "def", sp = NULL
-	x = mbstok_r(NULL, "=", &sp);	// x = NULL
-		// s = "abc\0-def\0"
+        char s[] = "-abc-=-def";
+        char *sp;
+        x = mbstok_r(s, "-", &sp);      // x = "abc", sp = "=-def"
+        x = mbstok_r(NULL, "-=", &sp);  // x = "def", sp = NULL
+        x = mbstok_r(NULL, "=", &sp);   // x = NULL
+                // s = "abc\0-def\0"
 
    Caveat: It modifies the original string.
    Caveat: These functions cannot be used on constant strings.
    Caveat: The identity of the delimiting character is lost.
 
    See also mbssep().  */
-extern char * mbstok_r (char *string, const char *delim, char **save_ptr);
+_GL_EXTERN_C char * mbstok_r (char *string, const char *delim, char **save_ptr)
+     _GL_ARG_NONNULL ((2, 3));
 #endif
 
 /* Map any int, typically from errno, into an error message.  */
 #if @GNULIB_STRERROR@
 # if @REPLACE_STRERROR@
-#  undef strerror
-#  define strerror rpl_strerror
-extern char *strerror (int);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strerror
+#   define strerror rpl_strerror
+#  endif
+_GL_FUNCDECL_RPL (strerror, char *, (int));
+_GL_CXXALIAS_RPL (strerror, char *, (int));
+# else
+_GL_CXXALIAS_SYS (strerror, char *, (int));
 # endif
+_GL_CXXALIASWARN (strerror);
 #elif defined GNULIB_POSIXCHECK
 # undef strerror
-# define strerror(e) \
-    (GL_LINK_WARNING ("strerror is unportable - " \
-                      "use gnulib module strerror to guarantee non-NULL result"), \
-     strerror (e))
+/* Assume strerror is always declared.  */
+_GL_WARN_ON_USE (strerror, "strerror is unportable - "
+                 "use gnulib module strerror to guarantee non-NULL result");
 #endif
 
 #if @GNULIB_STRSIGNAL@
 # if @REPLACE_STRSIGNAL@
-#  define strsignal rpl_strsignal
-# endif
-# if ! @HAVE_DECL_STRSIGNAL@ || @REPLACE_STRSIGNAL@
-extern char *strsignal (int __sig);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strsignal rpl_strsignal
+#  endif
+_GL_FUNCDECL_RPL (strsignal, char *, (int __sig));
+_GL_CXXALIAS_RPL (strsignal, char *, (int __sig));
+# else
+#  if ! @HAVE_DECL_STRSIGNAL@
+_GL_FUNCDECL_SYS (strsignal, char *, (int __sig));
+#  endif
+/* Need to cast, because on Cygwin 1.5.x systems, the return type is
+   'const char *'.  */
+_GL_CXXALIAS_SYS_CAST (strsignal, char *, (int __sig));
 # endif
+_GL_CXXALIASWARN (strsignal);
 #elif defined GNULIB_POSIXCHECK
 # undef strsignal
-# define strsignal(a) \
-    (GL_LINK_WARNING ("strsignal is unportable - " \
-                      "use gnulib module strsignal for portability"), \
-     strsignal (a))
+# if HAVE_RAW_DECL_STRSIGNAL
+_GL_WARN_ON_USE (strsignal, "strsignal is unportable - "
+                 "use gnulib module strsignal for portability");
+# endif
 #endif
 
 #if @GNULIB_STRVERSCMP@
 # if !@HAVE_STRVERSCMP@
-extern int strverscmp (const char *, const char *);
+_GL_FUNCDECL_SYS (strverscmp, int, (const char *, const char *)
+                                   _GL_ARG_NONNULL ((1, 2)));
 # endif
+_GL_CXXALIAS_SYS (strverscmp, int, (const char *, const char *));
+_GL_CXXALIASWARN (strverscmp);
 #elif defined GNULIB_POSIXCHECK
 # undef strverscmp
-# define strverscmp(a, b) \
-    (GL_LINK_WARNING ("strverscmp is unportable - " \
-                      "use gnulib module strverscmp for portability"), \
-     strverscmp (a, b))
+# if HAVE_RAW_DECL_STRVERSCMP
+_GL_WARN_ON_USE (strverscmp, "strverscmp is unportable - "
+                 "use gnulib module strverscmp for portability");
+# endif
 #endif
 
 
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* _GL_STRING_H */
 #endif /* _GL_STRING_H */
--- a/gl/unistd.in.h
+++ b/gl/unistd.in.h
@@ -1,5 +1,5 @@
 /* Substitute for and wrapper around <unistd.h>.
-   Copyright (C) 2003-2009 Free Software Foundation, Inc.
+   Copyright (C) 2003-2010 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -15,77 +15,171 @@
    along with this program; if not, write to the Free Software Foundation,
    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
 
-#ifndef _GL_UNISTD_H
-
 #if __GNUC__ >= 3
 @PRAGMA_SYSTEM_HEADER@
 #endif
 
+/* Special invocation convention:
+   - On mingw, several headers, including <winsock2.h>, include <unistd.h>,
+     but we need to ensure that both the system <unistd.h> and <winsock2.h>
+     are completely included before we replace gethostname.  */
+#if @GNULIB_GETHOSTNAME@ && @UNISTD_H_HAVE_WINSOCK2_H@ \
+  && !defined _GL_WINSOCK2_H_WITNESS && defined _WINSOCK2_H
+/* <unistd.h> is being indirectly included for the first time from
+   <winsock2.h>; avoid declaring any overrides.  */
+# if @HAVE_UNISTD_H@
+#  @INCLUDE_NEXT@ @NEXT_UNISTD_H@
+# else
+#  error unexpected; report this to bug-gnulib@gnu.org
+# endif
+# define _GL_WINSOCK2_H_WITNESS
+
+/* Normal invocation.  */
+#elif !defined _GL_UNISTD_H
+
 /* The include_next requires a split double-inclusion guard.  */
 #if @HAVE_UNISTD_H@
 # @INCLUDE_NEXT@ @NEXT_UNISTD_H@
 #endif
 
-#ifndef _GL_UNISTD_H
+/* Get all possible declarations of gethostname().  */
+#if @GNULIB_GETHOSTNAME@ && @UNISTD_H_HAVE_WINSOCK2_H@ \
+  && !defined _GL_INCLUDING_WINSOCK2_H
+# define _GL_INCLUDING_WINSOCK2_H
+# include <winsock2.h>
+# undef _GL_INCLUDING_WINSOCK2_H
+#endif
+
+#if !defined _GL_UNISTD_H && !defined _GL_INCLUDING_WINSOCK2_H
 #define _GL_UNISTD_H
 
+/* NetBSD 5.0 mis-defines NULL.  Also get size_t.  */
+#include <stddef.h>
+
 /* mingw doesn't define the SEEK_* or *_FILENO macros in <unistd.h>.  */
-#if !(defined SEEK_CUR && defined SEEK_END && defined SEEK_SET)
+/* Cygwin 1.7.1 declares symlinkat in <stdio.h>, not in <unistd.h>.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if (!(defined SEEK_CUR && defined SEEK_END && defined SEEK_SET) \
+     || (@GNULIB_SYMLINKAT@ || defined GNULIB_POSIXCHECK)) \
+    && ! defined __GLIBC__
 # include <stdio.h>
 #endif
 
+/* Cygwin 1.7.1 declares unlinkat in <fcntl.h>, not in <unistd.h>.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if (@GNULIB_UNLINKAT@ || defined GNULIB_POSIXCHECK) && ! defined __GLIBC__
+# include <fcntl.h>
+#endif
+
 /* mingw fails to declare _exit in <unistd.h>.  */
 /* mingw, BeOS, Haiku declare environ in <stdlib.h>, not in <unistd.h>.  */
-#include <stdlib.h>
+/* Solaris declares getcwd not only in <unistd.h> but also in <stdlib.h>.  */
+/* But avoid namespace pollution on glibc systems.  */
+#ifndef __GLIBC__
+# include <stdlib.h>
+#endif
+
+/* mingw declares getcwd in <io.h>, not in <unistd.h>.  */
+#if ((@GNULIB_GETCWD@ || defined GNULIB_POSIXCHECK) \
+     && ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))
+# include <io.h>
+#endif
 
-#if @GNULIB_WRITE@ && @REPLACE_WRITE@ && @GNULIB_UNISTD_H_SIGPIPE@
+#if (@GNULIB_WRITE@ || @GNULIB_READLINK@ || @GNULIB_READLINKAT@ \
+     || @GNULIB_PREAD@ || @GNULIB_PWRITE@ || defined GNULIB_POSIXCHECK)
 /* Get ssize_t.  */
 # include <sys/types.h>
 #endif
 
+/* Get getopt(), optarg, optind, opterr, optopt.
+   But avoid namespace pollution on glibc systems.  */
+#if @GNULIB_UNISTD_H_GETOPT@ && !defined __GLIBC__ && !defined _GL_SYSTEM_GETOPT
+# include <getopt.h>
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+
+
 #if @GNULIB_GETHOSTNAME@
 /* Get all possible declarations of gethostname().  */
 # if @UNISTD_H_HAVE_WINSOCK2_H@
-#  include <winsock2.h>
 #  if !defined _GL_SYS_SOCKET_H
-#   undef socket
-#   define socket		socket_used_without_including_sys_socket_h
-#   undef connect
-#   define connect		connect_used_without_including_sys_socket_h
-#   undef accept
-#   define accept		accept_used_without_including_sys_socket_h
-#   undef bind
-#   define bind			bind_used_without_including_sys_socket_h
-#   undef getpeername
-#   define getpeername		getpeername_used_without_including_sys_socket_h
-#   undef getsockname
-#   define getsockname		getsockname_used_without_including_sys_socket_h
-#   undef getsockopt
-#   define getsockopt		getsockopt_used_without_including_sys_socket_h
-#   undef listen
-#   define listen		listen_used_without_including_sys_socket_h
-#   undef recv
-#   define recv			recv_used_without_including_sys_socket_h
-#   undef send
-#   define send			send_used_without_including_sys_socket_h
-#   undef recvfrom
-#   define recvfrom		recvfrom_used_without_including_sys_socket_h
-#   undef sendto
-#   define sendto		sendto_used_without_including_sys_socket_h
-#   undef setsockopt
-#   define setsockopt		setsockopt_used_without_including_sys_socket_h
-#   undef shutdown
-#   define shutdown		shutdown_used_without_including_sys_socket_h
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef socket
+#    define socket              socket_used_without_including_sys_socket_h
+#    undef connect
+#    define connect             connect_used_without_including_sys_socket_h
+#    undef accept
+#    define accept              accept_used_without_including_sys_socket_h
+#    undef bind
+#    define bind                bind_used_without_including_sys_socket_h
+#    undef getpeername
+#    define getpeername         getpeername_used_without_including_sys_socket_h
+#    undef getsockname
+#    define getsockname         getsockname_used_without_including_sys_socket_h
+#    undef getsockopt
+#    define getsockopt          getsockopt_used_without_including_sys_socket_h
+#    undef listen
+#    define listen              listen_used_without_including_sys_socket_h
+#    undef recv
+#    define recv                recv_used_without_including_sys_socket_h
+#    undef send
+#    define send                send_used_without_including_sys_socket_h
+#    undef recvfrom
+#    define recvfrom            recvfrom_used_without_including_sys_socket_h
+#    undef sendto
+#    define sendto              sendto_used_without_including_sys_socket_h
+#    undef setsockopt
+#    define setsockopt          setsockopt_used_without_including_sys_socket_h
+#    undef shutdown
+#    define shutdown            shutdown_used_without_including_sys_socket_h
+#   else
+     _GL_WARN_ON_USE (socket,
+                      "socket() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (connect,
+                      "connect() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (accept,
+                      "accept() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (bind,
+                      "bind() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (getpeername,
+                      "getpeername() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (getsockname,
+                      "getsockname() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (getsockopt,
+                      "getsockopt() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (listen,
+                      "listen() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (recv,
+                      "recv() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (send,
+                      "send() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (recvfrom,
+                      "recvfrom() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (sendto,
+                      "sendto() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (setsockopt,
+                      "setsockopt() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (shutdown,
+                      "shutdown() used without including <sys/socket.h>");
+#   endif
 #  endif
 #  if !defined _GL_SYS_SELECT_H
-#   undef select
-#   define select		select_used_without_including_sys_select_h
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef select
+#    define select              select_used_without_including_sys_select_h
+#   else
+     _GL_WARN_ON_USE (select,
+                      "select() used without including <sys/select.h>");
+#   endif
 #  endif
 # endif
 #endif
 
-/* The definition of GL_LINK_WARNING is copied here.  */
-
 
 /* OS/2 EMX lacks these macros.  */
 #ifndef STDIN_FILENO
@@ -98,72 +192,147 @@
 # define STDERR_FILENO 2
 #endif
 
+/* Ensure *_OK macros exist.  */
+#ifndef F_OK
+# define F_OK 0
+# define X_OK 1
+# define W_OK 2
+# define R_OK 4
+#endif
+
+
 /* Declare overridden functions.  */
 
-#ifdef __cplusplus
-extern "C" {
+
+#if defined GNULIB_POSIXCHECK
+/* The access() function is a security risk.  */
+_GL_WARN_ON_USE (access, "the access function is a security risk - "
+                 "use the gnulib module faccessat instead");
 #endif
 
 
 #if @GNULIB_CHOWN@
-# if @REPLACE_CHOWN@
-#  ifndef REPLACE_CHOWN
-#   define REPLACE_CHOWN 1
-#  endif
-#  if REPLACE_CHOWN
 /* Change the owner of FILE to UID (if UID is not -1) and the group of FILE
    to GID (if GID is not -1).  Follow symbolic links.
    Return 0 if successful, otherwise -1 and errno set.
    See the POSIX:2001 specification
    <http://www.opengroup.org/susv3xsh/chown.html>.  */
+# if @REPLACE_CHOWN@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef chown
 #   define chown rpl_chown
-extern int chown (const char *file, uid_t uid, gid_t gid);
 #  endif
+_GL_FUNCDECL_RPL (chown, int, (const char *file, uid_t uid, gid_t gid)
+                              _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (chown, int, (const char *file, uid_t uid, gid_t gid));
+# else
+#  if !@HAVE_CHOWN@
+_GL_FUNCDECL_SYS (chown, int, (const char *file, uid_t uid, gid_t gid)
+                              _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (chown, int, (const char *file, uid_t uid, gid_t gid));
 # endif
+_GL_CXXALIASWARN (chown);
 #elif defined GNULIB_POSIXCHECK
 # undef chown
-# define chown(f,u,g) \
-    (GL_LINK_WARNING ("chown fails to follow symlinks on some systems and " \
-                      "doesn't treat a uid or gid of -1 on some systems - " \
-                      "use gnulib module chown for portability"), \
-     chown (f, u, g))
+# if HAVE_RAW_DECL_CHOWN
+_GL_WARN_ON_USE (chown, "chown fails to follow symlinks on some systems and "
+                 "doesn't treat a uid or gid of -1 on some systems - "
+                 "use gnulib module chown for portability");
+# endif
 #endif
 
 
 #if @GNULIB_CLOSE@
 # if @REPLACE_CLOSE@
 /* Automatically included by modules that need a replacement for close.  */
-#  undef close
-#  define close rpl_close
-extern int close (int);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef close
+#   define close rpl_close
+#  endif
+_GL_FUNCDECL_RPL (close, int, (int fd));
+_GL_CXXALIAS_RPL (close, int, (int fd));
+# else
+_GL_CXXALIAS_SYS (close, int, (int fd));
 # endif
-#elif @UNISTD_H_HAVE_WINSOCK2_H@
+_GL_CXXALIASWARN (close);
+#elif @UNISTD_H_HAVE_WINSOCK2_H_AND_USE_SOCKETS@
 # undef close
 # define close close_used_without_requesting_gnulib_module_close
 #elif defined GNULIB_POSIXCHECK
 # undef close
-# define close(f) \
-    (GL_LINK_WARNING ("close does not portably work on sockets - " \
-                      "use gnulib module close for portability"), \
-     close (f))
+/* Assume close is always declared.  */
+_GL_WARN_ON_USE (close, "close does not portably work on sockets - "
+                 "use gnulib module close for portability");
 #endif
 
 
+#if @REPLACE_DUP@
+# if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#  define dup rpl_dup
+# endif
+_GL_FUNCDECL_RPL (dup, int, (int oldfd));
+_GL_CXXALIAS_RPL (dup, int, (int oldfd));
+#else
+_GL_CXXALIAS_SYS (dup, int, (int oldfd));
+#endif
+_GL_CXXALIASWARN (dup);
+
+
 #if @GNULIB_DUP2@
-# if !@HAVE_DUP2@
 /* Copy the file descriptor OLDFD into file descriptor NEWFD.  Do nothing if
    NEWFD = OLDFD, otherwise close NEWFD first if it is open.
-   Return 0 if successful, otherwise -1 and errno set.
+   Return newfd if successful, otherwise -1 and errno set.
    See the POSIX:2001 specification
    <http://www.opengroup.org/susv3xsh/dup2.html>.  */
-extern int dup2 (int oldfd, int newfd);
+# if @REPLACE_DUP2@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define dup2 rpl_dup2
+#  endif
+_GL_FUNCDECL_RPL (dup2, int, (int oldfd, int newfd));
+_GL_CXXALIAS_RPL (dup2, int, (int oldfd, int newfd));
+# else
+#  if !@HAVE_DUP2@
+_GL_FUNCDECL_SYS (dup2, int, (int oldfd, int newfd));
+#  endif
+_GL_CXXALIAS_SYS (dup2, int, (int oldfd, int newfd));
 # endif
+_GL_CXXALIASWARN (dup2);
 #elif defined GNULIB_POSIXCHECK
 # undef dup2
-# define dup2(o,n) \
-    (GL_LINK_WARNING ("dup2 is unportable - " \
-                      "use gnulib module dup2 for portability"), \
-     dup2 (o, n))
+# if HAVE_RAW_DECL_DUP2
+_GL_WARN_ON_USE (dup2, "dup2 is unportable - "
+                 "use gnulib module dup2 for portability");
+# endif
+#endif
+
+
+#if @GNULIB_DUP3@
+/* Copy the file descriptor OLDFD into file descriptor NEWFD, with the
+   specified flags.
+   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)
+   and O_TEXT, O_BINARY (defined in "binary-io.h").
+   Close NEWFD first if it is open.
+   Return newfd if successful, otherwise -1 and errno set.
+   See the Linux man page at
+   <http://www.kernel.org/doc/man-pages/online/pages/man2/dup3.2.html>.  */
+# if @HAVE_DUP3@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define dup3 rpl_dup3
+#  endif
+_GL_FUNCDECL_RPL (dup3, int, (int oldfd, int newfd, int flags));
+_GL_CXXALIAS_RPL (dup3, int, (int oldfd, int newfd, int flags));
+# else
+_GL_FUNCDECL_SYS (dup3, int, (int oldfd, int newfd, int flags));
+_GL_CXXALIAS_SYS (dup3, int, (int oldfd, int newfd, int flags));
+# endif
+_GL_CXXALIASWARN (dup3);
+#elif defined GNULIB_POSIXCHECK
+# undef dup3
+# if HAVE_RAW_DECL_DUP3
+_GL_WARN_ON_USE (dup3, "dup3 is unportable - "
+                 "use gnulib module dup3 for portability");
+# endif
 #endif
 
 
@@ -175,55 +344,126 @@ extern int dup2 (int oldfd, int newfd);
 #   include <crt_externs.h>
 #   define environ (*_NSGetEnviron ())
 #  else
+#   ifdef __cplusplus
+extern "C" {
+#   endif
 extern char **environ;
+#   ifdef __cplusplus
+}
+#   endif
 #  endif
 # endif
 #elif defined GNULIB_POSIXCHECK
-# undef environ
-# define environ \
-    (GL_LINK_WARNING ("environ is unportable - " \
-                      "use gnulib module environ for portability"), \
-     environ)
+# if HAVE_RAW_DECL_ENVIRON
+static inline char ***
+rpl_environ (void)
+{
+  return &environ;
+}
+_GL_WARN_ON_USE (rpl_environ, "environ is unportable - "
+                 "use gnulib module environ for portability");
+#  undef environ
+#  define environ (*rpl_environ ())
+# endif
 #endif
 
 
 #if @GNULIB_EUIDACCESS@
-# if !@HAVE_EUIDACCESS@
-/* Like access(), except that is uses the effective user id and group id of
+/* Like access(), except that it uses the effective user id and group id of
    the current process.  */
-extern int euidaccess (const char *filename, int mode);
+# if !@HAVE_EUIDACCESS@
+_GL_FUNCDECL_SYS (euidaccess, int, (const char *filename, int mode)
+                                   _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (euidaccess, int, (const char *filename, int mode));
+_GL_CXXALIASWARN (euidaccess);
+# if defined GNULIB_POSIXCHECK
+/* Like access(), this function is a security risk.  */
+_GL_WARN_ON_USE (euidaccess, "the euidaccess function is a security risk - "
+                 "use the gnulib module faccessat instead");
 # endif
 #elif defined GNULIB_POSIXCHECK
 # undef euidaccess
-# define euidaccess(f,m) \
-    (GL_LINK_WARNING ("euidaccess is unportable - " \
-                      "use gnulib module euidaccess for portability"), \
-     euidaccess (f, m))
+# if HAVE_RAW_DECL_EUIDACCESS
+_GL_WARN_ON_USE (euidaccess, "euidaccess is unportable - "
+                 "use gnulib module euidaccess for portability");
+# endif
 #endif
 
 
-#if @GNULIB_FCHDIR@
-# if @REPLACE_FCHDIR@
+#if @GNULIB_FACCESSAT@
+# if !@HAVE_FACCESSAT@
+_GL_FUNCDECL_SYS (faccessat, int,
+                  (int fd, char const *file, int mode, int flag)
+                  _GL_ARG_NONNULL ((2)));
+# endif
+_GL_CXXALIAS_SYS (faccessat, int,
+                  (int fd, char const *file, int mode, int flag));
+_GL_CXXALIASWARN (faccessat);
+#elif defined GNULIB_POSIXCHECK
+# undef faccessat
+# if HAVE_RAW_DECL_FACCESSAT
+_GL_WARN_ON_USE (faccessat, "faccessat is not portable - "
+                 "use gnulib module faccessat for portability");
+# endif
+#endif
+
 
+#if @GNULIB_FCHDIR@
 /* Change the process' current working directory to the directory on which
    the given file descriptor is open.
    Return 0 if successful, otherwise -1 and errno set.
    See the POSIX:2001 specification
    <http://www.opengroup.org/susv3xsh/fchdir.html>.  */
-extern int fchdir (int /*fd*/);
+# if ! @HAVE_FCHDIR@
+_GL_FUNCDECL_SYS (fchdir, int, (int /*fd*/));
 
-#  define dup rpl_dup
-extern int dup (int);
-#  define dup2 rpl_dup2
-extern int dup2 (int, int);
+/* Gnulib internal hooks needed to maintain the fchdir metadata.  */
+_GL_EXTERN_C int _gl_register_fd (int fd, const char *filename)
+     _GL_ARG_NONNULL ((2));
+_GL_EXTERN_C void _gl_unregister_fd (int fd);
+_GL_EXTERN_C int _gl_register_dup (int oldfd, int newfd);
+_GL_EXTERN_C const char *_gl_directory_name (int fd);
 
 # endif
+_GL_CXXALIAS_SYS (fchdir, int, (int /*fd*/));
+_GL_CXXALIASWARN (fchdir);
 #elif defined GNULIB_POSIXCHECK
 # undef fchdir
-# define fchdir(f) \
-    (GL_LINK_WARNING ("fchdir is unportable - " \
-                      "use gnulib module fchdir for portability"), \
-     fchdir (f))
+# if HAVE_RAW_DECL_FCHDIR
+_GL_WARN_ON_USE (fchdir, "fchdir is unportable - "
+                 "use gnulib module fchdir for portability");
+# endif
+#endif
+
+
+#if @GNULIB_FCHOWNAT@
+# if @REPLACE_FCHOWNAT@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fchownat
+#   define fchownat rpl_fchownat
+#  endif
+_GL_FUNCDECL_RPL (fchownat, int, (int fd, char const *file,
+                                  uid_t owner, gid_t group, int flag)
+                                 _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (fchownat, int, (int fd, char const *file,
+                                  uid_t owner, gid_t group, int flag));
+# else
+#  if !@HAVE_FCHOWNAT@
+_GL_FUNCDECL_SYS (fchownat, int, (int fd, char const *file,
+                                  uid_t owner, gid_t group, int flag)
+                                 _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (fchownat, int, (int fd, char const *file,
+                                  uid_t owner, gid_t group, int flag));
+# endif
+_GL_CXXALIASWARN (fchownat);
+#elif defined GNULIB_POSIXCHECK
+# undef fchownat
+# if HAVE_RAW_DECL_FCHOWNAT
+_GL_WARN_ON_USE (fchownat, "fchownat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
 #endif
 
 
@@ -233,39 +473,39 @@ extern int dup2 (int, int);
    See POSIX:2001 specification
    <http://www.opengroup.org/susv3xsh/fsync.html>.  */
 # if !@HAVE_FSYNC@
-extern int fsync (int fd);
+_GL_FUNCDECL_SYS (fsync, int, (int fd));
 # endif
+_GL_CXXALIAS_SYS (fsync, int, (int fd));
+_GL_CXXALIASWARN (fsync);
 #elif defined GNULIB_POSIXCHECK
 # undef fsync
-# define fsync(fd) \
-    (GL_LINK_WARNING ("fsync is unportable - " \
-                      "use gnulib module fsync for portability"), \
-     fsync (fd))
+# if HAVE_RAW_DECL_FSYNC
+_GL_WARN_ON_USE (fsync, "fsync is unportable - "
+                 "use gnulib module fsync for portability");
+# endif
 #endif
 
 
 #if @GNULIB_FTRUNCATE@
-# if !@HAVE_FTRUNCATE@
 /* Change the size of the file to which FD is opened to become equal to LENGTH.
    Return 0 if successful, otherwise -1 and errno set.
    See the POSIX:2001 specification
    <http://www.opengroup.org/susv3xsh/ftruncate.html>.  */
-extern int ftruncate (int fd, off_t length);
+# if !@HAVE_FTRUNCATE@
+_GL_FUNCDECL_SYS (ftruncate, int, (int fd, off_t length));
 # endif
+_GL_CXXALIAS_SYS (ftruncate, int, (int fd, off_t length));
+_GL_CXXALIASWARN (ftruncate);
 #elif defined GNULIB_POSIXCHECK
 # undef ftruncate
-# define ftruncate(f,l) \
-    (GL_LINK_WARNING ("ftruncate is unportable - " \
-                      "use gnulib module ftruncate for portability"), \
-     ftruncate (f, l))
+# if HAVE_RAW_DECL_FTRUNCATE
+_GL_WARN_ON_USE (ftruncate, "ftruncate is unportable - "
+                 "use gnulib module ftruncate for portability");
+# endif
 #endif
 
 
 #if @GNULIB_GETCWD@
-/* Include the headers that might declare getcwd so that they will not
-   cause confusion if included after this file.  */
-# include <stdlib.h>
-# if @REPLACE_GETCWD@
 /* Get the name of the current working directory, and put it in SIZE bytes
    of BUF.
    Return BUF if successful, or NULL if the directory couldn't be determined
@@ -276,15 +516,24 @@ extern int ftruncate (int fd, off_t leng
    extension: If BUF is NULL, an array is allocated with 'malloc'; the array
    is SIZE bytes long, unless SIZE == 0, in which case it is as big as
    necessary.  */
-#  define getcwd rpl_getcwd
-extern char * getcwd (char *buf, size_t size);
+# if @REPLACE_GETCWD@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define getcwd rpl_getcwd
+#  endif
+_GL_FUNCDECL_RPL (getcwd, char *, (char *buf, size_t size));
+_GL_CXXALIAS_RPL (getcwd, char *, (char *buf, size_t size));
+# else
+/* Need to cast, because on mingw, the second parameter is
+                                                   int size.  */
+_GL_CXXALIAS_SYS_CAST (getcwd, char *, (char *buf, size_t size));
 # endif
+_GL_CXXALIASWARN (getcwd);
 #elif defined GNULIB_POSIXCHECK
 # undef getcwd
-# define getcwd(b,s) \
-    (GL_LINK_WARNING ("getcwd is unportable - " \
-                      "use gnulib module getcwd for portability"), \
-     getcwd (b, s))
+# if HAVE_RAW_DECL_GETCWD
+_GL_WARN_ON_USE (getcwd, "getcwd is unportable - "
+                 "use gnulib module getcwd for portability");
+# endif
 #endif
 
 
@@ -300,28 +549,65 @@ extern char * getcwd (char *buf, size_t
    If the NIS domain name is longer than LEN, set errno = EINVAL and return -1.
    Return 0 if successful, otherwise set errno and return -1.  */
 # if !@HAVE_GETDOMAINNAME@
-extern int getdomainname(char *name, size_t len);
+_GL_FUNCDECL_SYS (getdomainname, int, (char *name, size_t len)
+                                      _GL_ARG_NONNULL ((1)));
 # endif
+/* Need to cast, because on MacOS X 10.5 systems, the second parameter is
+                                                        int len.  */
+_GL_CXXALIAS_SYS_CAST (getdomainname, int, (char *name, size_t len));
+_GL_CXXALIASWARN (getdomainname);
 #elif defined GNULIB_POSIXCHECK
 # undef getdomainname
-# define getdomainname(n,l) \
-    (GL_LINK_WARNING ("getdomainname is unportable - " \
-                      "use gnulib module getdomainname for portability"), \
-     getdomainname (n, l))
+# if HAVE_RAW_DECL_GETDOMAINNAME
+_GL_WARN_ON_USE (getdomainname, "getdomainname is unportable - "
+                 "use gnulib module getdomainname for portability");
+# endif
 #endif
 
 
 #if @GNULIB_GETDTABLESIZE@
+/* Return the maximum number of file descriptors in the current process.
+   In POSIX, this is same as sysconf (_SC_OPEN_MAX).  */
 # if !@HAVE_GETDTABLESIZE@
-/* Return the maximum number of file descriptors in the current process.  */
-extern int getdtablesize (void);
+_GL_FUNCDECL_SYS (getdtablesize, int, (void));
 # endif
+_GL_CXXALIAS_SYS (getdtablesize, int, (void));
+_GL_CXXALIASWARN (getdtablesize);
 #elif defined GNULIB_POSIXCHECK
 # undef getdtablesize
-# define getdtablesize() \
-    (GL_LINK_WARNING ("getdtablesize is unportable - " \
-                      "use gnulib module getdtablesize for portability"), \
-     getdtablesize ())
+# if HAVE_RAW_DECL_GETDTABLESIZE
+_GL_WARN_ON_USE (getdtablesize, "getdtablesize is unportable - "
+                 "use gnulib module getdtablesize for portability");
+# endif
+#endif
+
+
+#if @GNULIB_GETGROUPS@
+/* Return the supplemental groups that the current process belongs to.
+   It is unspecified whether the effective group id is in the list.
+   If N is 0, return the group count; otherwise, N describes how many
+   entries are available in GROUPS.  Return -1 and set errno if N is
+   not 0 and not large enough.  Fails with ENOSYS on some systems.  */
+# if @REPLACE_GETGROUPS@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getgroups
+#   define getgroups rpl_getgroups
+#  endif
+_GL_FUNCDECL_RPL (getgroups, int, (int n, gid_t *groups));
+_GL_CXXALIAS_RPL (getgroups, int, (int n, gid_t *groups));
+# else
+#  if !@HAVE_GETGROUPS@
+_GL_FUNCDECL_SYS (getgroups, int, (int n, gid_t *groups));
+#  endif
+_GL_CXXALIAS_SYS (getgroups, int, (int n, gid_t *groups));
+# endif
+_GL_CXXALIASWARN (getgroups);
+#elif defined GNULIB_POSIXCHECK
+# undef getgroups
+# if HAVE_RAW_DECL_GETGROUPS
+_GL_WARN_ON_USE (getgroups, "getgroups is unportable - "
+                 "use gnulib module getgroups for portability");
+# endif
 #endif
 
 
@@ -334,21 +620,57 @@ extern int getdtablesize (void);
    If the host name is longer than LEN, set errno = EINVAL and return -1.
    Return 0 if successful, otherwise set errno and return -1.  */
 # if @UNISTD_H_HAVE_WINSOCK2_H@
-#  undef gethostname
-#  define gethostname rpl_gethostname
-# endif
-# if @UNISTD_H_HAVE_WINSOCK2_H@ || !@HAVE_GETHOSTNAME@
-extern int gethostname(char *name, size_t len);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef gethostname
+#   define gethostname rpl_gethostname
+#  endif
+_GL_FUNCDECL_RPL (gethostname, int, (char *name, size_t len)
+                                    _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (gethostname, int, (char *name, size_t len));
+# else
+#  if !@HAVE_GETHOSTNAME@
+_GL_FUNCDECL_SYS (gethostname, int, (char *name, size_t len)
+                                    _GL_ARG_NONNULL ((1)));
+#  endif
+/* Need to cast, because on Solaris 10 systems, the second parameter is
+                                                      int len.  */
+_GL_CXXALIAS_SYS_CAST (gethostname, int, (char *name, size_t len));
 # endif
+_GL_CXXALIASWARN (gethostname);
 #elif @UNISTD_H_HAVE_WINSOCK2_H@
 # undef gethostname
 # define gethostname gethostname_used_without_requesting_gnulib_module_gethostname
 #elif defined GNULIB_POSIXCHECK
 # undef gethostname
-# define gethostname(n,l) \
-    (GL_LINK_WARNING ("gethostname is unportable - " \
-                      "use gnulib module gethostname for portability"), \
-     gethostname (n, l))
+# if HAVE_RAW_DECL_GETHOSTNAME
+_GL_WARN_ON_USE (gethostname, "gethostname is unportable - "
+                 "use gnulib module gethostname for portability");
+# endif
+#endif
+
+
+#if @GNULIB_GETLOGIN@
+/* Returns the user's login name, or NULL if it cannot be found.  Upon error,
+   returns NULL with errno set.
+
+   See <http://www.opengroup.org/susv3xsh/getlogin.html>.
+
+   Most programs don't need to use this function, because the information is
+   available through environment variables:
+     ${LOGNAME-$USER}        on Unix platforms,
+     $USERNAME               on native Windows platforms.
+ */
+# if !@HAVE_GETLOGIN@
+_GL_FUNCDECL_SYS (getlogin, char *, (void));
+# endif
+_GL_CXXALIAS_SYS (getlogin, char *, (void));
+_GL_CXXALIASWARN (getlogin);
+#elif defined GNULIB_POSIXCHECK
+# undef getlogin
+# if HAVE_RAW_DECL_GETLOGIN
+_GL_WARN_ON_USE (getlogin, "getlogin is unportable - "
+                 "use gnulib module getlogin for portability");
+# endif
 #endif
 
 
@@ -361,124 +683,184 @@ extern int gethostname(char *name, size_
    provided (this case is hopefully rare but is left open by the POSIX spec).
 
    See <http://www.opengroup.org/susv3xsh/getlogin.html>.
+
+   Most programs don't need to use this function, because the information is
+   available through environment variables:
+     ${LOGNAME-$USER}        on Unix platforms,
+     $USERNAME               on native Windows platforms.
  */
 # if !@HAVE_DECL_GETLOGIN_R@
-#  include <stddef.h>
-extern int getlogin_r (char *name, size_t size);
+_GL_FUNCDECL_SYS (getlogin_r, int, (char *name, size_t size)
+                                   _GL_ARG_NONNULL ((1)));
 # endif
+/* Need to cast, because on Solaris 10 systems, the second argument is
+                                                     int size.  */
+_GL_CXXALIAS_SYS_CAST (getlogin_r, int, (char *name, size_t size));
+_GL_CXXALIASWARN (getlogin_r);
 #elif defined GNULIB_POSIXCHECK
 # undef getlogin_r
-# define getlogin_r(n,s) \
-    (GL_LINK_WARNING ("getlogin_r is unportable - " \
-                      "use gnulib module getlogin_r for portability"), \
-     getlogin_r (n, s))
+# if HAVE_RAW_DECL_GETLOGIN_R
+_GL_WARN_ON_USE (getlogin_r, "getlogin_r is unportable - "
+                 "use gnulib module getlogin_r for portability");
+# endif
 #endif
 
 
 #if @GNULIB_GETPAGESIZE@
 # if @REPLACE_GETPAGESIZE@
-#  define getpagesize rpl_getpagesize
-extern int getpagesize (void);
-# elif !@HAVE_GETPAGESIZE@
-/* This is for POSIX systems.  */
-#  if !defined getpagesize && defined _SC_PAGESIZE
-#   if ! (defined __VMS && __VMS_VER < 70000000)
-#    define getpagesize() sysconf (_SC_PAGESIZE)
-#   endif
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define getpagesize rpl_getpagesize
 #  endif
+_GL_FUNCDECL_RPL (getpagesize, int, (void));
+_GL_CXXALIAS_RPL (getpagesize, int, (void));
+# else
+#  if !@HAVE_GETPAGESIZE@
+#   if !defined getpagesize
+/* This is for POSIX systems.  */
+#    if !defined _gl_getpagesize && defined _SC_PAGESIZE
+#     if ! (defined __VMS && __VMS_VER < 70000000)
+#      define _gl_getpagesize() sysconf (_SC_PAGESIZE)
+#     endif
+#    endif
 /* This is for older VMS.  */
-#  if !defined getpagesize && defined __VMS
-#   ifdef __ALPHA
-#    define getpagesize() 8192
-#   else
-#    define getpagesize() 512
-#   endif
-#  endif
+#    if !defined _gl_getpagesize && defined __VMS
+#     ifdef __ALPHA
+#      define _gl_getpagesize() 8192
+#     else
+#      define _gl_getpagesize() 512
+#     endif
+#    endif
 /* This is for BeOS.  */
-#  if !defined getpagesize && @HAVE_OS_H@
-#   include <OS.h>
-#   if defined B_PAGE_SIZE
-#    define getpagesize() B_PAGE_SIZE
-#   endif
-#  endif
+#    if !defined _gl_getpagesize && @HAVE_OS_H@
+#     include <OS.h>
+#     if defined B_PAGE_SIZE
+#      define _gl_getpagesize() B_PAGE_SIZE
+#     endif
+#    endif
 /* This is for AmigaOS4.0.  */
-#  if !defined getpagesize && defined __amigaos4__
-#   define getpagesize() 2048
-#  endif
+#    if !defined _gl_getpagesize && defined __amigaos4__
+#     define _gl_getpagesize() 2048
+#    endif
 /* This is for older Unix systems.  */
-#  if !defined getpagesize && @HAVE_SYS_PARAM_H@
-#   include <sys/param.h>
-#   ifdef EXEC_PAGESIZE
-#    define getpagesize() EXEC_PAGESIZE
-#   else
-#    ifdef NBPG
-#     ifndef CLSIZE
-#      define CLSIZE 1
+#    if !defined _gl_getpagesize && @HAVE_SYS_PARAM_H@
+#     include <sys/param.h>
+#     ifdef EXEC_PAGESIZE
+#      define _gl_getpagesize() EXEC_PAGESIZE
+#     else
+#      ifdef NBPG
+#       ifndef CLSIZE
+#        define CLSIZE 1
+#       endif
+#       define _gl_getpagesize() (NBPG * CLSIZE)
+#      else
+#       ifdef NBPC
+#        define _gl_getpagesize() NBPC
+#       endif
+#      endif
 #     endif
-#     define getpagesize() (NBPG * CLSIZE)
+#    endif
+#    if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#     define getpagesize() _gl_getpagesize ()
 #    else
-#     ifdef NBPC
-#      define getpagesize() NBPC
-#     endif
+static inline int
+getpagesize ()
+{
+  return _gl_getpagesize ();
+}
 #    endif
 #   endif
 #  endif
+/* Need to cast, because on Cygwin 1.5.x systems, the return type is size_t.  */
+_GL_CXXALIAS_SYS_CAST (getpagesize, int, (void));
+# endif
+# if @HAVE_DECL_GETPAGESIZE@
+_GL_CXXALIASWARN (getpagesize);
 # endif
 #elif defined GNULIB_POSIXCHECK
 # undef getpagesize
-# define getpagesize() \
-    (GL_LINK_WARNING ("getpagesize is unportable - " \
-                      "use gnulib module getpagesize for portability"), \
-     getpagesize ())
+# if HAVE_RAW_DECL_GETPAGESIZE
+_GL_WARN_ON_USE (getpagesize, "getpagesize is unportable - "
+                 "use gnulib module getpagesize for portability");
+# endif
 #endif
 
 
 #if @GNULIB_GETUSERSHELL@
-# if !@HAVE_GETUSERSHELL@
 /* Return the next valid login shell on the system, or NULL when the end of
    the list has been reached.  */
-extern char *getusershell (void);
+# if !@HAVE_DECL_GETUSERSHELL@
+_GL_FUNCDECL_SYS (getusershell, char *, (void));
+# endif
+_GL_CXXALIAS_SYS (getusershell, char *, (void));
+_GL_CXXALIASWARN (getusershell);
+#elif defined GNULIB_POSIXCHECK
+# undef getusershell
+# if HAVE_RAW_DECL_GETUSERSHELL
+_GL_WARN_ON_USE (getusershell, "getusershell is unportable - "
+                 "use gnulib module getusershell for portability");
+# endif
+#endif
+
+#if @GNULIB_GETUSERSHELL@
 /* Rewind to pointer that is advanced at each getusershell() call.  */
-extern void setusershell (void);
+# if !@HAVE_DECL_GETUSERSHELL@
+_GL_FUNCDECL_SYS (setusershell, void, (void));
+# endif
+_GL_CXXALIAS_SYS (setusershell, void, (void));
+_GL_CXXALIASWARN (setusershell);
+#elif defined GNULIB_POSIXCHECK
+# undef setusershell
+# if HAVE_RAW_DECL_SETUSERSHELL
+_GL_WARN_ON_USE (setusershell, "setusershell is unportable - "
+                 "use gnulib module getusershell for portability");
+# endif
+#endif
+
+#if @GNULIB_GETUSERSHELL@
 /* Free the pointer that is advanced at each getusershell() call and
    associated resources.  */
-extern void endusershell (void);
+# if !@HAVE_DECL_GETUSERSHELL@
+_GL_FUNCDECL_SYS (endusershell, void, (void));
 # endif
+_GL_CXXALIAS_SYS (endusershell, void, (void));
+_GL_CXXALIASWARN (endusershell);
 #elif defined GNULIB_POSIXCHECK
-# undef getusershell
-# define getusershell() \
-    (GL_LINK_WARNING ("getusershell is unportable - " \
-                      "use gnulib module getusershell for portability"), \
-     getusershell ())
-# undef setusershell
-# define setusershell() \
-    (GL_LINK_WARNING ("setusershell is unportable - " \
-                      "use gnulib module getusershell for portability"), \
-     setusershell ())
 # undef endusershell
-# define endusershell() \
-    (GL_LINK_WARNING ("endusershell is unportable - " \
-                      "use gnulib module getusershell for portability"), \
-     endusershell ())
+# if HAVE_RAW_DECL_ENDUSERSHELL
+_GL_WARN_ON_USE (endusershell, "endusershell is unportable - "
+                 "use gnulib module getusershell for portability");
+# endif
 #endif
 
 
 #if @GNULIB_LCHOWN@
-# if @REPLACE_LCHOWN@
 /* Change the owner of FILE to UID (if UID is not -1) and the group of FILE
    to GID (if GID is not -1).  Do not follow symbolic links.
    Return 0 if successful, otherwise -1 and errno set.
    See the POSIX:2001 specification
    <http://www.opengroup.org/susv3xsh/lchown.html>.  */
-#  define lchown rpl_lchown
-extern int lchown (char const *file, uid_t owner, gid_t group);
+# if @REPLACE_LCHOWN@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef lchown
+#   define lchown rpl_lchown
+#  endif
+_GL_FUNCDECL_RPL (lchown, int, (char const *file, uid_t owner, gid_t group)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (lchown, int, (char const *file, uid_t owner, gid_t group));
+# else
+#  if !@HAVE_LCHOWN@
+_GL_FUNCDECL_SYS (lchown, int, (char const *file, uid_t owner, gid_t group)
+                               _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (lchown, int, (char const *file, uid_t owner, gid_t group));
 # endif
+_GL_CXXALIASWARN (lchown);
 #elif defined GNULIB_POSIXCHECK
 # undef lchown
-# define lchown(f,u,g) \
-    (GL_LINK_WARNING ("lchown is unportable to pre-POSIX.1-2001 " \
-                      "systems - use gnulib module lchown for portability"), \
-     lchown (f, u, g))
+# if HAVE_RAW_DECL_LCHOWN
+_GL_WARN_ON_USE (lchown, "lchown is unportable to pre-POSIX.1-2001 systems - "
+                 "use gnulib module lchown for portability");
+# endif
 #endif
 
 
@@ -487,33 +869,184 @@ extern int lchown (char const *file, uid
    Return 0 if successful, otherwise -1 and errno set.
    See POSIX:2001 specification
    <http://www.opengroup.org/susv3xsh/link.html>.  */
-# if !@HAVE_LINK@
-extern int link (const char *path1, const char *path2);
+# if @REPLACE_LINK@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define link rpl_link
+#  endif
+_GL_FUNCDECL_RPL (link, int, (const char *path1, const char *path2)
+                             _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (link, int, (const char *path1, const char *path2));
+# else
+#  if !@HAVE_LINK@
+_GL_FUNCDECL_SYS (link, int, (const char *path1, const char *path2)
+                             _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (link, int, (const char *path1, const char *path2));
 # endif
+_GL_CXXALIASWARN (link);
 #elif defined GNULIB_POSIXCHECK
 # undef link
-# define link(path1,path2) \
-    (GL_LINK_WARNING ("link is unportable - " \
-                      "use gnulib module link for portability"), \
-     link (path1, path2))
+# if HAVE_RAW_DECL_LINK
+_GL_WARN_ON_USE (link, "link is unportable - "
+                 "use gnulib module link for portability");
+# endif
+#endif
+
+
+#if @GNULIB_LINKAT@
+/* Create a new hard link for an existing file, relative to two
+   directories.  FLAG controls whether symlinks are followed.
+   Return 0 if successful, otherwise -1 and errno set.  */
+# if @REPLACE_LINKAT@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef linkat
+#   define linkat rpl_linkat
+#  endif
+_GL_FUNCDECL_RPL (linkat, int,
+                  (int fd1, const char *path1, int fd2, const char *path2,
+                   int flag)
+                  _GL_ARG_NONNULL ((2, 4)));
+_GL_CXXALIAS_RPL (linkat, int,
+                  (int fd1, const char *path1, int fd2, const char *path2,
+                   int flag));
+# else
+#  if !@HAVE_LINKAT@
+_GL_FUNCDECL_SYS (linkat, int,
+                  (int fd1, const char *path1, int fd2, const char *path2,
+                   int flag)
+                  _GL_ARG_NONNULL ((2, 4)));
+#  endif
+_GL_CXXALIAS_SYS (linkat, int,
+                  (int fd1, const char *path1, int fd2, const char *path2,
+                   int flag));
+# endif
+_GL_CXXALIASWARN (linkat);
+#elif defined GNULIB_POSIXCHECK
+# undef linkat
+# if HAVE_RAW_DECL_LINKAT
+_GL_WARN_ON_USE (linkat, "linkat is unportable - "
+                 "use gnulib module linkat for portability");
+# endif
 #endif
 
 
 #if @GNULIB_LSEEK@
-# if @REPLACE_LSEEK@
 /* Set the offset of FD relative to SEEK_SET, SEEK_CUR, or SEEK_END.
    Return the new offset if successful, otherwise -1 and errno set.
    See the POSIX:2001 specification
    <http://www.opengroup.org/susv3xsh/lseek.html>.  */
-#  define lseek rpl_lseek
-   extern off_t lseek (int fd, off_t offset, int whence);
+# if @REPLACE_LSEEK@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define lseek rpl_lseek
+#  endif
+_GL_FUNCDECL_RPL (lseek, off_t, (int fd, off_t offset, int whence));
+_GL_CXXALIAS_RPL (lseek, off_t, (int fd, off_t offset, int whence));
+# else
+_GL_CXXALIAS_SYS (lseek, off_t, (int fd, off_t offset, int whence));
 # endif
+_GL_CXXALIASWARN (lseek);
 #elif defined GNULIB_POSIXCHECK
 # undef lseek
-# define lseek(f,o,w) \
-    (GL_LINK_WARNING ("lseek does not fail with ESPIPE on pipes on some " \
-                      "systems - use gnulib module lseek for portability"), \
-     lseek (f, o, w))
+# if HAVE_RAW_DECL_LSEEK
+_GL_WARN_ON_USE (lseek, "lseek does not fail with ESPIPE on pipes on some "
+                 "systems - use gnulib module lseek for portability");
+# endif
+#endif
+
+
+#if @GNULIB_PIPE2@
+/* Create a pipe, applying the given flags when opening the read-end of the
+   pipe and the write-end of the pipe.
+   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)
+   and O_TEXT, O_BINARY (defined in "binary-io.h").
+   Store the read-end as fd[0] and the write-end as fd[1].
+   Return 0 upon success, or -1 with errno set upon failure.
+   See also the Linux man page at
+   <http://www.kernel.org/doc/man-pages/online/pages/man2/pipe2.2.html>.  */
+# if @HAVE_PIPE2@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define pipe2 rpl_pipe2
+#  endif
+_GL_FUNCDECL_RPL (pipe2, int, (int fd[2], int flags) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (pipe2, int, (int fd[2], int flags));
+# else
+_GL_FUNCDECL_SYS (pipe2, int, (int fd[2], int flags) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (pipe2, int, (int fd[2], int flags));
+# endif
+_GL_CXXALIASWARN (pipe2);
+#elif defined GNULIB_POSIXCHECK
+# undef pipe2
+# if HAVE_RAW_DECL_PIPE2
+_GL_WARN_ON_USE (pipe2, "pipe2 is unportable - "
+                 "use gnulib module pipe2 for portability");
+# endif
+#endif
+
+
+#if @GNULIB_PREAD@
+/* Read at most BUFSIZE bytes from FD into BUF, starting at OFFSET.
+   Return the number of bytes placed into BUF if successful, otherwise
+   set errno and return -1.  0 indicates EOF.  See the POSIX:2001
+   specification <http://www.opengroup.org/susv3xsh/pread.html>.  */
+# if @REPLACE_PREAD@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define pread rpl_pread
+#  endif
+_GL_FUNCDECL_RPL (pread, ssize_t,
+                  (int fd, void *buf, size_t bufsize, off_t offset)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (pread, ssize_t,
+                  (int fd, void *buf, size_t bufsize, off_t offset));
+# else
+#  if !@HAVE_PREAD@
+_GL_FUNCDECL_SYS (pread, ssize_t,
+                  (int fd, void *buf, size_t bufsize, off_t offset)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (pread, ssize_t,
+                  (int fd, void *buf, size_t bufsize, off_t offset));
+# endif
+_GL_CXXALIASWARN (pread);
+#elif defined GNULIB_POSIXCHECK
+# undef pread
+# if HAVE_RAW_DECL_PREAD
+_GL_WARN_ON_USE (pread, "pread is unportable - "
+                 "use gnulib module pread for portability");
+# endif
+#endif
+
+
+#if @GNULIB_PWRITE@
+/* Write at most BUFSIZE bytes from BUF into FD, starting at OFFSET.
+   Return the number of bytes written if successful, otherwise
+   set errno and return -1.  0 indicates nothing written.  See the
+   POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/pwrite.html>.  */
+# if @REPLACE_PWRITE@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define pwrite rpl_pwrite
+#  endif
+_GL_FUNCDECL_RPL (pwrite, ssize_t,
+                  (int fd, const void *buf, size_t bufsize, off_t offset)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (pwrite, ssize_t,
+                  (int fd, const void *buf, size_t bufsize, off_t offset));
+# else
+#  if !@HAVE_PWRITE@
+_GL_FUNCDECL_SYS (pwrite, ssize_t,
+                  (int fd, const void *buf, size_t bufsize, off_t offset)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (pwrite, ssize_t,
+                  (int fd, const void *buf, size_t bufsize, off_t offset));
+# endif
+_GL_CXXALIASWARN (pwrite);
+#elif defined GNULIB_POSIXCHECK
+# undef pwrite
+# if HAVE_RAW_DECL_PWRITE
+_GL_WARN_ON_USE (pwrite, "pwrite is unportable - "
+                 "use gnulib module pwrite for portability");
+# endif
 #endif
 
 
@@ -523,16 +1056,70 @@ extern int link (const char *path1, cons
    successful, otherwise -1 and errno set.
    See the POSIX:2001 specification
    <http://www.opengroup.org/susv3xsh/readlink.html>.  */
-# if !@HAVE_READLINK@
-#  include <stddef.h>
-extern int readlink (const char *file, char *buf, size_t bufsize);
+# if @REPLACE_READLINK@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define readlink rpl_readlink
+#  endif
+_GL_FUNCDECL_RPL (readlink, ssize_t,
+                  (const char *file, char *buf, size_t bufsize)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (readlink, ssize_t,
+                  (const char *file, char *buf, size_t bufsize));
+# else
+#  if !@HAVE_READLINK@
+_GL_FUNCDECL_SYS (readlink, ssize_t,
+                  (const char *file, char *buf, size_t bufsize)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (readlink, ssize_t,
+                  (const char *file, char *buf, size_t bufsize));
 # endif
+_GL_CXXALIASWARN (readlink);
 #elif defined GNULIB_POSIXCHECK
 # undef readlink
-# define readlink(f,b,s) \
-    (GL_LINK_WARNING ("readlink is unportable - " \
-                      "use gnulib module readlink for portability"), \
-     readlink (f, b, s))
+# if HAVE_RAW_DECL_READLINK
+_GL_WARN_ON_USE (readlink, "readlink is unportable - "
+                 "use gnulib module readlink for portability");
+# endif
+#endif
+
+
+#if @GNULIB_READLINKAT@
+# if !@HAVE_READLINKAT@
+_GL_FUNCDECL_SYS (readlinkat, ssize_t,
+                  (int fd, char const *file, char *buf, size_t len)
+                  _GL_ARG_NONNULL ((2, 3)));
+# endif
+_GL_CXXALIAS_SYS (readlinkat, ssize_t,
+                  (int fd, char const *file, char *buf, size_t len));
+_GL_CXXALIASWARN (readlinkat);
+#elif defined GNULIB_POSIXCHECK
+# undef readlinkat
+# if HAVE_RAW_DECL_READLINKAT
+_GL_WARN_ON_USE (readlinkat, "readlinkat is not portable - "
+                 "use gnulib module symlinkat for portability");
+# endif
+#endif
+
+
+#if @GNULIB_RMDIR@
+/* Remove the directory DIR.  */
+# if @REPLACE_RMDIR@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define rmdir rpl_rmdir
+#  endif
+_GL_FUNCDECL_RPL (rmdir, int, (char const *name) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (rmdir, int, (char const *name));
+# else
+_GL_CXXALIAS_SYS (rmdir, int, (char const *name));
+# endif
+_GL_CXXALIASWARN (rmdir);
+#elif defined GNULIB_POSIXCHECK
+# undef rmdir
+# if HAVE_RAW_DECL_RMDIR
+_GL_WARN_ON_USE (rmdir, "rmdir is unportable - "
+                 "use gnulib module rmdir for portability");
+# endif
 #endif
 
 
@@ -541,36 +1128,197 @@ extern int readlink (const char *file, c
    Returns the number of seconds left to sleep.
    See the POSIX:2001 specification
    <http://www.opengroup.org/susv3xsh/sleep.html>.  */
-# if !@HAVE_SLEEP@
-extern unsigned int sleep (unsigned int n);
+# if @REPLACE_SLEEP@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef sleep
+#   define sleep rpl_sleep
+#  endif
+_GL_FUNCDECL_RPL (sleep, unsigned int, (unsigned int n));
+_GL_CXXALIAS_RPL (sleep, unsigned int, (unsigned int n));
+# else
+#  if !@HAVE_SLEEP@
+_GL_FUNCDECL_SYS (sleep, unsigned int, (unsigned int n));
+#  endif
+_GL_CXXALIAS_SYS (sleep, unsigned int, (unsigned int n));
 # endif
+_GL_CXXALIASWARN (sleep);
 #elif defined GNULIB_POSIXCHECK
 # undef sleep
-# define sleep(n) \
-    (GL_LINK_WARNING ("sleep is unportable - " \
-                      "use gnulib module sleep for portability"), \
-     sleep (n))
+# if HAVE_RAW_DECL_SLEEP
+_GL_WARN_ON_USE (sleep, "sleep is unportable - "
+                 "use gnulib module sleep for portability");
+# endif
 #endif
 
 
-#if @GNULIB_WRITE@ && @REPLACE_WRITE@ && @GNULIB_UNISTD_H_SIGPIPE@
-/* Write up to COUNT bytes starting at BUF to file descriptor FD.
-   See the POSIX:2001 specification
-   <http://www.opengroup.org/susv3xsh/write.html>.  */
-# undef write
-# define write rpl_write
-extern ssize_t write (int fd, const void *buf, size_t count);
+#if @GNULIB_SYMLINK@
+# if @REPLACE_SYMLINK@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef symlink
+#   define symlink rpl_symlink
+#  endif
+_GL_FUNCDECL_RPL (symlink, int, (char const *contents, char const *file)
+                                _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (symlink, int, (char const *contents, char const *file));
+# else
+#  if !@HAVE_SYMLINK@
+_GL_FUNCDECL_SYS (symlink, int, (char const *contents, char const *file)
+                                _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (symlink, int, (char const *contents, char const *file));
+# endif
+_GL_CXXALIASWARN (symlink);
+#elif defined GNULIB_POSIXCHECK
+# undef symlink
+# if HAVE_RAW_DECL_SYMLINK
+_GL_WARN_ON_USE (symlink, "symlink is not portable - "
+                 "use gnulib module symlink for portability");
+# endif
 #endif
 
 
-#ifdef FCHDIR_REPLACEMENT
-/* gnulib internal function.  */
-extern void _gl_unregister_fd (int fd);
+#if @GNULIB_SYMLINKAT@
+# if !@HAVE_SYMLINKAT@
+_GL_FUNCDECL_SYS (symlinkat, int,
+                  (char const *contents, int fd, char const *file)
+                  _GL_ARG_NONNULL ((1, 3)));
+# endif
+_GL_CXXALIAS_SYS (symlinkat, int,
+                  (char const *contents, int fd, char const *file));
+_GL_CXXALIASWARN (symlinkat);
+#elif defined GNULIB_POSIXCHECK
+# undef symlinkat
+# if HAVE_RAW_DECL_SYMLINKAT
+_GL_WARN_ON_USE (symlinkat, "symlinkat is not portable - "
+                 "use gnulib module symlinkat for portability");
+# endif
 #endif
 
 
-#ifdef __cplusplus
-}
+#if @GNULIB_TTYNAME_R@
+/* Store at most BUFLEN characters of the pathname of the terminal FD is
+   open on in BUF.  Return 0 on success, otherwise an error number.  */
+# if @REPLACE_TTYNAME_R@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef ttyname_r
+#   define ttyname_r rpl_ttyname_r
+#  endif
+_GL_FUNCDECL_RPL (ttyname_r, int,
+                  (int fd, char *buf, size_t buflen) _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (ttyname_r, int,
+                  (int fd, char *buf, size_t buflen));
+# else
+#  if !@HAVE_TTYNAME_R@
+_GL_FUNCDECL_SYS (ttyname_r, int,
+                  (int fd, char *buf, size_t buflen) _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (ttyname_r, int,
+                  (int fd, char *buf, size_t buflen));
+# endif
+_GL_CXXALIASWARN (ttyname_r);
+#elif defined GNULIB_POSIXCHECK
+# undef ttyname_r
+# if HAVE_RAW_DECL_TTYNAME_R
+_GL_WARN_ON_USE (ttyname_r, "ttyname_r is not portable - "
+                 "use gnulib module ttyname_r for portability");
+# endif
+#endif
+
+
+#if @GNULIB_UNLINK@
+# if @REPLACE_UNLINK@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef unlink
+#   define unlink rpl_unlink
+#  endif
+_GL_FUNCDECL_RPL (unlink, int, (char const *file) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (unlink, int, (char const *file));
+# else
+_GL_CXXALIAS_SYS (unlink, int, (char const *file));
+# endif
+_GL_CXXALIASWARN (unlink);
+#elif defined GNULIB_POSIXCHECK
+# undef unlink
+# if HAVE_RAW_DECL_UNLINK
+_GL_WARN_ON_USE (unlink, "unlink is not portable - "
+                 "use gnulib module unlink for portability");
+# endif
+#endif
+
+
+#if @GNULIB_UNLINKAT@
+# if @REPLACE_UNLINKAT@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef unlinkat
+#   define unlinkat rpl_unlinkat
+#  endif
+_GL_FUNCDECL_RPL (unlinkat, int, (int fd, char const *file, int flag)
+                                 _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (unlinkat, int, (int fd, char const *file, int flag));
+# else
+#  if !@HAVE_UNLINKAT@
+_GL_FUNCDECL_SYS (unlinkat, int, (int fd, char const *file, int flag)
+                                 _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (unlinkat, int, (int fd, char const *file, int flag));
+# endif
+_GL_CXXALIASWARN (unlinkat);
+#elif defined GNULIB_POSIXCHECK
+# undef unlinkat
+# if HAVE_RAW_DECL_UNLINKAT
+_GL_WARN_ON_USE (unlinkat, "unlinkat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+#if @GNULIB_USLEEP@
+/* Pause the execution of the current thread for N microseconds.
+   Returns 0 on completion, or -1 on range error.
+   See the POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/sleep.html>.  */
+# if @REPLACE_USLEEP@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef usleep
+#   define usleep rpl_usleep
+#  endif
+_GL_FUNCDECL_RPL (usleep, int, (useconds_t n));
+_GL_CXXALIAS_RPL (usleep, int, (useconds_t n));
+# else
+#  if !@HAVE_USLEEP@
+_GL_FUNCDECL_SYS (usleep, int, (useconds_t n));
+#  endif
+_GL_CXXALIAS_SYS (usleep, int, (useconds_t n));
+# endif
+_GL_CXXALIASWARN (usleep);
+#elif defined GNULIB_POSIXCHECK
+# undef usleep
+# if HAVE_RAW_DECL_USLEEP
+_GL_WARN_ON_USE (usleep, "usleep is unportable - "
+                 "use gnulib module usleep for portability");
+# endif
+#endif
+
+
+#if @GNULIB_WRITE@
+/* Write up to COUNT bytes starting at BUF to file descriptor FD.
+   See the POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/write.html>.  */
+# if @REPLACE_WRITE@ && @GNULIB_UNISTD_H_SIGPIPE@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef write
+#   define write rpl_write
+#  endif
+_GL_FUNCDECL_RPL (write, ssize_t, (int fd, const void *buf, size_t count)
+                                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (write, ssize_t, (int fd, const void *buf, size_t count));
+# else
+/* Need to cast, because on mingw, the third parameter is
+                                                             unsigned int count
+   and the return type is 'int'.  */
+_GL_CXXALIAS_SYS_CAST (write, ssize_t, (int fd, const void *buf, size_t count));
+# endif
+_GL_CXXALIASWARN (write);
 #endif
 
 
--- a/gl/version-etc.c
+++ b/gl/version-etc.c
@@ -1,5 +1,5 @@
 /* Print --version and bug-reporting information in a consistent format.
-   Copyright (C) 1999-2009 Free Software Foundation, Inc.
+   Copyright (C) 1999-2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -32,28 +32,38 @@
 #include "gettext.h"
 #define _(msgid) gettext (msgid)
 
-enum { COPYRIGHT_YEAR = 2009 };
+/* If you use AM_INIT_AUTOMAKE's no-define option,
+   PACKAGE is not defined.  Use PACKAGE_TARNAME instead.  */
+#if ! defined PACKAGE && defined PACKAGE_TARNAME
+# define PACKAGE PACKAGE_TARNAME
+#endif
 
-/* Like version_etc, below, but with the NULL-terminated author list
-   provided via a variable of type va_list.  */
-void
-version_etc_va (FILE *stream,
-		const char *command_name, const char *package,
-		const char *version, va_list authors)
-{
-  size_t n_authors;
+enum { COPYRIGHT_YEAR = 2010 };
+
+/* The three functions below display the --version information the
+   standard way.
+
+   If COMMAND_NAME is NULL, the PACKAGE is assumed to be the name of
+   the program.  The formats are therefore:
+
+   PACKAGE VERSION
+
+   or
+
+   COMMAND_NAME (PACKAGE) VERSION.
 
-  /* Count the number of authors.  */
-  {
-    va_list tmp_authors;
-
-    va_copy (tmp_authors, authors);
-
-    n_authors = 0;
-    while (va_arg (tmp_authors, const char *) != NULL)
-      ++n_authors;
-  }
+   The functions differ in the way they are passed author names. */
 
+/* Display the --version information the standard way.
+
+   Author names are given in the array AUTHORS. N_AUTHORS is the
+   number of elements in the array. */
+void
+version_etc_arn (FILE *stream,
+                 const char *command_name, const char *package,
+                 const char *version,
+                 const char * const * authors, size_t n_authors)
+{
   if (command_name)
     fprintf (stream, "%s (%s) %s\n", command_name, package, version);
   else
@@ -62,7 +72,7 @@ version_etc_va (FILE *stream,
 #ifdef PACKAGE_PACKAGER
 # ifdef PACKAGE_PACKAGER_VERSION
   fprintf (stream, _("Packaged by %s (%s)\n"), PACKAGE_PACKAGER,
-	   PACKAGE_PACKAGER_VERSION);
+           PACKAGE_PACKAGER_VERSION);
 # else
   fprintf (stream, _("Packaged by %s\n"), PACKAGE_PACKAGER);
 # endif
@@ -80,7 +90,7 @@ This is free software: you are free to c
 There is NO WARRANTY, to the extent permitted by law.\n\
 \n\
 "),
-	 stream);
+         stream);
 
   switch (n_authors)
     {
@@ -89,76 +99,120 @@ There is NO WARRANTY, to the extent perm
       abort ();
     case 1:
       /* TRANSLATORS: %s denotes an author name.  */
-      vfprintf (stream, _("Written by %s.\n"), authors);
+      fprintf (stream, _("Written by %s.\n"), authors[0]);
       break;
     case 2:
       /* TRANSLATORS: Each %s denotes an author name.  */
-      vfprintf (stream, _("Written by %s and %s.\n"), authors);
+      fprintf (stream, _("Written by %s and %s.\n"), authors[0], authors[1]);
       break;
     case 3:
       /* TRANSLATORS: Each %s denotes an author name.  */
-      vfprintf (stream, _("Written by %s, %s, and %s.\n"), authors);
+      fprintf (stream, _("Written by %s, %s, and %s.\n"),
+               authors[0], authors[1], authors[2]);
       break;
     case 4:
       /* TRANSLATORS: Each %s denotes an author name.
-	 You can use line breaks, estimating that each author name occupies
-	 ca. 16 screen columns and that a screen line has ca. 80 columns.  */
-      vfprintf (stream, _("Written by %s, %s, %s,\nand %s.\n"), authors);
+         You can use line breaks, estimating that each author name occupies
+         ca. 16 screen columns and that a screen line has ca. 80 columns.  */
+      fprintf (stream, _("Written by %s, %s, %s,\nand %s.\n"),
+               authors[0], authors[1], authors[2], authors[3]);
       break;
     case 5:
       /* TRANSLATORS: Each %s denotes an author name.
-	 You can use line breaks, estimating that each author name occupies
-	 ca. 16 screen columns and that a screen line has ca. 80 columns.  */
-      vfprintf (stream, _("Written by %s, %s, %s,\n%s, and %s.\n"), authors);
+         You can use line breaks, estimating that each author name occupies
+         ca. 16 screen columns and that a screen line has ca. 80 columns.  */
+      fprintf (stream, _("Written by %s, %s, %s,\n%s, and %s.\n"),
+               authors[0], authors[1], authors[2], authors[3], authors[4]);
       break;
     case 6:
       /* TRANSLATORS: Each %s denotes an author name.
-	 You can use line breaks, estimating that each author name occupies
-	 ca. 16 screen columns and that a screen line has ca. 80 columns.  */
-      vfprintf (stream, _("Written by %s, %s, %s,\n%s, %s, and %s.\n"),
-		authors);
+         You can use line breaks, estimating that each author name occupies
+         ca. 16 screen columns and that a screen line has ca. 80 columns.  */
+      fprintf (stream, _("Written by %s, %s, %s,\n%s, %s, and %s.\n"),
+               authors[0], authors[1], authors[2], authors[3], authors[4],
+               authors[5]);
       break;
     case 7:
       /* TRANSLATORS: Each %s denotes an author name.
-	 You can use line breaks, estimating that each author name occupies
-	 ca. 16 screen columns and that a screen line has ca. 80 columns.  */
-      vfprintf (stream, _("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n"),
-		authors);
+         You can use line breaks, estimating that each author name occupies
+         ca. 16 screen columns and that a screen line has ca. 80 columns.  */
+      fprintf (stream, _("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n"),
+               authors[0], authors[1], authors[2], authors[3], authors[4],
+               authors[5], authors[6]);
       break;
     case 8:
       /* TRANSLATORS: Each %s denotes an author name.
-	 You can use line breaks, estimating that each author name occupies
-	 ca. 16 screen columns and that a screen line has ca. 80 columns.  */
-      vfprintf (stream, _("\
+         You can use line breaks, estimating that each author name occupies
+         ca. 16 screen columns and that a screen line has ca. 80 columns.  */
+      fprintf (stream, _("\
 Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n"),
-		authors);
+                authors[0], authors[1], authors[2], authors[3], authors[4],
+                authors[5], authors[6], authors[7]);
       break;
     case 9:
       /* TRANSLATORS: Each %s denotes an author name.
-	 You can use line breaks, estimating that each author name occupies
-	 ca. 16 screen columns and that a screen line has ca. 80 columns.  */
-      vfprintf (stream, _("\
+         You can use line breaks, estimating that each author name occupies
+         ca. 16 screen columns and that a screen line has ca. 80 columns.  */
+      fprintf (stream, _("\
 Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n"),
-		authors);
+               authors[0], authors[1], authors[2], authors[3], authors[4],
+               authors[5], authors[6], authors[7], authors[8]);
       break;
     default:
       /* 10 or more authors.  Use an abbreviation, since the human reader
-	 will probably not want to read the entire list anyway.  */
+         will probably not want to read the entire list anyway.  */
       /* TRANSLATORS: Each %s denotes an author name.
-	 You can use line breaks, estimating that each author name occupies
-	 ca. 16 screen columns and that a screen line has ca. 80 columns.  */
-      vfprintf (stream, _("\
+         You can use line breaks, estimating that each author name occupies
+         ca. 16 screen columns and that a screen line has ca. 80 columns.  */
+      fprintf (stream, _("\
 Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n"),
-		authors);
+                authors[0], authors[1], authors[2], authors[3], authors[4],
+                authors[5], authors[6], authors[7], authors[8]);
       break;
     }
-  va_end (authors);
+}
+
+/* Display the --version information the standard way.  See the initial
+   comment to this module, for more information.
+
+   Author names are given in the NULL-terminated array AUTHORS. */
+void
+version_etc_ar (FILE *stream,
+                const char *command_name, const char *package,
+                const char *version, const char * const * authors)
+{
+  size_t n_authors;
+
+  for (n_authors = 0; authors[n_authors]; n_authors++)
+    ;
+  version_etc_arn (stream, command_name, package, version, authors, n_authors);
+}
+
+/* Display the --version information the standard way.  See the initial
+   comment to this module, for more information.
+
+   Author names are given in the NULL-terminated va_list AUTHORS. */
+void
+version_etc_va (FILE *stream,
+                const char *command_name, const char *package,
+                const char *version, va_list authors)
+{
+  size_t n_authors;
+  const char *authtab[10];
+
+  for (n_authors = 0;
+       n_authors < 10
+         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;
+       n_authors++)
+    ;
+  version_etc_arn (stream, command_name, package, version,
+                   authtab, n_authors);
 }
 
 
 /* Display the --version information the standard way.
 
-   If COMMAND_NAME is NULL, the PACKAGE is asumed to be the name of
+   If COMMAND_NAME is NULL, the PACKAGE is assumed to be the name of
    the program.  The formats are therefore:
 
    PACKAGE VERSION
@@ -167,17 +221,18 @@ Written by %s, %s, %s,\n%s, %s, %s, %s,\
 
    COMMAND_NAME (PACKAGE) VERSION.
 
-   The author names are passed as separate arguments, with an additional
+   The authors names are passed as separate arguments, with an additional
    NULL argument at the end.  */
 void
 version_etc (FILE *stream,
-	     const char *command_name, const char *package,
-	     const char *version, /* const char *author1, ...*/ ...)
+             const char *command_name, const char *package,
+             const char *version, /* const char *author1, ...*/ ...)
 {
   va_list authors;
 
   va_start (authors, version);
   version_etc_va (stream, command_name, package, version, authors);
+  va_end (authors);
 }
 
 void
@@ -187,13 +242,17 @@ emit_bug_reporting_address (void)
      for this package.  Please add _another line_ saying
      "Report translation bugs to <...>\n" with the address for translation
      bugs (typically your translation team's web or email address).  */
-  printf (_("\nReport bugs to <%s>.\n"), PACKAGE_BUGREPORT);
+  printf (_("\nReport bugs to: %s\n"), PACKAGE_BUGREPORT);
 #ifdef PACKAGE_PACKAGER_BUG_REPORTS
-  printf (_("Report %s bugs to <%s>.\n"), PACKAGE_PACKAGER,
-	  PACKAGE_PACKAGER_BUG_REPORTS);
+  printf (_("Report %s bugs to: %s\n"), PACKAGE_PACKAGER,
+          PACKAGE_PACKAGER_BUG_REPORTS);
+#endif
+#ifdef PACKAGE_URL
+  printf (_("%s home page: <%s>\n"), PACKAGE_NAME, PACKAGE_URL);
+#else
+  printf (_("%s home page: <http://www.gnu.org/software/%s/>\n"),
+          PACKAGE_NAME, PACKAGE);
 #endif
-  printf (_("%s home page: <http://www.gnu.org/software/%s/>.\n"),
-	  PACKAGE_NAME, PACKAGE);
-  fputs (_("General help using GNU software: <http://www.gnu.org/gethelp/>.\n"),
+  fputs (_("General help using GNU software: <http://www.gnu.org/gethelp/>\n"),
          stdout);
 }
--- a/gl/version-etc.h
+++ b/gl/version-etc.h
@@ -1,5 +1,5 @@
 /* Print --version and bug-reporting information in a consistent format.
-   Copyright (C) 1999, 2003, 2005, 2009 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2003, 2005, 2009-2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -22,17 +22,57 @@
 # include <stdarg.h>
 # include <stdio.h>
 
+/* The `sentinel' attribute was added in gcc 4.0.  */
+#ifndef ATTRIBUTE_SENTINEL
+# if 4 <= __GNUC__
+#  define ATTRIBUTE_SENTINEL __attribute__ ((__sentinel__))
+# else
+#  define ATTRIBUTE_SENTINEL /* empty */
+# endif
+#endif
+
 extern const char version_etc_copyright[];
 
+/* The three functions below display the --version information in the
+   standard way: command and package names, package version, followed
+   by a short GPLv3+ notice and a list of up to 10 author names.
+
+   If COMMAND_NAME is NULL, the PACKAGE is asumed to be the name of
+   the program.  The formats are therefore:
+
+   PACKAGE VERSION
+
+   or
+
+   COMMAND_NAME (PACKAGE) VERSION.
+
+   The functions differ in the way they are passed author names: */
+
+/* N_AUTHORS names are supplied in array AUTHORS.  */
+extern void version_etc_arn (FILE *stream,
+                             const char *command_name, const char *package,
+                             const char *version,
+                             const char * const * authors, size_t n_authors);
+
+/* Names are passed in the NULL-terminated array AUTHORS.  */
+extern void version_etc_ar (FILE *stream,
+                            const char *command_name, const char *package,
+                            const char *version, const char * const * authors);
+
+/* Names are passed in the NULL-terminated va_list.  */
 extern void version_etc_va (FILE *stream,
-			    const char *command_name, const char *package,
-			    const char *version, va_list authors);
+                            const char *command_name, const char *package,
+                            const char *version, va_list authors);
 
+/* Names are passed as separate arguments, with an additional
+   NULL argument at the end.  */
 extern void version_etc (FILE *stream,
-			 const char *command_name, const char *package,
-			 const char *version,
-			 /* const char *author1, ...*/ ...);
+                         const char *command_name, const char *package,
+                         const char *version,
+                         /* const char *author1, ..., NULL */ ...)
+  ATTRIBUTE_SENTINEL;
 
+/* Display the usual `Report bugs to' stanza */
 extern void emit_bug_reporting_address (void);
 
 #endif /* VERSION_ETC_H */
--- a/gltests/Makefile.am
+++ b/gltests/Makefile.am
@@ -1,6 +1,6 @@
 ## DO NOT EDIT! GENERATED AUTOMATICALLY!
 ## Process this file with automake to produce Makefile.in.
-# Copyright (C) 2002-2009 Free Software Foundation, Inc.
+# Copyright (C) 2002-2010 Free Software Foundation, Inc.
 #
 # This file is free software, distributed under the terms of the GNU
 # General Public License.  As a special exception to the GNU General
@@ -12,13 +12,15 @@
 
 AUTOMAKE_OPTIONS = 1.5 foreign
 
-SUBDIRS =
+SUBDIRS = .
 TESTS =
+XFAIL_TESTS =
 TESTS_ENVIRONMENT =
 noinst_PROGRAMS =
 check_PROGRAMS =
 noinst_HEADERS =
 noinst_LIBRARIES =
+check_LIBRARIES = libtests.a
 EXTRA_DIST =
 BUILT_SOURCES =
 SUFFIXES =
@@ -29,11 +31,136 @@ DISTCLEANFILES =
 MAINTAINERCLEANFILES =
 
 AM_CPPFLAGS = \
+  -D@gltests_WITNESS@=1 \
   -I. -I$(srcdir) \
   -I.. -I$(srcdir)/.. \
   -I../gl -I$(srcdir)/../gl
 
-LDADD = ../gl/libgnu.la
+LDADD = libtests.a ../gl/libgnu.la libtests.a $(LIBTESTS_LIBDEPS)
+
+libtests_a_SOURCES =
+libtests_a_LIBADD = $(gltests_LIBOBJS)
+libtests_a_DEPENDENCIES = $(gltests_LIBOBJS)
+EXTRA_libtests_a_SOURCES =
+AM_LIBTOOLFLAGS = --preserve-dup-deps
+
+TESTS_ENVIRONMENT += EXEEXT='@EXEEXT@' srcdir='$(srcdir)'
+
+## begin gnulib module alloca-opt
+
+BUILT_SOURCES += $(ALLOCA_H)
+
+# We need the following in order to create <alloca.h> when the system
+# doesn't have one that works with the given compiler.
+alloca.h: alloca.in.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  cat $(srcdir)/alloca.in.h; \
+	} > $@-t && \
+	mv -f $@-t $@
+MOSTLYCLEANFILES += alloca.h alloca.h-t
+
+EXTRA_DIST += alloca.in.h
+
+## end   gnulib module alloca-opt
+
+## begin gnulib module alloca-opt-tests
+
+TESTS += test-alloca-opt
+check_PROGRAMS += test-alloca-opt
+
+EXTRA_DIST += test-alloca-opt.c
+
+## end   gnulib module alloca-opt-tests
+
+## begin gnulib module arg-nonnull
+
+# The BUILT_SOURCES created by this Makefile snippet are not used via #include
+# statements but through direct file reference. Therefore this snippet must be
+# present in all Makefile.am that need it. This is ensured by the applicability
+# 'all' defined above.
+
+BUILT_SOURCES += arg-nonnull.h
+# The arg-nonnull.h that gets inserted into generated .h files is the same as
+# build-aux/arg-nonnull.h, except that it has the copyright header cut off.
+arg-nonnull.h: $(top_srcdir)/build-aux/arg-nonnull.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	sed -n -e '/GL_ARG_NONNULL/,$$p' \
+	  < $(top_srcdir)/build-aux/arg-nonnull.h \
+	  > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += arg-nonnull.h arg-nonnull.h-t
+
+ARG_NONNULL_H=arg-nonnull.h
+
+EXTRA_DIST += $(top_srcdir)/build-aux/arg-nonnull.h
+
+## end   gnulib module arg-nonnull
+
+## begin gnulib module binary-io
+
+libtests_a_SOURCES += binary-io.h
+
+## end   gnulib module binary-io
+
+## begin gnulib module binary-io-tests
+
+TESTS += test-binary-io.sh
+check_PROGRAMS += test-binary-io
+
+EXTRA_DIST += test-binary-io.sh test-binary-io.c macros.h
+
+## end   gnulib module binary-io-tests
+
+## begin gnulib module c++defs
+
+# The BUILT_SOURCES created by this Makefile snippet are not used via #include
+# statements but through direct file reference. Therefore this snippet must be
+# present in all Makefile.am that need it. This is ensured by the applicability
+# 'all' defined above.
+
+BUILT_SOURCES += c++defs.h
+# The c++defs.h that gets inserted into generated .h files is the same as
+# build-aux/c++defs.h, except that it has the copyright header cut off.
+c++defs.h: $(top_srcdir)/build-aux/c++defs.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	sed -n -e '/_GL_CXXDEFS/,$$p' \
+	  < $(top_srcdir)/build-aux/c++defs.h \
+	  > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += c++defs.h c++defs.h-t
+
+CXXDEFS_H=c++defs.h
+
+EXTRA_DIST += $(top_srcdir)/build-aux/c++defs.h
+
+## end   gnulib module c++defs
+
+## begin gnulib module dup2
+
+
+EXTRA_DIST += dup2.c
+
+EXTRA_libtests_a_SOURCES += dup2.c
+
+## end   gnulib module dup2
+
+## begin gnulib module dup2-tests
+
+TESTS += test-dup2
+check_PROGRAMS += test-dup2
+EXTRA_DIST += test-dup2.c signature.h macros.h
+
+## end   gnulib module dup2-tests
+
+## begin gnulib module environ-tests
+
+TESTS += test-environ
+check_PROGRAMS += test-environ
+
+EXTRA_DIST += test-environ.c
+
+## end   gnulib module environ-tests
 
 ## begin gnulib module errno-tests
 
@@ -44,11 +171,356 @@ EXTRA_DIST += test-errno.c
 
 ## end   gnulib module errno-tests
 
+## begin gnulib module fcntl-h
+
+BUILT_SOURCES += fcntl.h
+
+# We need the following in order to create <fcntl.h> when the system
+# doesn't have one that works with the given compiler.
+fcntl.h: fcntl.in.h $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_FCNTL_H''@|$(NEXT_FCNTL_H)|g' \
+	      -e 's|@''GNULIB_FCNTL''@|$(GNULIB_FCNTL)|g' \
+	      -e 's|@''GNULIB_OPEN''@|$(GNULIB_OPEN)|g' \
+	      -e 's|@''GNULIB_OPENAT''@|$(GNULIB_OPENAT)|g' \
+	      -e 's|@''HAVE_FCNTL''@|$(HAVE_FCNTL)|g' \
+	      -e 's|@''HAVE_OPENAT''@|$(HAVE_OPENAT)|g' \
+	      -e 's|@''REPLACE_FCNTL''@|$(REPLACE_FCNTL)|g' \
+	      -e 's|@''REPLACE_OPEN''@|$(REPLACE_OPEN)|g' \
+	      -e 's|@''REPLACE_OPENAT''@|$(REPLACE_OPENAT)|g' \
+	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
+	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
+	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
+	      < $(srcdir)/fcntl.in.h; \
+	} > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += fcntl.h fcntl.h-t
+
+EXTRA_DIST += fcntl.in.h
+
+## end   gnulib module fcntl-h
+
+## begin gnulib module fcntl-h-tests
+
+TESTS += test-fcntl-h
+check_PROGRAMS += test-fcntl-h
+EXTRA_DIST += test-fcntl-h.c
+
+## end   gnulib module fcntl-h-tests
+
+## begin gnulib module getopt-posix-tests
+
+TESTS += test-getopt
+check_PROGRAMS += test-getopt
+test_getopt_LDADD = $(LDADD) $(LIBINTL)
+EXTRA_DIST += macros.h signature.h test-getopt.c test-getopt.h test-getopt_long.h
+
+## end   gnulib module getopt-posix-tests
+
+## begin gnulib module ignore-value
+
+libtests_a_SOURCES += ignore-value.h
+
+## end   gnulib module ignore-value
+
+## begin gnulib module lstat
+
+
+EXTRA_DIST += lstat.c
+
+EXTRA_libtests_a_SOURCES += lstat.c
+
+## end   gnulib module lstat
+
+## begin gnulib module lstat-tests
+
+TESTS += test-lstat
+check_PROGRAMS += test-lstat
+EXTRA_DIST += test-lstat.h test-lstat.c signature.h macros.h
+
+## end   gnulib module lstat-tests
+
+## begin gnulib module malloc-posix
+
+
+EXTRA_DIST += malloc.c
+
+EXTRA_libtests_a_SOURCES += malloc.c
+
+## end   gnulib module malloc-posix
+
+## begin gnulib module malloca
+
+libtests_a_SOURCES += malloca.c
+
+EXTRA_DIST += malloca.h malloca.valgrind
+
+## end   gnulib module malloca
+
+## begin gnulib module malloca-tests
+
+TESTS += test-malloca
+check_PROGRAMS += test-malloca
+
+EXTRA_DIST += test-malloca.c
+
+## end   gnulib module malloca-tests
+
+## begin gnulib module open
+
+
+EXTRA_DIST += open.c
+
+EXTRA_libtests_a_SOURCES += open.c
+
+## end   gnulib module open
+
+## begin gnulib module open-tests
+
+TESTS += test-open
+check_PROGRAMS += test-open
+EXTRA_DIST += test-open.h test-open.c signature.h macros.h
+
+## end   gnulib module open-tests
+
+## begin gnulib module pathmax
+
+
+EXTRA_DIST += pathmax.h
+
+## end   gnulib module pathmax
+
+## begin gnulib module putenv
+
+
+EXTRA_DIST += putenv.c
+
+EXTRA_libtests_a_SOURCES += putenv.c
+
+## end   gnulib module putenv
+
+## begin gnulib module same-inode
+
+
+EXTRA_DIST += same-inode.h
+
+## end   gnulib module same-inode
+
+## begin gnulib module setenv
+
+
+EXTRA_DIST += setenv.c
+
+EXTRA_libtests_a_SOURCES += setenv.c
+
+## end   gnulib module setenv
+
+## begin gnulib module setenv-tests
+
+TESTS += test-setenv
+check_PROGRAMS += test-setenv
+EXTRA_DIST += test-setenv.c signature.h macros.h
+
+## end   gnulib module setenv-tests
+
+## begin gnulib module stat
+
+
+EXTRA_DIST += stat.c
+
+EXTRA_libtests_a_SOURCES += stat.c
+
+## end   gnulib module stat
+
+## begin gnulib module stat-tests
+
+TESTS += test-stat
+check_PROGRAMS += test-stat
+EXTRA_DIST += test-stat.h test-stat.c signature.h macros.h
+
+## end   gnulib module stat-tests
+
+## begin gnulib module stdbool
+
+BUILT_SOURCES += $(STDBOOL_H)
+
+# We need the following in order to create <stdbool.h> when the system
+# doesn't have one that works.
+stdbool.h: stdbool.in.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's/@''HAVE__BOOL''@/$(HAVE__BOOL)/g' < $(srcdir)/stdbool.in.h; \
+	} > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += stdbool.h stdbool.h-t
+
+EXTRA_DIST += stdbool.in.h
+
+## end   gnulib module stdbool
+
+## begin gnulib module stdbool-tests
+
+TESTS += test-stdbool
+check_PROGRAMS += test-stdbool
+EXTRA_DIST += test-stdbool.c
+
+## end   gnulib module stdbool-tests
+
+## begin gnulib module stddef-tests
+
+TESTS += test-stddef
+check_PROGRAMS += test-stddef
+EXTRA_DIST += test-stddef.c
+
+## end   gnulib module stddef-tests
+
+## begin gnulib module stdint
+
+BUILT_SOURCES += $(STDINT_H)
+
+# We need the following in order to create <stdint.h> when the system
+# doesn't have one that works with the given compiler.
+stdint.h: stdint.in.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's/@''HAVE_STDINT_H''@/$(HAVE_STDINT_H)/g' \
+	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_STDINT_H''@|$(NEXT_STDINT_H)|g' \
+	      -e 's/@''HAVE_SYS_TYPES_H''@/$(HAVE_SYS_TYPES_H)/g' \
+	      -e 's/@''HAVE_INTTYPES_H''@/$(HAVE_INTTYPES_H)/g' \
+	      -e 's/@''HAVE_SYS_INTTYPES_H''@/$(HAVE_SYS_INTTYPES_H)/g' \
+	      -e 's/@''HAVE_SYS_BITYPES_H''@/$(HAVE_SYS_BITYPES_H)/g' \
+	      -e 's/@''HAVE_LONG_LONG_INT''@/$(HAVE_LONG_LONG_INT)/g' \
+	      -e 's/@''HAVE_UNSIGNED_LONG_LONG_INT''@/$(HAVE_UNSIGNED_LONG_LONG_INT)/g' \
+	      -e 's/@''APPLE_UNIVERSAL_BUILD''@/$(APPLE_UNIVERSAL_BUILD)/g' \
+	      -e 's/@''BITSIZEOF_PTRDIFF_T''@/$(BITSIZEOF_PTRDIFF_T)/g' \
+	      -e 's/@''PTRDIFF_T_SUFFIX''@/$(PTRDIFF_T_SUFFIX)/g' \
+	      -e 's/@''BITSIZEOF_SIG_ATOMIC_T''@/$(BITSIZEOF_SIG_ATOMIC_T)/g' \
+	      -e 's/@''HAVE_SIGNED_SIG_ATOMIC_T''@/$(HAVE_SIGNED_SIG_ATOMIC_T)/g' \
+	      -e 's/@''SIG_ATOMIC_T_SUFFIX''@/$(SIG_ATOMIC_T_SUFFIX)/g' \
+	      -e 's/@''BITSIZEOF_SIZE_T''@/$(BITSIZEOF_SIZE_T)/g' \
+	      -e 's/@''SIZE_T_SUFFIX''@/$(SIZE_T_SUFFIX)/g' \
+	      -e 's/@''BITSIZEOF_WCHAR_T''@/$(BITSIZEOF_WCHAR_T)/g' \
+	      -e 's/@''HAVE_SIGNED_WCHAR_T''@/$(HAVE_SIGNED_WCHAR_T)/g' \
+	      -e 's/@''WCHAR_T_SUFFIX''@/$(WCHAR_T_SUFFIX)/g' \
+	      -e 's/@''BITSIZEOF_WINT_T''@/$(BITSIZEOF_WINT_T)/g' \
+	      -e 's/@''HAVE_SIGNED_WINT_T''@/$(HAVE_SIGNED_WINT_T)/g' \
+	      -e 's/@''WINT_T_SUFFIX''@/$(WINT_T_SUFFIX)/g' \
+	      < $(srcdir)/stdint.in.h; \
+	} > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += stdint.h stdint.h-t
+
+EXTRA_DIST += stdint.in.h
+
+## end   gnulib module stdint
+
+## begin gnulib module stdint-tests
+
+TESTS += test-stdint
+check_PROGRAMS += test-stdint
+EXTRA_DIST += test-stdint.c
+
+## end   gnulib module stdint-tests
+
+## begin gnulib module stdlib
+
+BUILT_SOURCES += stdlib.h
+
+# We need the following in order to create <stdlib.h> when the system
+# doesn't have one that works with the given compiler.
+stdlib.h: stdlib.in.h $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
+	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_STDLIB_H''@|$(NEXT_STDLIB_H)|g' \
+	      -e 's|@''GNULIB_ATOLL''@|$(GNULIB_ATOLL)|g' \
+	      -e 's|@''GNULIB_CALLOC_POSIX''@|$(GNULIB_CALLOC_POSIX)|g' \
+	      -e 's|@''GNULIB_CANONICALIZE_FILE_NAME''@|$(GNULIB_CANONICALIZE_FILE_NAME)|g' \
+	      -e 's|@''GNULIB_GETLOADAVG''@|$(GNULIB_GETLOADAVG)|g' \
+	      -e 's|@''GNULIB_GETSUBOPT''@|$(GNULIB_GETSUBOPT)|g' \
+	      -e 's|@''GNULIB_GRANTPT''@|$(GNULIB_GRANTPT)|g' \
+	      -e 's|@''GNULIB_MALLOC_POSIX''@|$(GNULIB_MALLOC_POSIX)|g' \
+	      -e 's|@''GNULIB_MKDTEMP''@|$(GNULIB_MKDTEMP)|g' \
+	      -e 's|@''GNULIB_MKOSTEMP''@|$(GNULIB_MKOSTEMP)|g' \
+	      -e 's|@''GNULIB_MKOSTEMPS''@|$(GNULIB_MKOSTEMPS)|g' \
+	      -e 's|@''GNULIB_MKSTEMP''@|$(GNULIB_MKSTEMP)|g' \
+	      -e 's|@''GNULIB_MKSTEMPS''@|$(GNULIB_MKSTEMPS)|g' \
+	      -e 's|@''GNULIB_PTSNAME''@|$(GNULIB_PTSNAME)|g' \
+	      -e 's|@''GNULIB_PUTENV''@|$(GNULIB_PUTENV)|g' \
+	      -e 's|@''GNULIB_RANDOM_R''@|$(GNULIB_RANDOM_R)|g' \
+	      -e 's|@''GNULIB_REALLOC_POSIX''@|$(GNULIB_REALLOC_POSIX)|g' \
+	      -e 's|@''GNULIB_REALPATH''@|$(GNULIB_REALPATH)|g' \
+	      -e 's|@''GNULIB_RPMATCH''@|$(GNULIB_RPMATCH)|g' \
+	      -e 's|@''GNULIB_SETENV''@|$(GNULIB_SETENV)|g' \
+	      -e 's|@''GNULIB_STRTOD''@|$(GNULIB_STRTOD)|g' \
+	      -e 's|@''GNULIB_STRTOLL''@|$(GNULIB_STRTOLL)|g' \
+	      -e 's|@''GNULIB_STRTOULL''@|$(GNULIB_STRTOULL)|g' \
+	      -e 's|@''GNULIB_UNLOCKPT''@|$(GNULIB_UNLOCKPT)|g' \
+	      -e 's|@''GNULIB_UNSETENV''@|$(GNULIB_UNSETENV)|g' \
+	      -e 's|@''HAVE_ATOLL''@|$(HAVE_ATOLL)|g' \
+	      -e 's|@''HAVE_CALLOC_POSIX''@|$(HAVE_CALLOC_POSIX)|g' \
+	      -e 's|@''HAVE_CANONICALIZE_FILE_NAME''@|$(HAVE_CANONICALIZE_FILE_NAME)|g' \
+	      -e 's|@''HAVE_DECL_GETLOADAVG''@|$(HAVE_DECL_GETLOADAVG)|g' \
+	      -e 's|@''HAVE_GETSUBOPT''@|$(HAVE_GETSUBOPT)|g' \
+	      -e 's|@''HAVE_GRANTPT''@|$(HAVE_GRANTPT)|g' \
+	      -e 's|@''HAVE_MALLOC_POSIX''@|$(HAVE_MALLOC_POSIX)|g' \
+	      -e 's|@''HAVE_MKDTEMP''@|$(HAVE_MKDTEMP)|g' \
+	      -e 's|@''HAVE_MKOSTEMP''@|$(HAVE_MKOSTEMP)|g' \
+	      -e 's|@''HAVE_MKOSTEMPS''@|$(HAVE_MKOSTEMPS)|g' \
+	      -e 's|@''HAVE_MKSTEMP''@|$(HAVE_MKSTEMP)|g' \
+	      -e 's|@''HAVE_MKSTEMPS''@|$(HAVE_MKSTEMPS)|g' \
+	      -e 's|@''HAVE_PTSNAME''@|$(HAVE_PTSNAME)|g' \
+	      -e 's|@''HAVE_RANDOM_H''@|$(HAVE_RANDOM_H)|g' \
+	      -e 's|@''HAVE_RANDOM_R''@|$(HAVE_RANDOM_R)|g' \
+	      -e 's|@''HAVE_REALLOC_POSIX''@|$(HAVE_REALLOC_POSIX)|g' \
+	      -e 's|@''HAVE_REALPATH''@|$(HAVE_REALPATH)|g' \
+	      -e 's|@''HAVE_RPMATCH''@|$(HAVE_RPMATCH)|g' \
+	      -e 's|@''HAVE_SETENV''@|$(HAVE_SETENV)|g' \
+	      -e 's|@''HAVE_STRTOD''@|$(HAVE_STRTOD)|g' \
+	      -e 's|@''HAVE_STRTOLL''@|$(HAVE_STRTOLL)|g' \
+	      -e 's|@''HAVE_STRTOULL''@|$(HAVE_STRTOULL)|g' \
+	      -e 's|@''HAVE_STRUCT_RANDOM_DATA''@|$(HAVE_STRUCT_RANDOM_DATA)|g' \
+	      -e 's|@''HAVE_SYS_LOADAVG_H''@|$(HAVE_SYS_LOADAVG_H)|g' \
+	      -e 's|@''HAVE_UNLOCKPT''@|$(HAVE_UNLOCKPT)|g' \
+	      -e 's|@''HAVE_UNSETENV''@|$(HAVE_UNSETENV)|g' \
+	      -e 's|@''REPLACE_CANONICALIZE_FILE_NAME''@|$(REPLACE_CANONICALIZE_FILE_NAME)|g' \
+	      -e 's|@''REPLACE_MKSTEMP''@|$(REPLACE_MKSTEMP)|g' \
+	      -e 's|@''REPLACE_PUTENV''@|$(REPLACE_PUTENV)|g' \
+	      -e 's|@''REPLACE_REALPATH''@|$(REPLACE_REALPATH)|g' \
+	      -e 's|@''REPLACE_SETENV''@|$(REPLACE_SETENV)|g' \
+	      -e 's|@''REPLACE_STRTOD''@|$(REPLACE_STRTOD)|g' \
+	      -e 's|@''REPLACE_UNSETENV''@|$(REPLACE_UNSETENV)|g' \
+	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
+	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
+	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
+	      < $(srcdir)/stdlib.in.h; \
+	} > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += stdlib.h stdlib.h-t
+
+EXTRA_DIST += stdlib.in.h
+
+## end   gnulib module stdlib
+
+## begin gnulib module stdlib-tests
+
+TESTS += test-stdlib
+check_PROGRAMS += test-stdlib
+EXTRA_DIST += test-stdlib.c
+
+## end   gnulib module stdlib-tests
+
 ## begin gnulib module strerror-tests
 
 TESTS += test-strerror
 check_PROGRAMS += test-strerror
-EXTRA_DIST += test-strerror.c
+EXTRA_DIST += test-strerror.c signature.h macros.h
 
 ## end   gnulib module strerror-tests
 
@@ -56,29 +528,292 @@ EXTRA_DIST += test-strerror.c
 
 TESTS += test-string
 check_PROGRAMS += test-string
-
 EXTRA_DIST += test-string.c
 
 ## end   gnulib module string-tests
 
+## begin gnulib module symlink
+
+
+EXTRA_DIST += symlink.c
+
+EXTRA_libtests_a_SOURCES += symlink.c
+
+## end   gnulib module symlink
+
+## begin gnulib module symlink-tests
+
+TESTS += test-symlink
+check_PROGRAMS += test-symlink
+EXTRA_DIST += test-symlink.h test-symlink.c signature.h macros.h
+
+## end   gnulib module symlink-tests
+
+## begin gnulib module sys_stat
+
+BUILT_SOURCES += sys/stat.h
+
+# We need the following in order to create <sys/stat.h> when the system
+# has one that is incomplete.
+sys/stat.h: sys_stat.in.h $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
+	$(AM_V_at)$(MKDIR_P) sys
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_SYS_STAT_H''@|$(NEXT_SYS_STAT_H)|g' \
+	      -e 's|@''GNULIB_FCHMODAT''@|$(GNULIB_FCHMODAT)|g' \
+	      -e 's|@''GNULIB_FSTATAT''@|$(GNULIB_FSTATAT)|g' \
+	      -e 's|@''GNULIB_FUTIMENS''@|$(GNULIB_FUTIMENS)|g' \
+	      -e 's|@''GNULIB_LCHMOD''@|$(GNULIB_LCHMOD)|g' \
+	      -e 's|@''GNULIB_LSTAT''@|$(GNULIB_LSTAT)|g' \
+	      -e 's|@''GNULIB_MKDIRAT''@|$(GNULIB_MKDIRAT)|g' \
+	      -e 's|@''GNULIB_MKFIFO''@|$(GNULIB_MKFIFO)|g' \
+	      -e 's|@''GNULIB_MKFIFOAT''@|$(GNULIB_MKFIFOAT)|g' \
+	      -e 's|@''GNULIB_MKNOD''@|$(GNULIB_MKNOD)|g' \
+	      -e 's|@''GNULIB_MKNODAT''@|$(GNULIB_MKNODAT)|g' \
+	      -e 's|@''GNULIB_STAT''@|$(GNULIB_STAT)|g' \
+	      -e 's|@''GNULIB_UTIMENSAT''@|$(GNULIB_UTIMENSAT)|g' \
+	      -e 's|@''HAVE_FCHMODAT''@|$(HAVE_FCHMODAT)|g' \
+	      -e 's|@''HAVE_FSTATAT''@|$(HAVE_FSTATAT)|g' \
+	      -e 's|@''HAVE_FUTIMENS''@|$(HAVE_FUTIMENS)|g' \
+	      -e 's|@''HAVE_LCHMOD''@|$(HAVE_LCHMOD)|g' \
+	      -e 's|@''HAVE_LSTAT''@|$(HAVE_LSTAT)|g' \
+	      -e 's|@''HAVE_MKDIRAT''@|$(HAVE_MKDIRAT)|g' \
+	      -e 's|@''HAVE_MKFIFO''@|$(HAVE_MKFIFO)|g' \
+	      -e 's|@''HAVE_MKFIFOAT''@|$(HAVE_MKFIFOAT)|g' \
+	      -e 's|@''HAVE_MKNOD''@|$(HAVE_MKNOD)|g' \
+	      -e 's|@''HAVE_MKNODAT''@|$(HAVE_MKNODAT)|g' \
+	      -e 's|@''HAVE_UTIMENSAT''@|$(HAVE_UTIMENSAT)|g' \
+	      -e 's|@''REPLACE_FSTAT''@|$(REPLACE_FSTAT)|g' \
+	      -e 's|@''REPLACE_FSTATAT''@|$(REPLACE_FSTATAT)|g' \
+	      -e 's|@''REPLACE_FUTIMENS''@|$(REPLACE_FUTIMENS)|g' \
+	      -e 's|@''REPLACE_LSTAT''@|$(REPLACE_LSTAT)|g' \
+	      -e 's|@''REPLACE_MKDIR''@|$(REPLACE_MKDIR)|g' \
+	      -e 's|@''REPLACE_MKFIFO''@|$(REPLACE_MKFIFO)|g' \
+	      -e 's|@''REPLACE_MKNOD''@|$(REPLACE_MKNOD)|g' \
+	      -e 's|@''REPLACE_STAT''@|$(REPLACE_STAT)|g' \
+	      -e 's|@''REPLACE_UTIMENSAT''@|$(REPLACE_UTIMENSAT)|g' \
+	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
+	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
+	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
+	      < $(srcdir)/sys_stat.in.h; \
+	} > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += sys/stat.h sys/stat.h-t
+MOSTLYCLEANDIRS += sys
+
+EXTRA_DIST += sys_stat.in.h
+
+## end   gnulib module sys_stat
+
+## begin gnulib module sys_stat-tests
+
+TESTS += test-sys_stat
+check_PROGRAMS += test-sys_stat
+EXTRA_DIST += test-sys_stat.c
+
+## end   gnulib module sys_stat-tests
+
+## begin gnulib module time
+
+BUILT_SOURCES += time.h
+
+# We need the following in order to create <time.h> when the system
+# doesn't have one that works with the given compiler.
+time.h: time.in.h $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
+	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_TIME_H''@|$(NEXT_TIME_H)|g' \
+	      -e 's|@''GNULIB_MKTIME''@|$(GNULIB_MKTIME)|g' \
+	      -e 's|@''GNULIB_NANOSLEEP''@|$(GNULIB_NANOSLEEP)|g' \
+	      -e 's|@''GNULIB_STRPTIME''@|$(GNULIB_STRPTIME)|g' \
+	      -e 's|@''GNULIB_TIMEGM''@|$(GNULIB_TIMEGM)|g' \
+	      -e 's|@''GNULIB_TIME_R''@|$(GNULIB_TIME_R)|g' \
+	      -e 's|@''HAVE_LOCALTIME_R''@|$(HAVE_LOCALTIME_R)|g' \
+	      -e 's|@''HAVE_NANOSLEEP''@|$(HAVE_NANOSLEEP)|g' \
+	      -e 's|@''HAVE_STRPTIME''@|$(HAVE_STRPTIME)|g' \
+	      -e 's|@''HAVE_TIMEGM''@|$(HAVE_TIMEGM)|g' \
+	      -e 's|@''REPLACE_LOCALTIME_R''@|$(REPLACE_LOCALTIME_R)|g' \
+	      -e 's|@''REPLACE_MKTIME''@|$(REPLACE_MKTIME)|g' \
+	      -e 's|@''REPLACE_NANOSLEEP''@|$(REPLACE_NANOSLEEP)|g' \
+	      -e 's|@''REPLACE_TIMEGM''@|$(REPLACE_TIMEGM)|g' \
+	      -e 's|@''PTHREAD_H_DEFINES_STRUCT_TIMESPEC''@|$(PTHREAD_H_DEFINES_STRUCT_TIMESPEC)|g' \
+	      -e 's|@''SYS_TIME_H_DEFINES_STRUCT_TIMESPEC''@|$(SYS_TIME_H_DEFINES_STRUCT_TIMESPEC)|g' \
+	      -e 's|@''TIME_H_DEFINES_STRUCT_TIMESPEC''@|$(TIME_H_DEFINES_STRUCT_TIMESPEC)|g' \
+	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
+	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
+	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
+	      < $(srcdir)/time.in.h; \
+	} > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += time.h time.h-t
+
+EXTRA_DIST += time.in.h
+
+## end   gnulib module time
+
+## begin gnulib module time-tests
+
+TESTS += test-time
+check_PROGRAMS += test-time
+EXTRA_DIST += test-time.c
+
+## end   gnulib module time-tests
+
 ## begin gnulib module unistd-tests
 
 TESTS += test-unistd
 check_PROGRAMS += test-unistd
-
 EXTRA_DIST += test-unistd.c
 
 ## end   gnulib module unistd-tests
 
+## begin gnulib module unsetenv
+
+
+EXTRA_DIST += unsetenv.c
+
+EXTRA_libtests_a_SOURCES += unsetenv.c
+
+## end   gnulib module unsetenv
+
+## begin gnulib module unsetenv-tests
+
+TESTS += test-unsetenv
+check_PROGRAMS += test-unsetenv
+EXTRA_DIST += test-unsetenv.c signature.h macros.h
+
+## end   gnulib module unsetenv-tests
+
 ## begin gnulib module vc-list-files-tests
 
 TESTS += test-vc-list-files-git.sh
 TESTS += test-vc-list-files-cvs.sh
 TESTS_ENVIRONMENT += PATH='$(abs_aux_dir)'$(PATH_SEPARATOR)"$$PATH"
-EXTRA_DIST += test-vc-list-files-git.sh test-vc-list-files-cvs.sh
+EXTRA_DIST += test-vc-list-files-git.sh test-vc-list-files-cvs.sh init.sh
 
 ## end   gnulib module vc-list-files-tests
 
+## begin gnulib module verify
+
+libtests_a_SOURCES += verify.h
+
+## end   gnulib module verify
+
+## begin gnulib module verify-tests
+
+TESTS_ENVIRONMENT += MAKE='$(MAKE)'
+TESTS += test-verify test-verify.sh
+check_PROGRAMS += test-verify
+EXTRA_DIST += test-verify.c test-verify.sh init.sh
+
+## end   gnulib module verify-tests
+
+## begin gnulib module version-etc-fsf
+
+libtests_a_SOURCES += version-etc-fsf.c
+
+## end   gnulib module version-etc-fsf
+
+## begin gnulib module version-etc-tests
+
+TESTS += test-version-etc.sh
+check_PROGRAMS += test-version-etc
+test_version_etc_LDADD = $(LDADD) @LIBINTL@
+EXTRA_DIST += test-version-etc.c test-version-etc.sh
+
+## end   gnulib module version-etc-tests
+
+## begin gnulib module warn-on-use
+
+BUILT_SOURCES += warn-on-use.h
+# The warn-on-use.h that gets inserted into generated .h files is the same as
+# build-aux/warn-on-use.h, except that it has the copyright header cut off.
+warn-on-use.h: $(top_srcdir)/build-aux/warn-on-use.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	sed -n -e '/^.ifndef/,$$p' \
+	  < $(top_srcdir)/build-aux/warn-on-use.h \
+	  > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += warn-on-use.h warn-on-use.h-t
+
+WARN_ON_USE_H=warn-on-use.h
+
+EXTRA_DIST += $(top_srcdir)/build-aux/warn-on-use.h
+
+## end   gnulib module warn-on-use
+
+## begin gnulib module wchar
+
+BUILT_SOURCES += wchar.h
+
+# We need the following in order to create <wchar.h> when the system
+# version does not work standalone.
+wchar.h: wchar.in.h $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_WCHAR_H''@|$(NEXT_WCHAR_H)|g' \
+	      -e 's|@''HAVE_WCHAR_H''@|$(HAVE_WCHAR_H)|g' \
+	      -e 's|@''GNULIB_BTOWC''@|$(GNULIB_BTOWC)|g' \
+	      -e 's|@''GNULIB_WCTOB''@|$(GNULIB_WCTOB)|g' \
+	      -e 's|@''GNULIB_MBSINIT''@|$(GNULIB_MBSINIT)|g' \
+	      -e 's|@''GNULIB_MBRTOWC''@|$(GNULIB_MBRTOWC)|g' \
+	      -e 's|@''GNULIB_MBRLEN''@|$(GNULIB_MBRLEN)|g' \
+	      -e 's|@''GNULIB_MBSRTOWCS''@|$(GNULIB_MBSRTOWCS)|g' \
+	      -e 's|@''GNULIB_MBSNRTOWCS''@|$(GNULIB_MBSNRTOWCS)|g' \
+	      -e 's|@''GNULIB_WCRTOMB''@|$(GNULIB_WCRTOMB)|g' \
+	      -e 's|@''GNULIB_WCSRTOMBS''@|$(GNULIB_WCSRTOMBS)|g' \
+	      -e 's|@''GNULIB_WCSNRTOMBS''@|$(GNULIB_WCSNRTOMBS)|g' \
+	      -e 's|@''GNULIB_WCWIDTH''@|$(GNULIB_WCWIDTH)|g' \
+	      -e 's|@''HAVE_WINT_T''@|$(HAVE_WINT_T)|g' \
+	      -e 's|@''HAVE_BTOWC''@|$(HAVE_BTOWC)|g' \
+	      -e 's|@''HAVE_MBSINIT''@|$(HAVE_MBSINIT)|g' \
+	      -e 's|@''HAVE_MBRTOWC''@|$(HAVE_MBRTOWC)|g' \
+	      -e 's|@''HAVE_MBRLEN''@|$(HAVE_MBRLEN)|g' \
+	      -e 's|@''HAVE_MBSRTOWCS''@|$(HAVE_MBSRTOWCS)|g' \
+	      -e 's|@''HAVE_MBSNRTOWCS''@|$(HAVE_MBSNRTOWCS)|g' \
+	      -e 's|@''HAVE_WCRTOMB''@|$(HAVE_WCRTOMB)|g' \
+	      -e 's|@''HAVE_WCSRTOMBS''@|$(HAVE_WCSRTOMBS)|g' \
+	      -e 's|@''HAVE_WCSNRTOMBS''@|$(HAVE_WCSNRTOMBS)|g' \
+	      -e 's|@''HAVE_DECL_WCTOB''@|$(HAVE_DECL_WCTOB)|g' \
+	      -e 's|@''HAVE_DECL_WCWIDTH''@|$(HAVE_DECL_WCWIDTH)|g' \
+	      -e 's|@''REPLACE_MBSTATE_T''@|$(REPLACE_MBSTATE_T)|g' \
+	      -e 's|@''REPLACE_BTOWC''@|$(REPLACE_BTOWC)|g' \
+	      -e 's|@''REPLACE_WCTOB''@|$(REPLACE_WCTOB)|g' \
+	      -e 's|@''REPLACE_MBSINIT''@|$(REPLACE_MBSINIT)|g' \
+	      -e 's|@''REPLACE_MBRTOWC''@|$(REPLACE_MBRTOWC)|g' \
+	      -e 's|@''REPLACE_MBRLEN''@|$(REPLACE_MBRLEN)|g' \
+	      -e 's|@''REPLACE_MBSRTOWCS''@|$(REPLACE_MBSRTOWCS)|g' \
+	      -e 's|@''REPLACE_MBSNRTOWCS''@|$(REPLACE_MBSNRTOWCS)|g' \
+	      -e 's|@''REPLACE_WCRTOMB''@|$(REPLACE_WCRTOMB)|g' \
+	      -e 's|@''REPLACE_WCSRTOMBS''@|$(REPLACE_WCSRTOMBS)|g' \
+	      -e 's|@''REPLACE_WCSNRTOMBS''@|$(REPLACE_WCSNRTOMBS)|g' \
+	      -e 's|@''REPLACE_WCWIDTH''@|$(REPLACE_WCWIDTH)|g' \
+	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
+	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
+	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
+	    < $(srcdir)/wchar.in.h; \
+	} > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += wchar.h wchar.h-t
+
+EXTRA_DIST += wchar.in.h
+
+## end   gnulib module wchar
+
+## begin gnulib module wchar-tests
+
+TESTS += test-wchar
+check_PROGRAMS += test-wchar
+EXTRA_DIST += test-wchar.c
+
+## end   gnulib module wchar-tests
+
 # Clean up after Solaris cc.
 clean-local:
 	rm -rf SunWS_cache
--- /dev/null
+++ b/gltests/alloca.in.h
@@ -0,0 +1,56 @@
+/* Memory allocation on the stack.
+
+   Copyright (C) 1995, 1999, 2001-2004, 2006-2010 Free Software Foundation,
+   Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
+   USA.  */
+
+/* Avoid using the symbol _ALLOCA_H here, as Bison assumes _ALLOCA_H
+   means there is a real alloca function.  */
+#ifndef _GL_ALLOCA_H
+#define _GL_ALLOCA_H
+
+/* alloca (N) returns a pointer to N bytes of memory
+   allocated on the stack, which will last until the function returns.
+   Use of alloca should be avoided:
+     - inside arguments of function calls - undefined behaviour,
+     - in inline functions - the allocation may actually last until the
+       calling function returns,
+     - for huge N (say, N >= 65536) - you never know how large (or small)
+       the stack is, and when the stack cannot fulfill the memory allocation
+       request, the program just crashes.
+ */
+
+#ifndef alloca
+# ifdef __GNUC__
+#  define alloca __builtin_alloca
+# elif defined _AIX
+#  define alloca __alloca
+# elif defined _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# elif defined __DECC && defined __VMS
+#  define alloca __ALLOCA
+# else
+#  include <stddef.h>
+#  ifdef  __cplusplus
+extern "C"
+#  endif
+void *alloca (size_t);
+# endif
+#endif
+
+#endif /* _GL_ALLOCA_H */
--- /dev/null
+++ b/gltests/binary-io.h
@@ -0,0 +1,66 @@
+/* Binary mode I/O.
+   Copyright (C) 2001, 2003, 2005, 2008, 2009, 2010 Free Software Foundation,
+   Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _BINARY_H
+#define _BINARY_H
+
+/* For systems that distinguish between text and binary I/O.
+   O_BINARY is usually declared in <fcntl.h>. */
+#include <fcntl.h>
+
+/* The MSVC7 <stdio.h> doesn't like to be included after '#define fileno ...',
+   so we include it here first.  */
+#include <stdio.h>
+
+#if !defined O_BINARY && defined _O_BINARY
+  /* For MSC-compatible compilers.  */
+# define O_BINARY _O_BINARY
+# define O_TEXT _O_TEXT
+#endif
+#if defined __BEOS__ || defined __HAIKU__
+  /* BeOS 5 and Haiku have O_BINARY and O_TEXT, but they have no effect.  */
+# undef O_BINARY
+# undef O_TEXT
+#endif
+
+/* SET_BINARY (fd);
+   changes the file descriptor fd to perform binary I/O.  */
+#if O_BINARY
+# if defined __EMX__ || defined __DJGPP__ || defined __CYGWIN__
+#  include <io.h> /* declares setmode() */
+# else
+#  define setmode _setmode
+#  undef fileno
+#  define fileno _fileno
+# endif
+# ifdef __DJGPP__
+#  include <unistd.h> /* declares isatty() */
+   /* Avoid putting stdin/stdout in binary mode if it is connected to
+      the console, because that would make it impossible for the user
+      to interrupt the program through Ctrl-C or Ctrl-Break.  */
+#  define SET_BINARY(fd) ((void) (!isatty (fd) ? (setmode (fd, O_BINARY), 0) : 0))
+# else
+#  define SET_BINARY(fd) ((void) setmode (fd, O_BINARY))
+# endif
+#else
+  /* On reasonable systems, binary I/O is the default.  */
+# undef O_BINARY
+# define O_BINARY 0
+# define SET_BINARY(fd) /* do nothing */ ((void) 0)
+#endif
+
+#endif /* _BINARY_H */
--- /dev/null
+++ b/gltests/dup2.c
@@ -0,0 +1,128 @@
+/* Duplicate an open file descriptor to a specified file descriptor.
+
+   Copyright (C) 1999, 2004-2007, 2009-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* written by Paul Eggert */
+
+#include <config.h>
+
+/* Specification.  */
+#include <unistd.h>
+
+#include <errno.h>
+#include <fcntl.h>
+
+#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+/* Get declarations of the Win32 API functions.  */
+# define WIN32_LEAN_AND_MEAN
+# include <windows.h>
+#endif
+
+#if HAVE_DUP2
+
+# undef dup2
+
+int
+rpl_dup2 (int fd, int desired_fd)
+{
+  int result;
+# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+  /* If fd is closed, mingw hangs on dup2 (fd, fd).  If fd is open,
+     dup2 (fd, fd) returns 0, but all further attempts to use fd in
+     future dup2 calls will hang.  */
+  if (fd == desired_fd)
+    {
+      if ((HANDLE) _get_osfhandle (fd) == INVALID_HANDLE_VALUE)
+        {
+          errno = EBADF;
+          return -1;
+        }
+      return fd;
+    }
+  /* Wine 1.0.1 return 0 when desired_fd is negative but not -1:
+     http://bugs.winehq.org/show_bug.cgi?id=21289 */
+  if (desired_fd < 0)
+    {
+      errno = EBADF;
+      return -1;
+    }
+# endif
+  result = dup2 (fd, desired_fd);
+# ifdef __linux__
+  /* Correct a Linux return value.
+     <http://git.kernel.org/?p=linux/kernel/git/stable/linux-2.6.30.y.git;a=commitdiff;h=2b79bc4f7ebbd5af3c8b867968f9f15602d5f802>
+   */
+  if (fd == desired_fd && result == (unsigned int) -EBADF)
+    {
+      errno = EBADF;
+      result = -1;
+    }
+# endif
+  if (result == 0)
+    result = desired_fd;
+  /* Correct a cygwin 1.5.x errno value.  */
+  else if (result == -1 && errno == EMFILE)
+    errno = EBADF;
+# if REPLACE_FCHDIR
+  if (fd != desired_fd && result != -1)
+    result = _gl_register_dup (fd, result);
+# endif
+  return result;
+}
+
+#else /* !HAVE_DUP2 */
+
+/* On older platforms, dup2 did not exist.  */
+
+# ifndef F_DUPFD
+static int
+dupfd (int fd, int desired_fd)
+{
+  int duplicated_fd = dup (fd);
+  if (duplicated_fd < 0 || duplicated_fd == desired_fd)
+    return duplicated_fd;
+  else
+    {
+      int r = dupfd (fd, desired_fd);
+      int e = errno;
+      close (duplicated_fd);
+      errno = e;
+      return r;
+    }
+}
+# endif
+
+int
+dup2 (int fd, int desired_fd)
+{
+  int result = fcntl (fd, F_GETFL) < 0 ? -1 : fd;
+  if (result == -1 || fd == desired_fd)
+    return result;
+  close (desired_fd);
+# ifdef F_DUPFD
+  result = fcntl (fd, F_DUPFD, desired_fd);
+#  if REPLACE_FCHDIR
+  if (0 <= result)
+    result = _gl_register_dup (fd, result);
+#  endif
+# else
+  result = dupfd (fd, desired_fd);
+# endif
+  if (result == -1 && (errno == EMFILE || errno == EINVAL))
+    errno = EBADF;
+  return result;
+}
+#endif /* !HAVE_DUP2 */
--- /dev/null
+++ b/gltests/fcntl.in.h
@@ -0,0 +1,279 @@
+/* Like <fcntl.h>, but with non-working flags defined to 0.
+
+   Copyright (C) 2006-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* written by Paul Eggert */
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+#if defined __need_system_fcntl_h
+/* Special invocation convention.  */
+
+#include <sys/types.h>
+#ifndef __GLIBC__ /* Avoid namespace pollution on glibc systems.  */
+# include <sys/stat.h>
+#endif
+#@INCLUDE_NEXT@ @NEXT_FCNTL_H@
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_FCNTL_H
+
+#include <sys/types.h>
+#ifndef __GLIBC__ /* Avoid namespace pollution on glibc systems.  */
+# include <sys/stat.h>
+#endif
+/* The include_next requires a split double-inclusion guard.  */
+#@INCLUDE_NEXT@ @NEXT_FCNTL_H@
+
+#ifndef _GL_FCNTL_H
+#define _GL_FCNTL_H
+
+#ifndef __GLIBC__ /* Avoid namespace pollution on glibc systems.  */
+# include <unistd.h>
+#endif
+
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+
+
+/* Declare overridden functions.  */
+
+#if @GNULIB_FCNTL@
+# if @REPLACE_FCNTL@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fcntl
+#   define fcntl rpl_fcntl
+#  endif
+_GL_FUNCDECL_RPL (fcntl, int, (int fd, int action, ...));
+_GL_CXXALIAS_RPL (fcntl, int, (int fd, int action, ...));
+# else
+#  if !@HAVE_FCNTL@
+_GL_FUNCDECL_SYS (fcntl, int, (int fd, int action, ...));
+#  endif
+_GL_CXXALIAS_SYS (fcntl, int, (int fd, int action, ...));
+# endif
+_GL_CXXALIASWARN (fcntl);
+#elif defined GNULIB_POSIXCHECK
+# undef fcntl
+# if HAVE_RAW_DECL_FCNTL
+_GL_WARN_ON_USE (fcntl, "fcntl is not always POSIX compliant - "
+                 "use gnulib module fcntl for portability");
+# endif
+#endif
+
+#if @GNULIB_OPEN@
+# if @REPLACE_OPEN@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef open
+#   define open rpl_open
+#  endif
+_GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                             _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+# else
+_GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+# endif
+_GL_CXXALIASWARN (open);
+#elif defined GNULIB_POSIXCHECK
+# undef open
+/* Assume open is always declared.  */
+_GL_WARN_ON_USE (open, "open is not always POSIX compliant - "
+                 "use gnulib module open for portability");
+#endif
+
+#if @GNULIB_OPENAT@
+# if @REPLACE_OPENAT@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef openat
+#   define openat rpl_openat
+#  endif
+_GL_FUNCDECL_RPL (openat, int,
+                  (int fd, char const *file, int flags, /* mode_t mode */ ...)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (openat, int,
+                  (int fd, char const *file, int flags, /* mode_t mode */ ...));
+# else
+#  if !@HAVE_OPENAT@
+_GL_FUNCDECL_SYS (openat, int,
+                  (int fd, char const *file, int flags, /* mode_t mode */ ...)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (openat, int,
+                  (int fd, char const *file, int flags, /* mode_t mode */ ...));
+# endif
+_GL_CXXALIASWARN (openat);
+#elif defined GNULIB_POSIXCHECK
+# undef openat
+# if HAVE_RAW_DECL_OPENAT
+_GL_WARN_ON_USE (openat, "openat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+/* Fix up the FD_* macros, only known to be missing on mingw.  */
+
+#ifndef FD_CLOEXEC
+# define FD_CLOEXEC 1
+#endif
+
+/* Fix up the supported F_* macros.  Intentionally leave other F_*
+   macros undefined.  Only known to be missing on mingw.  */
+
+#ifndef F_DUPFD_CLOEXEC
+# define F_DUPFD_CLOEXEC 0x40000000
+/* Witness variable: 1 if gnulib defined F_DUPFD_CLOEXEC, 0 otherwise.  */
+# define GNULIB_defined_F_DUPFD_CLOEXEC 1
+#else
+# define GNULIB_defined_F_DUPFD_CLOEXEC 0
+#endif
+
+#ifndef F_DUPFD
+# define F_DUPFD 1
+#endif
+
+#ifndef F_GETFD
+# define F_GETFD 2
+#endif
+
+/* Fix up the O_* macros.  */
+
+#if !defined O_DIRECT && defined O_DIRECTIO
+/* Tru64 spells it `O_DIRECTIO'.  */
+# define O_DIRECT O_DIRECTIO
+#endif
+
+#if !defined O_CLOEXEC && defined O_NOINHERIT
+/* Mingw spells it `O_NOINHERIT'.  Intentionally leave it
+   undefined if not available.  */
+# define O_CLOEXEC O_NOINHERIT
+#endif
+
+#ifndef O_DIRECT
+# define O_DIRECT 0
+#endif
+
+#ifndef O_DIRECTORY
+# define O_DIRECTORY 0
+#endif
+
+#ifndef O_DSYNC
+# define O_DSYNC 0
+#endif
+
+#ifndef O_NDELAY
+# define O_NDELAY 0
+#endif
+
+#ifndef O_NOATIME
+# define O_NOATIME 0
+#endif
+
+#ifndef O_NONBLOCK
+# define O_NONBLOCK O_NDELAY
+#endif
+
+#ifndef O_NOCTTY
+# define O_NOCTTY 0
+#endif
+
+#ifndef O_NOFOLLOW
+# define O_NOFOLLOW 0
+#endif
+
+#ifndef O_NOLINKS
+# define O_NOLINKS 0
+#endif
+
+#ifndef O_RSYNC
+# define O_RSYNC 0
+#endif
+
+#ifndef O_SYNC
+# define O_SYNC 0
+#endif
+
+#ifndef O_TTY_INIT
+# define O_TTY_INIT 0
+#endif
+
+/* For systems that distinguish between text and binary I/O.
+   O_BINARY is usually declared in fcntl.h  */
+#if !defined O_BINARY && defined _O_BINARY
+  /* For MSC-compatible compilers.  */
+# define O_BINARY _O_BINARY
+# define O_TEXT _O_TEXT
+#endif
+
+#if defined __BEOS__ || defined __HAIKU__
+  /* BeOS 5 and Haiku have O_BINARY and O_TEXT, but they have no effect.  */
+# undef O_BINARY
+# undef O_TEXT
+#endif
+
+#ifndef O_BINARY
+# define O_BINARY 0
+# define O_TEXT 0
+#endif
+
+/* Fix up the AT_* macros.  */
+
+/* Work around a bug in Solaris 9 and 10: AT_FDCWD is positive.  Its
+   value exceeds INT_MAX, so its use as an int doesn't conform to the
+   C standard, and GCC and Sun C complain in some cases.  If the bug
+   is present, undef AT_FDCWD here, so it can be redefined below.  */
+#if 0 < AT_FDCWD && AT_FDCWD == 0xffd19553
+# undef AT_FDCWD
+#endif
+
+/* Use the same bit pattern as Solaris 9, but with the proper
+   signedness.  The bit pattern is important, in case this actually is
+   Solaris with the above workaround.  */
+#ifndef AT_FDCWD
+# define AT_FDCWD (-3041965)
+#endif
+
+/* Use the same values as Solaris 9.  This shouldn't matter, but
+   there's no real reason to differ.  */
+#ifndef AT_SYMLINK_NOFOLLOW
+# define AT_SYMLINK_NOFOLLOW 4096
+#endif
+
+#ifndef AT_REMOVEDIR
+# define AT_REMOVEDIR 1
+#endif
+
+/* Solaris 9 lacks these two, so just pick unique values.  */
+#ifndef AT_SYMLINK_FOLLOW
+# define AT_SYMLINK_FOLLOW 2
+#endif
+
+#ifndef AT_EACCESS
+# define AT_EACCESS 4
+#endif
+
+
+#endif /* _GL_FCNTL_H */
+#endif /* _GL_FCNTL_H */
+#endif
--- /dev/null
+++ b/gltests/ignore-value.h
@@ -0,0 +1,37 @@
+/* ignore a function return without a compiler warning
+
+   Copyright (C) 2008-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Jim Meyering.  */
+
+/* Use these functions to avoid a warning when using a function declared with
+   gcc's warn_unused_result attribute, but for which you really do want to
+   ignore the result.  Traditionally, people have used a "(void)" cast to
+   indicate that a function's return value is deliberately unused.  However,
+   if the function is declared with __attribute__((warn_unused_result)),
+   gcc issues a warning even with the cast.
+
+   Caution: most of the time, you really should heed gcc's warning, and
+   check the return value.  However, in those exceptional cases in which
+   you're sure you know what you're doing, use this function.
+
+   For the record, here's one of the ignorable warnings:
+   "copy.c:233: warning: ignoring return value of 'fchown',
+   declared with attribute warn_unused_result".  */
+
+static inline void ignore_value (int i) { (void) i; }
+static inline void ignore_ptr (void* p) { (void) p; }
+/* FIXME: what about aggregate types? */
--- /dev/null
+++ b/gltests/init.sh
@@ -0,0 +1,387 @@
+# source this file; set up for tests
+
+# Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# Using this file in a test
+# =========================
+#
+# The typical skeleton of a test looks like this:
+#
+#   #!/bin/sh
+#   . "${srcdir=.}/init.sh"; path_prepend_ .
+#   Execute some commands.
+#   Note that these commands are executed in a subdirectory, therefore you
+#   need to prepend "../" to relative filenames in the build directory.
+#   Note that the "path_prepend_ ." is useful only if the body of your
+#   test invokes programs residing in the initial directory.
+#   For example, if the programs you want to test are in src/, and this test
+#   script is named tests/test-1, then you would use "path_prepend_ ../src",
+#   or perhaps export PATH='$(abs_top_builddir)/src$(PATH_SEPARATOR)'"$$PATH"
+#   to all tests via automake's TESTS_ENVIRONMENT.
+#   Set the exit code 0 for success, 77 for skipped, or 1 or other for failure.
+#   Use the skip_ and fail_ functions to print a diagnostic and then exit
+#   with the corresponding exit code.
+#   Exit $?
+
+# Executing a test that uses this file
+# ====================================
+#
+# Running a single test:
+#   $ make check TESTS=test-foo.sh
+#
+# Running a single test, with verbose output:
+#   $ make check TESTS=test-foo.sh VERBOSE=yes
+#
+# Running a single test, with single-stepping:
+#   1. Go into a sub-shell:
+#   $ bash
+#   2. Set relevant environment variables from TESTS_ENVIRONMENT in the
+#      Makefile:
+#   $ export srcdir=../../tests # this is an example
+#   3. Execute the commands from the test, copy&pasting them one by one:
+#   $ . "$srcdir/init.sh"; path_prepend_ .
+#   ...
+#   4. Finally
+#   $ exit
+
+ME_=`expr "./$0" : '.*/\(.*\)$'`
+
+# We use a trap below for cleanup.  This requires us to go through
+# hoops to get the right exit status transported through the handler.
+# So use `Exit STATUS' instead of `exit STATUS' inside of the tests.
+# Turn off errexit here so that we don't trip the bug with OSF1/Tru64
+# sh inside this function.
+Exit () { set +e; (exit $1); exit $1; }
+
+# Print warnings (e.g., about skipped and failed tests) to this file number.
+# Override by defining to say, 9, in init.cfg, and putting say,
+# "export ...ENVVAR_SETTINGS...; exec 9>&2; $(SHELL)" in the definition
+# of TESTS_ENVIRONMENT in your tests/Makefile.am file.
+# This is useful when using automake's parallel tests mode, to print
+# the reason for skip/failure to console, rather than to the .log files.
+: ${stderr_fileno_=2}
+
+warn_() { echo "$@" 1>&$stderr_fileno_; }
+fail_() { warn_ "$ME_: failed test: $@"; Exit 1; }
+skip_() { warn_ "$ME_: skipped test: $@"; Exit 77; }
+framework_failure_() { warn_ "$ME_: set-up failure: $@"; Exit 99; }
+
+# We require $(...) support unconditionally.
+# We require a few additional shell features only when $EXEEXT is nonempty,
+# in order to support automatic $EXEEXT emulation:
+# - hyphen-containing alias names
+# - we prefer to use ${var#...} substitution, rather than having
+#   to work around lack of support for that feature.
+# The following code attempts to find a shell with support for these features.
+# If the current shell passes the test, we're done.  Otherwise, test other
+# shells until we find one that passes.  If one is found, re-exec it.
+# If no acceptable shell is found, skip the current test.
+#
+# Use "9" to indicate success (rather than 0), in case some shell acts
+# like Solaris 10's /bin/sh but exits successfully instead of with status 2.
+
+gl_shell_test_script_='
+test $(echo y) = y || exit 1
+test -z "$EXEEXT" && exit 9
+shopt -s expand_aliases
+alias a-b="echo zoo"
+v=abx
+     test ${v%x} = ab \
+  && test ${v#a} = bx \
+  && test $(a-b) = zoo \
+  && exit 9
+'
+
+if test "x$1" = "x--no-reexec"; then
+  shift
+else
+  # 'eval'ing the above code makes Solaris 10's /bin/sh exit with $? set to 2.
+  # It does not evaluate any of the code after the "unexpected" `('.  Thus,
+  # we must run it in a subshell.
+  ( eval "$gl_shell_test_script_" ) > /dev/null 2>&1
+  if test $? = 9; then
+    : # The current shell is adequate.  No re-exec required.
+  else
+    # Search for a shell that meets our requirements.
+    for re_shell_ in "${CONFIG_SHELL:-no_shell}" /bin/sh bash dash zsh pdksh fail
+    do
+      test "$re_shell_" = no_shell && continue
+      test "$re_shell_" = fail && skip_ failed to find an adequate shell
+      "$re_shell_" -c "$gl_shell_test_script_" 2>/dev/null
+      if test $? = 9; then
+        # Found an acceptable shell.
+        exec "$re_shell_" "$0" --no-reexec "$@"
+        echo "$ME_: exec failed" 1>&2
+        exit 127
+      fi
+    done
+  fi
+fi
+
+test -n "$EXEEXT" && shopt -s expand_aliases
+
+# Enable glibc's malloc-perturbing option.
+# This is cheap and useful for exposing code that depends on the fact that
+# malloc-related functions often return memory that is mostly zeroed.
+# If you have the time and cycles, use valgrind to do an even better job.
+: ${MALLOC_PERTURB_=87}
+export MALLOC_PERTURB_
+
+# This is a stub function that is run upon trap (upon regular exit and
+# interrupt).  Override it with a per-test function, e.g., to unmount
+# a partition, or to undo any other global state changes.
+cleanup_() { :; }
+
+if ( diff --version < /dev/null 2>&1 | grep GNU ) > /dev/null 2>&1; then
+  compare() { diff -u "$@"; }
+elif ( cmp --version < /dev/null 2>&1 | grep GNU ) > /dev/null 2>&1; then
+  compare() { cmp -s "$@"; }
+else
+  compare() { cmp "$@"; }
+fi
+
+# An arbitrary prefix to help distinguish test directories.
+testdir_prefix_() { printf gt; }
+
+# Run the user-overridable cleanup_ function, remove the temporary
+# directory and exit with the incoming value of $?.
+remove_tmp_()
+{
+  __st=$?
+  cleanup_
+  # cd out of the directory we're about to remove
+  cd "$initial_cwd_" || cd / || cd /tmp
+  chmod -R u+rwx "$test_dir_"
+  # If removal fails and exit status was to be 0, then change it to 1.
+  rm -rf "$test_dir_" || { test $__st = 0 && __st=1; }
+  exit $__st
+}
+
+# Given a directory name, DIR, if every entry in it that matches *.exe
+# contains only the specified bytes (see the case stmt below), then print
+# a space-separated list of those names and return 0.  Otherwise, don't
+# print anything and return 1.  Naming constraints apply also to DIR.
+find_exe_basenames_()
+{
+  feb_dir_=$1
+  feb_fail_=0
+  feb_result_=
+  feb_sp_=
+  for feb_file_ in $feb_dir_/*.exe; do
+    case $feb_file_ in
+      *[!-a-zA-Z/0-9_.+]*) feb_fail_=1; break;;
+      *) # Remove leading file name components as well as the .exe suffix.
+         feb_file_=${feb_file_##*/}
+         feb_file_=${feb_file_%.exe}
+         feb_result_="$feb_result_$feb_sp_$feb_file_";;
+    esac
+    feb_sp_=' '
+  done
+  test $feb_fail_ = 0 && printf %s "$feb_result_"
+  return $feb_fail_
+}
+
+# Consider the files in directory, $1.
+# For each file name of the form PROG.exe, create an alias named
+# PROG that simply invokes PROG.exe, then return 0.  If any selected
+# file name or the directory name, $1, contains an unexpected character,
+# define no function and return 1.
+create_exe_shims_()
+{
+  case $EXEEXT in
+    '') return 0 ;;
+    .exe) ;;
+    *) echo "$0: unexpected \$EXEEXT value: $EXEEXT" 1>&2; return 1 ;;
+  esac
+
+  base_names_=`find_exe_basenames_ $1` \
+    || { echo "$0 (exe_shim): skipping directory: $1" 1>&2; return 1; }
+
+  if test -n "$base_names_"; then
+    for base_ in $base_names_; do
+      alias "$base_"="$base_$EXEEXT"
+    done
+  fi
+
+  return 0
+}
+
+# Use this function to prepend to PATH an absolute name for each
+# specified, possibly-$initial_cwd_-relative, directory.
+path_prepend_()
+{
+  while test $# != 0; do
+    path_dir_=$1
+    case $path_dir_ in
+      '') fail_ "invalid path dir: '$1'";;
+      /*) abs_path_dir_=$path_dir_;;
+      *) abs_path_dir_=`cd "$initial_cwd_/$path_dir_" && echo "$PWD"` \
+           || fail_ "invalid path dir: $path_dir_";;
+    esac
+    case $abs_path_dir_ in
+      *:*) fail_ "invalid path dir: '$abs_path_dir_'";;
+    esac
+    PATH="$abs_path_dir_:$PATH"
+
+    # Create an alias, FOO, for each FOO.exe in this directory.
+    create_exe_shims_ "$abs_path_dir_" \
+      || fail_ "something failed (above): $abs_path_dir_"
+    shift
+  done
+  export PATH
+}
+
+setup_()
+{
+  test "$VERBOSE" = yes && set -x
+
+  initial_cwd_=$PWD
+
+  pfx_=`testdir_prefix_`
+  test_dir_=`mktempd_ "$initial_cwd_" "$pfx_-$ME_.XXXX"` \
+    || fail_ "failed to create temporary directory in $initial_cwd_"
+  cd "$test_dir_"
+
+  # These trap statements ensure that the temporary directory, $test_dir_,
+  # is removed upon exit as well as upon receipt of any of the listed signals.
+  trap remove_tmp_ 0
+  for sig_ in 1 2 3 13 15; do
+    eval "trap 'Exit $(expr $sig_ + 128)' $sig_"
+  done
+}
+
+# Create a temporary directory, much like mktemp -d does.
+# Written by Jim Meyering.
+#
+# Usage: mktempd_ /tmp phoey.XXXXXXXXXX
+#
+# First, try to use the mktemp program.
+# Failing that, we'll roll our own mktemp-like function:
+#  - try to get random bytes from /dev/urandom
+#  - failing that, generate output from a combination of quickly-varying
+#      sources and gzip.  Ignore non-varying gzip header, and extract
+#      "random" bits from there.
+#  - given those bits, map to file-name bytes using tr, and try to create
+#      the desired directory.
+#  - make only $MAX_TRIES_ attempts
+
+# Helper function.  Print $N pseudo-random bytes from a-zA-Z0-9.
+rand_bytes_()
+{
+  n_=$1
+
+  # Maybe try openssl rand -base64 $n_prime_|tr '+/=\012' abcd first?
+  # But if they have openssl, they probably have mktemp, too.
+
+  chars_=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
+  dev_rand_=/dev/urandom
+  if test -r "$dev_rand_"; then
+    # Note: 256-length($chars_) == 194; 3 copies of $chars_ is 186 + 8 = 194.
+    dd ibs=$n_ count=1 if=$dev_rand_ 2>/dev/null \
+      | LC_ALL=C tr -c $chars_ 01234567$chars_$chars_$chars_
+    return
+  fi
+
+  n_plus_50_=`expr $n_ + 50`
+  cmds_='date; date +%N; free; who -a; w; ps auxww; ps ef; netstat -n'
+  data_=` (eval "$cmds_") 2>&1 | gzip `
+
+  # Ensure that $data_ has length at least 50+$n_
+  while :; do
+    len_=`echo "$data_"|wc -c`
+    test $n_plus_50_ -le $len_ && break;
+    data_=` (echo "$data_"; eval "$cmds_") 2>&1 | gzip `
+  done
+
+  echo "$data_" \
+    | dd bs=1 skip=50 count=$n_ 2>/dev/null \
+    | LC_ALL=C tr -c $chars_ 01234567$chars_$chars_$chars_
+}
+
+mktempd_()
+{
+  case $# in
+  2);;
+  *) fail_ "Usage: $ME DIR TEMPLATE";;
+  esac
+
+  destdir_=$1
+  template_=$2
+
+  MAX_TRIES_=4
+
+  # Disallow any trailing slash on specified destdir:
+  # it would subvert the post-mktemp "case"-based destdir test.
+  case $destdir_ in
+  /) ;;
+  */) fail_ "invalid destination dir: remove trailing slash(es)";;
+  esac
+
+  case $template_ in
+  *XXXX) ;;
+  *) fail_ "invalid template: $template_ (must have a suffix of at least 4 X's)";;
+  esac
+
+  fail=0
+
+  # First, try to use mktemp.
+  d=`unset TMPDIR; mktemp -d -t -p "$destdir_" "$template_" 2>/dev/null` \
+    || fail=1
+
+  # The resulting name must be in the specified directory.
+  case $d in "$destdir_"*);; *) fail=1;; esac
+
+  # It must have created the directory.
+  test -d "$d" || fail=1
+
+  # It must have 0700 permissions.  Handle sticky "S" bits.
+  perms=`ls -dgo "$d" 2>/dev/null|tr S -` || fail=1
+  case $perms in drwx------*) ;; *) fail=1;; esac
+
+  test $fail = 0 && {
+    echo "$d"
+    return
+  }
+
+  # If we reach this point, we'll have to create a directory manually.
+
+  # Get a copy of the template without its suffix of X's.
+  base_template_=`echo "$template_"|sed 's/XX*$//'`
+
+  # Calculate how many X's we've just removed.
+  template_length_=`echo "$template_" | wc -c`
+  nx_=`echo "$base_template_" | wc -c`
+  nx_=`expr $template_length_ - $nx_`
+
+  err_=
+  i_=1
+  while :; do
+    X_=`rand_bytes_ $nx_`
+    candidate_dir_="$destdir_/$base_template_$X_"
+    err_=`mkdir -m 0700 "$candidate_dir_" 2>&1` \
+      && { echo "$candidate_dir_"; return; }
+    test $MAX_TRIES_ -le $i_ && break;
+    i_=`expr $i_ + 1`
+  done
+  fail_ "$err_"
+}
+
+# If you want to override the testdir_prefix_ function,
+# or to add more utility functions, use this file.
+test -f "$srcdir/init.cfg" \
+  && . "$srcdir/init.cfg"
+
+setup_ "$@"
--- /dev/null
+++ b/gltests/lstat.c
@@ -0,0 +1,91 @@
+/* Work around a bug of lstat on some systems
+
+   Copyright (C) 1997-2006, 2008-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* written by Jim Meyering */
+
+#include <config.h>
+
+#if !HAVE_LSTAT
+/* On systems that lack symlinks, our replacement <sys/stat.h> already
+   defined lstat as stat, so there is nothing further to do other than
+   avoid an empty file.  */
+typedef int dummy;
+#else /* HAVE_LSTAT */
+
+/* Get the original definition of lstat.  It might be defined as a macro.  */
+# define __need_system_sys_stat_h
+# include <sys/types.h>
+# include <sys/stat.h>
+# undef __need_system_sys_stat_h
+
+static inline int
+orig_lstat (const char *filename, struct stat *buf)
+{
+  return lstat (filename, buf);
+}
+
+/* Specification.  */
+# include <sys/stat.h>
+
+# include <string.h>
+# include <errno.h>
+
+/* lstat works differently on Linux and Solaris systems.  POSIX (see
+   `pathname resolution' in the glossary) requires that programs like
+   `ls' take into consideration the fact that FILE has a trailing slash
+   when FILE is a symbolic link.  On Linux and Solaris 10 systems, the
+   lstat function already has the desired semantics (in treating
+   `lstat ("symlink/", sbuf)' just like `lstat ("symlink/.", sbuf)',
+   but on Solaris 9 and earlier it does not.
+
+   If FILE has a trailing slash and specifies a symbolic link,
+   then use stat() to get more info on the referent of FILE.
+   If the referent is a non-directory, then set errno to ENOTDIR
+   and return -1.  Otherwise, return stat's result.  */
+
+int
+rpl_lstat (const char *file, struct stat *sbuf)
+{
+  size_t len;
+  int lstat_result = orig_lstat (file, sbuf);
+
+  if (lstat_result != 0)
+    return lstat_result;
+
+  /* This replacement file can blindly check against '/' rather than
+     using the ISSLASH macro, because all platforms with '\\' either
+     lack symlinks (mingw) or have working lstat (cygwin) and thus do
+     not compile this file.  0 len should have already been filtered
+     out above, with a failure return of ENOENT.  */
+  len = strlen (file);
+  if (file[len - 1] != '/' || S_ISDIR (sbuf->st_mode))
+    return 0;
+
+  /* At this point, a trailing slash is only permitted on
+     symlink-to-dir; but it should have found information on the
+     directory, not the symlink.  Call stat() to get info about the
+     link's referent.  Our replacement stat guarantees valid results,
+     even if the symlink is not pointing to a directory.  */
+  if (!S_ISLNK (sbuf->st_mode))
+    {
+      errno = ENOTDIR;
+      return -1;
+    }
+  return stat (file, sbuf);
+}
+
+#endif /* HAVE_LSTAT */
--- /dev/null
+++ b/gltests/macros.h
@@ -0,0 +1,64 @@
+/* Common macros used by gnulib tests.
+   Copyright (C) 2006-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+
+/* This file contains macros that are used by many gnulib tests.
+   Put here only frequently used macros, say, used by 10 tests or more.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* Define ASSERT_STREAM before including this file if ASSERT must
+   target a stream other than stderr.  */
+#ifndef ASSERT_STREAM
+# define ASSERT_STREAM stderr
+#endif
+
+/* ASSERT (condition);
+   verifies that the specified condition is fulfilled.  If not, a message
+   is printed to ASSERT_STREAM if defined (defaulting to stderr if
+   undefined) and the program is terminated with an error code.
+
+   This macro has the following properties:
+     - The programmer specifies the expected condition, not the failure
+       condition.  This simplifies thinking.
+     - The condition is tested always, regardless of compilation flags.
+       (Unlike the macro from <assert.h>.)
+     - On Unix platforms, the tester can debug the test program with a
+       debugger (provided core dumps are enabled: "ulimit -c unlimited").
+     - For the sake of platforms where no debugger is available (such as
+       some mingw systems), an error message is printed on the error
+       stream that includes the source location of the ASSERT invocation.
+ */
+#define ASSERT(expr) \
+  do                                                                         \
+    {                                                                        \
+      if (!(expr))                                                           \
+        {                                                                    \
+          fprintf (ASSERT_STREAM, "%s:%d: assertion failed\n",               \
+                   __FILE__, __LINE__);                                      \
+          fflush (ASSERT_STREAM);                                            \
+          abort ();                                                          \
+        }                                                                    \
+    }                                                                        \
+  while (0)
+
+/* SIZEOF (array)
+   returns the number of elements of an array.  It works for arrays that are
+   declared outside functions and for local variables of array type.  It does
+   *not* work for function parameters of array type, because they are actually
+   parameters of pointer type.  */
+#define SIZEOF(array) (sizeof (array) / sizeof (array[0]))
--- /dev/null
+++ b/gltests/malloc.c
@@ -0,0 +1,57 @@
+/* malloc() function that is glibc compatible.
+
+   Copyright (C) 1997-1998, 2006-2007, 2009-2010 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* written by Jim Meyering and Bruno Haible */
+
+#include <config.h>
+/* Only the AC_FUNC_MALLOC macro defines 'malloc' already in config.h.  */
+#ifdef malloc
+# define NEED_MALLOC_GNU
+# undef malloc
+#endif
+
+/* Specification.  */
+#include <stdlib.h>
+
+#include <errno.h>
+
+/* Call the system's malloc below.  */
+#undef malloc
+
+/* Allocate an N-byte block of memory from the heap.
+   If N is zero, allocate a 1-byte block.  */
+
+void *
+rpl_malloc (size_t n)
+{
+  void *result;
+
+#ifdef NEED_MALLOC_GNU
+  if (n == 0)
+    n = 1;
+#endif
+
+  result = malloc (n);
+
+#if !HAVE_MALLOC_POSIX
+  if (result == NULL)
+    errno = ENOMEM;
+#endif
+
+  return result;
+}
--- /dev/null
+++ b/gltests/malloca.c
@@ -0,0 +1,140 @@
+/* Safe automatic memory allocation.
+   Copyright (C) 2003, 2006-2007, 2009-2010 Free Software Foundation, Inc.
+   Written by Bruno Haible <bruno@clisp.org>, 2003.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include <config.h>
+
+/* Specification.  */
+#include "malloca.h"
+
+/* Use the system functions, not the gnulib overrides in this file.  */
+#undef malloc
+
+/* The speed critical point in this file is freea() applied to an alloca()
+   result: it must be fast, to match the speed of alloca().  The speed of
+   mmalloca() and freea() in the other case are not critical, because they
+   are only invoked for big memory sizes.  */
+
+#if HAVE_ALLOCA
+
+/* Store the mmalloca() results in a hash table.  This is needed to reliably
+   distinguish a mmalloca() result and an alloca() result.
+
+   Although it is possible that the same pointer is returned by alloca() and
+   by mmalloca() at different times in the same application, it does not lead
+   to a bug in freea(), because:
+     - Before a pointer returned by alloca() can point into malloc()ed memory,
+       the function must return, and once this has happened the programmer must
+       not call freea() on it anyway.
+     - Before a pointer returned by mmalloca() can point into the stack, it
+       must be freed.  The only function that can free it is freea(), and
+       when freea() frees it, it also removes it from the hash table.  */
+
+#define MAGIC_NUMBER 0x1415fb4a
+#define MAGIC_SIZE sizeof (int)
+/* This is how the header info would look like without any alignment
+   considerations.  */
+struct preliminary_header { void *next; char room[MAGIC_SIZE]; };
+/* But the header's size must be a multiple of sa_alignment_max.  */
+#define HEADER_SIZE \
+  (((sizeof (struct preliminary_header) + sa_alignment_max - 1) / sa_alignment_max) * sa_alignment_max)
+struct header { void *next; char room[HEADER_SIZE - sizeof (struct preliminary_header) + MAGIC_SIZE]; };
+/* Verify that HEADER_SIZE == sizeof (struct header).  */
+typedef int verify1[2 * (HEADER_SIZE == sizeof (struct header)) - 1];
+/* We make the hash table quite big, so that during lookups the probability
+   of empty hash buckets is quite high.  There is no need to make the hash
+   table resizable, because when the hash table gets filled so much that the
+   lookup becomes slow, it means that the application has memory leaks.  */
+#define HASH_TABLE_SIZE 257
+static void * mmalloca_results[HASH_TABLE_SIZE];
+
+#endif
+
+void *
+mmalloca (size_t n)
+{
+#if HAVE_ALLOCA
+  /* Allocate one more word, that serves as an indicator for malloc()ed
+     memory, so that freea() of an alloca() result is fast.  */
+  size_t nplus = n + HEADER_SIZE;
+
+  if (nplus >= n)
+    {
+      char *p = (char *) malloc (nplus);
+
+      if (p != NULL)
+        {
+          size_t slot;
+
+          p += HEADER_SIZE;
+
+          /* Put a magic number into the indicator word.  */
+          ((int *) p)[-1] = MAGIC_NUMBER;
+
+          /* Enter p into the hash table.  */
+          slot = (unsigned long) p % HASH_TABLE_SIZE;
+          ((struct header *) (p - HEADER_SIZE))->next = mmalloca_results[slot];
+          mmalloca_results[slot] = p;
+
+          return p;
+        }
+    }
+  /* Out of memory.  */
+  return NULL;
+#else
+# if !MALLOC_0_IS_NONNULL
+  if (n == 0)
+    n = 1;
+# endif
+  return malloc (n);
+#endif
+}
+
+#if HAVE_ALLOCA
+void
+freea (void *p)
+{
+  /* mmalloca() may have returned NULL.  */
+  if (p != NULL)
+    {
+      /* Attempt to quickly distinguish the mmalloca() result - which has
+         a magic indicator word - and the alloca() result - which has an
+         uninitialized indicator word.  It is for this test that sa_increment
+         additional bytes are allocated in the alloca() case.  */
+      if (((int *) p)[-1] == MAGIC_NUMBER)
+        {
+          /* Looks like a mmalloca() result.  To see whether it really is one,
+             perform a lookup in the hash table.  */
+          size_t slot = (unsigned long) p % HASH_TABLE_SIZE;
+          void **chain = &mmalloca_results[slot];
+          for (; *chain != NULL;)
+            {
+              if (*chain == p)
+                {
+                  /* Found it.  Remove it from the hash table and free it.  */
+                  char *p_begin = (char *) p - HEADER_SIZE;
+                  *chain = ((struct header *) p_begin)->next;
+                  free (p_begin);
+                  return;
+                }
+              chain = &((struct header *) ((char *) *chain - HEADER_SIZE))->next;
+            }
+        }
+      /* At this point, we know it was not a mmalloca() result.  */
+    }
+}
+#endif
--- /dev/null
+++ b/gltests/malloca.h
@@ -0,0 +1,134 @@
+/* Safe automatic memory allocation.
+   Copyright (C) 2003-2007, 2009-2010 Free Software Foundation, Inc.
+   Written by Bruno Haible <bruno@clisp.org>, 2003.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _MALLOCA_H
+#define _MALLOCA_H
+
+#include <alloca.h>
+#include <stddef.h>
+#include <stdlib.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* safe_alloca(N) is equivalent to alloca(N) when it is safe to call
+   alloca(N); otherwise it returns NULL.  It either returns N bytes of
+   memory allocated on the stack, that lasts until the function returns,
+   or NULL.
+   Use of safe_alloca should be avoided:
+     - inside arguments of function calls - undefined behaviour,
+     - in inline functions - the allocation may actually last until the
+       calling function returns.
+*/
+#if HAVE_ALLOCA
+/* The OS usually guarantees only one guard page at the bottom of the stack,
+   and a page size can be as small as 4096 bytes.  So we cannot safely
+   allocate anything larger than 4096 bytes.  Also care for the possibility
+   of a few compiler-allocated temporary stack slots.
+   This must be a macro, not an inline function.  */
+# define safe_alloca(N) ((N) < 4032 ? alloca (N) : NULL)
+#else
+# define safe_alloca(N) ((void) (N), NULL)
+#endif
+
+/* malloca(N) is a safe variant of alloca(N).  It allocates N bytes of
+   memory allocated on the stack, that must be freed using freea() before
+   the function returns.  Upon failure, it returns NULL.  */
+#if HAVE_ALLOCA
+# define malloca(N) \
+  ((N) < 4032 - sa_increment                                        \
+   ? (void *) ((char *) alloca ((N) + sa_increment) + sa_increment) \
+   : mmalloca (N))
+#else
+# define malloca(N) \
+  mmalloca (N)
+#endif
+extern void * mmalloca (size_t n);
+
+/* Free a block of memory allocated through malloca().  */
+#if HAVE_ALLOCA
+extern void freea (void *p);
+#else
+# define freea free
+#endif
+
+/* nmalloca(N,S) is an overflow-safe variant of malloca (N * S).
+   It allocates an array of N objects, each with S bytes of memory,
+   on the stack.  S must be positive and N must be nonnegative.
+   The array must be freed using freea() before the function returns.  */
+#if 1
+/* Cf. the definition of xalloc_oversized.  */
+# define nmalloca(n, s) \
+    ((n) > (size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) \
+     ? NULL \
+     : malloca ((n) * (s)))
+#else
+extern void * nmalloca (size_t n, size_t s);
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+/* ------------------- Auxiliary, non-public definitions ------------------- */
+
+/* Determine the alignment of a type at compile time.  */
+#if defined __GNUC__
+# define sa_alignof __alignof__
+#elif defined __cplusplus
+  template <class type> struct sa_alignof_helper { char __slot1; type __slot2; };
+# define sa_alignof(type) offsetof (sa_alignof_helper<type>, __slot2)
+#elif defined __hpux
+  /* Work around a HP-UX 10.20 cc bug with enums constants defined as offsetof
+     values.  */
+# define sa_alignof(type) (sizeof (type) <= 4 ? 4 : 8)
+#elif defined _AIX
+  /* Work around an AIX 3.2.5 xlc bug with enums constants defined as offsetof
+     values.  */
+# define sa_alignof(type) (sizeof (type) <= 4 ? 4 : 8)
+#else
+# define sa_alignof(type) offsetof (struct { char __slot1; type __slot2; }, __slot2)
+#endif
+
+enum
+{
+/* The desired alignment of memory allocations is the maximum alignment
+   among all elementary types.  */
+  sa_alignment_long = sa_alignof (long),
+  sa_alignment_double = sa_alignof (double),
+#if HAVE_LONG_LONG_INT
+  sa_alignment_longlong = sa_alignof (long long),
+#endif
+  sa_alignment_longdouble = sa_alignof (long double),
+  sa_alignment_max = ((sa_alignment_long - 1) | (sa_alignment_double - 1)
+#if HAVE_LONG_LONG_INT
+                      | (sa_alignment_longlong - 1)
+#endif
+                      | (sa_alignment_longdouble - 1)
+                     ) + 1,
+/* The increment that guarantees room for a magic word must be >= sizeof (int)
+   and a multiple of sa_alignment_max.  */
+  sa_increment = ((sizeof (int) + sa_alignment_max - 1) / sa_alignment_max) * sa_alignment_max
+};
+
+#endif /* _MALLOCA_H */
--- /dev/null
+++ b/gltests/malloca.valgrind
@@ -0,0 +1,7 @@
+# Suppress a valgrind message about use of uninitialized memory in freea().
+# This use is OK because it provides only a speedup.
+{
+    freea
+    Memcheck:Cond
+    fun:freea
+}
--- /dev/null
+++ b/gltests/open.c
@@ -0,0 +1,166 @@
+/* Open a descriptor to a file.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2007.  */
+
+#include <config.h>
+
+/* Get the original definition of open.  It might be defined as a macro.  */
+#define __need_system_fcntl_h
+#include <fcntl.h>
+#undef __need_system_fcntl_h
+#include <sys/types.h>
+
+static inline int
+orig_open (const char *filename, int flags, mode_t mode)
+{
+  return open (filename, flags, mode);
+}
+
+/* Specification.  */
+#include <fcntl.h>
+
+#include <errno.h>
+#include <stdarg.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#ifndef REPLACE_OPEN_DIRECTORY
+# define REPLACE_OPEN_DIRECTORY 0
+#endif
+
+int
+open (const char *filename, int flags, ...)
+{
+  mode_t mode;
+  int fd;
+
+  mode = 0;
+  if (flags & O_CREAT)
+    {
+      va_list arg;
+      va_start (arg, flags);
+
+      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4
+         creates crashing code when 'mode_t' is smaller than 'int'.  */
+      mode = va_arg (arg, PROMOTED_MODE_T);
+
+      va_end (arg);
+    }
+
+#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+  if (strcmp (filename, "/dev/null") == 0)
+    filename = "NUL";
+#endif
+
+#if OPEN_TRAILING_SLASH_BUG
+  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR
+     is specified, then fail.
+     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>
+     says that
+       "A pathname that contains at least one non-slash character and that
+        ends with one or more trailing slashes shall be resolved as if a
+        single dot character ( '.' ) were appended to the pathname."
+     and
+       "The special filename dot shall refer to the directory specified by
+        its predecessor."
+     If the named file already exists as a directory, then
+       - if O_CREAT is specified, open() must fail because of the semantics
+         of O_CREAT,
+       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX
+         <http://www.opengroup.org/susv3/functions/open.html> says that it
+         fails with errno = EISDIR in this case.
+     If the named file does not exist or does not name a directory, then
+       - if O_CREAT is specified, open() must fail since open() cannot create
+         directories,
+       - if O_WRONLY or O_RDWR is specified, open() must fail because the
+         file does not contain a '.' directory.  */
+  if (flags & (O_CREAT | O_WRONLY | O_RDWR))
+    {
+      size_t len = strlen (filename);
+      if (len > 0 && filename[len - 1] == '/')
+        {
+          errno = EISDIR;
+          return -1;
+        }
+    }
+#endif
+
+  fd = orig_open (filename, flags, mode);
+
+#if REPLACE_FCHDIR
+  /* Implementing fchdir and fdopendir requires the ability to open a
+     directory file descriptor.  If open doesn't support that (as on
+     mingw), we use a dummy file that behaves the same as directories
+     on Linux (ie. always reports EOF on attempts to read()), and
+     override fstat() in fchdir.c to hide the fact that we have a
+     dummy.  */
+  if (REPLACE_OPEN_DIRECTORY && fd < 0 && errno == EACCES
+      && (flags & O_ACCMODE) == O_RDONLY)
+    {
+      struct stat statbuf;
+      if (stat (filename, &statbuf) == 0 && S_ISDIR (statbuf.st_mode))
+        {
+          /* Maximum recursion depth of 1.  */
+          fd = open ("/dev/null", flags, mode);
+          if (0 <= fd)
+            fd = _gl_register_fd (fd, filename);
+        }
+      else
+        errno = EACCES;
+    }
+#endif
+
+#if OPEN_TRAILING_SLASH_BUG
+  /* If the filename ends in a slash and fd does not refer to a directory,
+     then fail.
+     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>
+     says that
+       "A pathname that contains at least one non-slash character and that
+        ends with one or more trailing slashes shall be resolved as if a
+        single dot character ( '.' ) were appended to the pathname."
+     and
+       "The special filename dot shall refer to the directory specified by
+        its predecessor."
+     If the named file without the slash is not a directory, open() must fail
+     with ENOTDIR.  */
+  if (fd >= 0)
+    {
+      /* We know len is positive, since open did not fail with ENOENT.  */
+      size_t len = strlen (filename);
+      if (filename[len - 1] == '/')
+        {
+          struct stat statbuf;
+
+          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))
+            {
+              close (fd);
+              errno = ENOTDIR;
+              return -1;
+            }
+        }
+    }
+#endif
+
+#if REPLACE_FCHDIR
+  if (!REPLACE_OPEN_DIRECTORY && 0 <= fd)
+    fd = _gl_register_fd (fd, filename);
+#endif
+
+  return fd;
+}
--- /dev/null
+++ b/gltests/pathmax.h
@@ -0,0 +1,48 @@
+/* Define PATH_MAX somehow.  Requires sys/types.h.
+   Copyright (C) 1992, 1999, 2001, 2003, 2005, 2009-2010 Free Software
+   Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _PATHMAX_H
+# define _PATHMAX_H
+
+# include <unistd.h>
+
+# include <limits.h>
+
+# ifndef _POSIX_PATH_MAX
+#  define _POSIX_PATH_MAX 256
+# endif
+
+# if !defined PATH_MAX && defined _PC_PATH_MAX && defined HAVE_PATHCONF
+#  define PATH_MAX (pathconf ("/", _PC_PATH_MAX) < 1 ? 1024 \
+                    : pathconf ("/", _PC_PATH_MAX))
+# endif
+
+/* Don't include sys/param.h if it already has been.  */
+# if defined HAVE_SYS_PARAM_H && !defined PATH_MAX && !defined MAXPATHLEN
+#  include <sys/param.h>
+# endif
+
+# if !defined PATH_MAX && defined MAXPATHLEN
+#  define PATH_MAX MAXPATHLEN
+# endif
+
+# ifndef PATH_MAX
+#  define PATH_MAX _POSIX_PATH_MAX
+# endif
+
+#endif /* _PATHMAX_H */
--- /dev/null
+++ b/gltests/putenv.c
@@ -0,0 +1,132 @@
+/* Copyright (C) 1991, 1994, 1997-1998, 2000, 2003-2010 Free Software
+   Foundation, Inc.
+
+   NOTE: The canonical source of this file is maintained with the GNU C
+   Library.  Bugs can be reported to bug-glibc@prep.ai.mit.edu.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 3 of the License, or any
+   later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+/* Specification.  */
+#include <stdlib.h>
+
+#include <stddef.h>
+
+/* Include errno.h *after* sys/types.h to work around header problems
+   on AIX 3.2.5.  */
+#include <errno.h>
+#ifndef __set_errno
+# define __set_errno(ev) ((errno) = (ev))
+#endif
+
+#include <string.h>
+#include <unistd.h>
+
+#if HAVE_GNU_LD
+# define environ __environ
+#else
+extern char **environ;
+#endif
+
+#if _LIBC
+/* This lock protects against simultaneous modifications of `environ'.  */
+# include <bits/libc-lock.h>
+__libc_lock_define_initialized (static, envlock)
+# define LOCK   __libc_lock_lock (envlock)
+# define UNLOCK __libc_lock_unlock (envlock)
+#else
+# define LOCK
+# define UNLOCK
+#endif
+
+static int
+_unsetenv (const char *name)
+{
+  size_t len;
+  char **ep;
+
+  if (name == NULL || *name == '\0' || strchr (name, '=') != NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  len = strlen (name);
+
+  LOCK;
+
+  ep = environ;
+  while (*ep != NULL)
+    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')
+      {
+        /* Found it.  Remove this pointer by moving later ones back.  */
+        char **dp = ep;
+
+        do
+          dp[0] = dp[1];
+        while (*dp++);
+        /* Continue the loop in case NAME appears again.  */
+      }
+    else
+      ++ep;
+
+  UNLOCK;
+
+  return 0;
+}
+
+
+/* Put STRING, which is of the form "NAME=VALUE", in the environment.
+   If STRING contains no `=', then remove STRING from the environment.  */
+int
+putenv (char *string)
+{
+  const char *const name_end = strchr (string, '=');
+  register size_t size;
+  register char **ep;
+
+  if (name_end == NULL)
+    {
+      /* Remove the variable from the environment.  */
+      return _unsetenv (string);
+    }
+
+  size = 0;
+  for (ep = environ; *ep != NULL; ++ep)
+    if (!strncmp (*ep, string, name_end - string) &&
+        (*ep)[name_end - string] == '=')
+      break;
+    else
+      ++size;
+
+  if (*ep == NULL)
+    {
+      static char **last_environ = NULL;
+      char **new_environ = (char **) malloc ((size + 2) * sizeof (char *));
+      if (new_environ == NULL)
+        return -1;
+      (void) memcpy ((void *) new_environ, (void *) environ,
+                     size * sizeof (char *));
+      new_environ[size] = (char *) string;
+      new_environ[size + 1] = NULL;
+      free (last_environ);
+      last_environ = new_environ;
+      environ = new_environ;
+    }
+  else
+    *ep = string;
+
+  return 0;
+}
--- /dev/null
+++ b/gltests/same-inode.h
@@ -0,0 +1,25 @@
+/* Determine whether two stat buffers refer to the same file.
+
+   Copyright (C) 2006, 2009-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef SAME_INODE_H
+# define SAME_INODE_H 1
+
+# define SAME_INODE(Stat_buf_1, Stat_buf_2) \
+   ((Stat_buf_1).st_ino == (Stat_buf_2).st_ino \
+    && (Stat_buf_1).st_dev == (Stat_buf_2).st_dev)
+
+#endif
--- /dev/null
+++ b/gltests/setenv.c
@@ -0,0 +1,390 @@
+/* Copyright (C) 1992, 1995-2003, 2005-2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#if !_LIBC
+# include <config.h>
+#endif
+
+/* Don't use __attribute__ __nonnull__ in this compilation unit.  Otherwise gcc
+   optimizes away the name == NULL test below.  */
+#define _GL_ARG_NONNULL(params)
+
+#include <alloca.h>
+
+/* Specification.  */
+#include <stdlib.h>
+
+#include <errno.h>
+#ifndef __set_errno
+# define __set_errno(ev) ((errno) = (ev))
+#endif
+
+#include <string.h>
+#if _LIBC || HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#if !_LIBC
+# include "malloca.h"
+#endif
+
+#if _LIBC || !HAVE_SETENV
+
+#if !_LIBC
+# define __environ      environ
+#endif
+
+#if _LIBC
+/* This lock protects against simultaneous modifications of `environ'.  */
+# include <bits/libc-lock.h>
+__libc_lock_define_initialized (static, envlock)
+# define LOCK   __libc_lock_lock (envlock)
+# define UNLOCK __libc_lock_unlock (envlock)
+#else
+# define LOCK
+# define UNLOCK
+#endif
+
+/* In the GNU C library we must keep the namespace clean.  */
+#ifdef _LIBC
+# define setenv __setenv
+# define clearenv __clearenv
+# define tfind __tfind
+# define tsearch __tsearch
+#else
+/* Use the system functions, not the gnulib overrides in this file.  */
+# undef malloc
+# undef realloc
+#endif
+
+/* In the GNU C library implementation we try to be more clever and
+   allow arbitrarily many changes of the environment given that the used
+   values are from a small set.  Outside glibc this will eat up all
+   memory after a while.  */
+#if defined _LIBC || (defined HAVE_SEARCH_H && defined HAVE_TSEARCH \
+                      && defined __GNUC__)
+# define USE_TSEARCH    1
+# include <search.h>
+typedef int (*compar_fn_t) (const void *, const void *);
+
+/* This is a pointer to the root of the search tree with the known
+   values.  */
+static void *known_values;
+
+# define KNOWN_VALUE(Str) \
+  ({                                                                          \
+    void *value = tfind (Str, &known_values, (compar_fn_t) strcmp);           \
+    value != NULL ? *(char **) value : NULL;                                  \
+  })
+# define STORE_VALUE(Str) \
+  tsearch (Str, &known_values, (compar_fn_t) strcmp)
+
+#else
+# undef USE_TSEARCH
+
+# define KNOWN_VALUE(Str) NULL
+# define STORE_VALUE(Str) do { } while (0)
+
+#endif
+
+
+/* If this variable is not a null pointer we allocated the current
+   environment.  */
+static char **last_environ;
+
+
+/* This function is used by `setenv' and `putenv'.  The difference between
+   the two functions is that for the former must create a new string which
+   is then placed in the environment, while the argument of `putenv'
+   must be used directly.  This is all complicated by the fact that we try
+   to reuse values once generated for a `setenv' call since we can never
+   free the strings.  */
+int
+__add_to_environ (const char *name, const char *value, const char *combined,
+                  int replace)
+{
+  char **ep;
+  size_t size;
+  const size_t namelen = strlen (name);
+  const size_t vallen = value != NULL ? strlen (value) + 1 : 0;
+
+  LOCK;
+
+  /* We have to get the pointer now that we have the lock and not earlier
+     since another thread might have created a new environment.  */
+  ep = __environ;
+
+  size = 0;
+  if (ep != NULL)
+    {
+      for (; *ep != NULL; ++ep)
+        if (!strncmp (*ep, name, namelen) && (*ep)[namelen] == '=')
+          break;
+        else
+          ++size;
+    }
+
+  if (ep == NULL || *ep == NULL)
+    {
+      char **new_environ;
+#ifdef USE_TSEARCH
+      char *new_value;
+#endif
+
+      /* We allocated this space; we can extend it.  */
+      new_environ =
+        (char **) (last_environ == NULL
+                   ? malloc ((size + 2) * sizeof (char *))
+                   : realloc (last_environ, (size + 2) * sizeof (char *)));
+      if (new_environ == NULL)
+        {
+          /* It's easier to set errno to ENOMEM than to rely on the
+             'malloc-posix' and 'realloc-posix' gnulib modules.  */
+          __set_errno (ENOMEM);
+          UNLOCK;
+          return -1;
+        }
+
+      /* If the whole entry is given add it.  */
+      if (combined != NULL)
+        /* We must not add the string to the search tree since it belongs
+           to the user.  */
+        new_environ[size] = (char *) combined;
+      else
+        {
+          /* See whether the value is already known.  */
+#ifdef USE_TSEARCH
+# ifdef _LIBC
+          new_value = (char *) alloca (namelen + 1 + vallen);
+          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), "=", 1),
+                     value, vallen);
+# else
+          new_value = (char *) malloca (namelen + 1 + vallen);
+          if (new_value == NULL)
+            {
+              __set_errno (ENOMEM);
+              UNLOCK;
+              return -1;
+            }
+          memcpy (new_value, name, namelen);
+          new_value[namelen] = '=';
+          memcpy (&new_value[namelen + 1], value, vallen);
+# endif
+
+          new_environ[size] = KNOWN_VALUE (new_value);
+          if (new_environ[size] == NULL)
+#endif
+            {
+              new_environ[size] = (char *) malloc (namelen + 1 + vallen);
+              if (new_environ[size] == NULL)
+                {
+#if defined USE_TSEARCH && !defined _LIBC
+                  freea (new_value);
+#endif
+                  __set_errno (ENOMEM);
+                  UNLOCK;
+                  return -1;
+                }
+
+#ifdef USE_TSEARCH
+              memcpy (new_environ[size], new_value, namelen + 1 + vallen);
+#else
+              memcpy (new_environ[size], name, namelen);
+              new_environ[size][namelen] = '=';
+              memcpy (&new_environ[size][namelen + 1], value, vallen);
+#endif
+              /* And save the value now.  We cannot do this when we remove
+                 the string since then we cannot decide whether it is a
+                 user string or not.  */
+              STORE_VALUE (new_environ[size]);
+            }
+#if defined USE_TSEARCH && !defined _LIBC
+          freea (new_value);
+#endif
+        }
+
+      if (__environ != last_environ)
+        memcpy ((char *) new_environ, (char *) __environ,
+                size * sizeof (char *));
+
+      new_environ[size + 1] = NULL;
+
+      last_environ = __environ = new_environ;
+    }
+  else if (replace)
+    {
+      char *np;
+
+      /* Use the user string if given.  */
+      if (combined != NULL)
+        np = (char *) combined;
+      else
+        {
+#ifdef USE_TSEARCH
+          char *new_value;
+# ifdef _LIBC
+          new_value = alloca (namelen + 1 + vallen);
+          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), "=", 1),
+                     value, vallen);
+# else
+          new_value = malloca (namelen + 1 + vallen);
+          if (new_value == NULL)
+            {
+              __set_errno (ENOMEM);
+              UNLOCK;
+              return -1;
+            }
+          memcpy (new_value, name, namelen);
+          new_value[namelen] = '=';
+          memcpy (&new_value[namelen + 1], value, vallen);
+# endif
+
+          np = KNOWN_VALUE (new_value);
+          if (np == NULL)
+#endif
+            {
+              np = (char *) malloc (namelen + 1 + vallen);
+              if (np == NULL)
+                {
+#if defined USE_TSEARCH && !defined _LIBC
+                  freea (new_value);
+#endif
+                  __set_errno (ENOMEM);
+                  UNLOCK;
+                  return -1;
+                }
+
+#ifdef USE_TSEARCH
+              memcpy (np, new_value, namelen + 1 + vallen);
+#else
+              memcpy (np, name, namelen);
+              np[namelen] = '=';
+              memcpy (&np[namelen + 1], value, vallen);
+#endif
+              /* And remember the value.  */
+              STORE_VALUE (np);
+            }
+#if defined USE_TSEARCH && !defined _LIBC
+          freea (new_value);
+#endif
+        }
+
+      *ep = np;
+    }
+
+  UNLOCK;
+
+  return 0;
+}
+
+int
+setenv (const char *name, const char *value, int replace)
+{
+  if (name == NULL || *name == '\0' || strchr (name, '=') != NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  return __add_to_environ (name, value, NULL, replace);
+}
+
+/* The `clearenv' was planned to be added to POSIX.1 but probably
+   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings
+   for Fortran 77) requires this function.  */
+int
+clearenv (void)
+{
+  LOCK;
+
+  if (__environ == last_environ && __environ != NULL)
+    {
+      /* We allocated this environment so we can free it.  */
+      free (__environ);
+      last_environ = NULL;
+    }
+
+  /* Clear the environment pointer removes the whole environment.  */
+  __environ = NULL;
+
+  UNLOCK;
+
+  return 0;
+}
+
+#ifdef _LIBC
+static void
+free_mem (void)
+{
+  /* Remove all traces.  */
+  clearenv ();
+
+  /* Now remove the search tree.  */
+  __tdestroy (known_values, free);
+  known_values = NULL;
+}
+text_set_element (__libc_subfreeres, free_mem);
+
+
+# undef setenv
+# undef clearenv
+weak_alias (__setenv, setenv)
+weak_alias (__clearenv, clearenv)
+#endif
+
+#endif /* _LIBC || !HAVE_SETENV */
+
+/* The rest of this file is called into use when replacing an existing
+   but buggy setenv.  Known bugs include failure to diagnose invalid
+   name, and consuming a leading '=' from value.  */
+#if HAVE_SETENV
+
+# undef setenv
+# define STREQ(a, b) (strcmp (a, b) == 0)
+
+int
+rpl_setenv (const char *name, const char *value, int replace)
+{
+  int result;
+  if (!name || !*name || strchr (name, '='))
+    {
+      errno = EINVAL;
+      return -1;
+    }
+  /* Call the real setenv even if replace is 0, in case implementation
+     has underlying data to update, such as when environ changes.  */
+  result = setenv (name, value, replace);
+  if (result == 0 && replace && *value == '=')
+    {
+      char *tmp = getenv (name);
+      if (!STREQ (tmp, value))
+        {
+          int saved_errno;
+          size_t len = strlen (value);
+          tmp = malloca (len + 2);
+          /* Since leading '=' is eaten, double it up.  */
+          *tmp = '=';
+          memcpy (tmp + 1, value, len + 1);
+          result = setenv (name, tmp, replace);
+          saved_errno = errno;
+          freea (tmp);
+          errno = saved_errno;
+        }
+    }
+  return result;
+}
+
+#endif /* HAVE_SETENV */
--- /dev/null
+++ b/gltests/signature.h
@@ -0,0 +1,48 @@
+/* Macro for checking that a function declaration is compliant.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef SIGNATURE_CHECK
+
+/* Check that the function FN takes the specified arguments ARGS with
+   a return type of RET.  This header is designed to be included after
+   <config.h> and the one system header that is supposed to contain
+   the function being checked, but prior to any other system headers
+   that are necessary for the unit test.  Therefore, this file does
+   not include any system headers, nor reference anything outside of
+   the macro arguments.  For an example, if foo.h should provide:
+
+   extern int foo (char, float);
+
+   then the unit test named test-foo.c would start out with:
+
+   #include <config.h>
+   #include <foo.h>
+   #include "signature.h"
+   SIGNATURE_CHECK (foo, int, (char, float));
+   #include <other.h>
+   ...
+*/
+# define SIGNATURE_CHECK(fn, ret, args) \
+  SIGNATURE_CHECK1 (fn, ret, args, __LINE__)
+
+/* Necessary to allow multiple SIGNATURE_CHECK lines in a unit test.
+   Note that the checks must not occupy the same line.  */
+# define SIGNATURE_CHECK1(fn, ret, args, id) \
+  SIGNATURE_CHECK2 (fn, ret, args, id) /* macroexpand line */
+# define SIGNATURE_CHECK2(fn, ret, args, id) \
+  static ret (* _GL_UNUSED signature_check ## id) args = fn
+
+#endif /* SIGNATURE_CHECK */
--- /dev/null
+++ b/gltests/stat.c
@@ -0,0 +1,104 @@
+/* Work around platform bugs in stat.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* written by Eric Blake */
+
+#include <config.h>
+
+/* Get the original definition of stat.  It might be defined as a macro.  */
+#define __need_system_sys_stat_h
+#include <sys/types.h>
+#include <sys/stat.h>
+#undef __need_system_sys_stat_h
+
+static inline int
+orig_stat (const char *filename, struct stat *buf)
+{
+  return stat (filename, buf);
+}
+
+/* Specification.  */
+#include <sys/stat.h>
+
+#include <errno.h>
+#include <limits.h>
+#include <stdbool.h>
+#include <string.h>
+
+/* Store information about NAME into ST.  Work around bugs with
+   trailing slashes.  Mingw has other bugs (such as st_ino always
+   being 0 on success) which this wrapper does not work around.  But
+   at least this implementation provides the ability to emulate fchdir
+   correctly.  */
+
+int
+rpl_stat (char const *name, struct stat *st)
+{
+  int result = orig_stat (name, st);
+#if REPLACE_FUNC_STAT_FILE
+  /* Solaris 9 mistakenly succeeds when given a non-directory with a
+     trailing slash.  */
+  if (result == 0 && !S_ISDIR (st->st_mode))
+    {
+      size_t len = strlen (name);
+      if (ISSLASH (name[len - 1]))
+        {
+          errno = ENOTDIR;
+          return -1;
+        }
+    }
+#endif /* REPLACE_FUNC_STAT_FILE */
+#if REPLACE_FUNC_STAT_DIR
+  if (result == -1 && errno == ENOENT)
+    {
+      /* Due to mingw's oddities, there are some directories (like
+         c:\) where stat() only succeeds with a trailing slash, and
+         other directories (like c:\windows) where stat() only
+         succeeds without a trailing slash.  But we want the two to be
+         synonymous, since chdir() manages either style.  Likewise, Mingw also
+         reports ENOENT for names longer than PATH_MAX, when we want
+         ENAMETOOLONG, and for stat("file/"), when we want ENOTDIR.
+         Fortunately, mingw PATH_MAX is small enough for stack
+         allocation.  */
+      char fixed_name[PATH_MAX + 1] = {0};
+      size_t len = strlen (name);
+      bool check_dir = false;
+      if (PATH_MAX <= len)
+        errno = ENAMETOOLONG;
+      else if (len)
+        {
+          strcpy (fixed_name, name);
+          if (ISSLASH (fixed_name[len - 1]))
+            {
+              check_dir = true;
+              while (len && ISSLASH (fixed_name[len - 1]))
+                fixed_name[--len] = '\0';
+              if (!len)
+                fixed_name[0] = '/';
+            }
+          else
+            fixed_name[len++] = '/';
+          result = orig_stat (fixed_name, st);
+          if (result == 0 && check_dir && !S_ISDIR (st->st_mode))
+            {
+              result = -1;
+              errno = ENOTDIR;
+            }
+        }
+    }
+#endif /* REPLACE_FUNC_STAT_DIR */
+  return result;
+}
--- /dev/null
+++ b/gltests/stdbool.in.h
@@ -0,0 +1,122 @@
+/* Copyright (C) 2001-2003, 2006-2010 Free Software Foundation, Inc.
+   Written by Bruno Haible <haible@clisp.cons.org>, 2001.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _GL_STDBOOL_H
+#define _GL_STDBOOL_H
+
+/* ISO C 99 <stdbool.h> for platforms that lack it.  */
+
+/* Usage suggestions:
+
+   Programs that use <stdbool.h> should be aware of some limitations
+   and standards compliance issues.
+
+   Standards compliance:
+
+       - <stdbool.h> must be #included before 'bool', 'false', 'true'
+         can be used.
+
+       - You cannot assume that sizeof (bool) == 1.
+
+       - Programs should not undefine the macros bool, true, and false,
+         as C99 lists that as an "obsolescent feature".
+
+   Limitations of this substitute, when used in a C89 environment:
+
+       - <stdbool.h> must be #included before the '_Bool' type can be used.
+
+       - You cannot assume that _Bool is a typedef; it might be a macro.
+
+       - Bit-fields of type 'bool' are not supported.  Portable code
+         should use 'unsigned int foo : 1;' rather than 'bool foo : 1;'.
+
+       - In C99, casts and automatic conversions to '_Bool' or 'bool' are
+         performed in such a way that every nonzero value gets converted
+         to 'true', and zero gets converted to 'false'.  This doesn't work
+         with this substitute.  With this substitute, only the values 0 and 1
+         give the expected result when converted to _Bool' or 'bool'.
+
+       - C99 allows the use of (_Bool)0.0 in constant expressions, but
+         this substitute cannot always provide this property.
+
+   Also, it is suggested that programs use 'bool' rather than '_Bool';
+   this isn't required, but 'bool' is more common.  */
+
+
+/* 7.16. Boolean type and values */
+
+/* BeOS <sys/socket.h> already #defines false 0, true 1.  We use the same
+   definitions below, but temporarily we have to #undef them.  */
+#if defined __BEOS__ && !defined __HAIKU__
+# include <OS.h> /* defines bool but not _Bool */
+# undef false
+# undef true
+#endif
+
+/* For the sake of symbolic names in gdb, we define true and false as
+   enum constants, not only as macros.
+   It is tempting to write
+      typedef enum { false = 0, true = 1 } _Bool;
+   so that gdb prints values of type 'bool' symbolically. But if we do
+   this, values of type '_Bool' may promote to 'int' or 'unsigned int'
+   (see ISO C 99 6.7.2.2.(4)); however, '_Bool' must promote to 'int'
+   (see ISO C 99 6.3.1.1.(2)).  So we add a negative value to the
+   enum; this ensures that '_Bool' promotes to 'int'.  */
+#if defined __cplusplus || (defined __BEOS__ && !defined __HAIKU__)
+  /* A compiler known to have 'bool'.  */
+  /* If the compiler already has both 'bool' and '_Bool', we can assume they
+     are the same types.  */
+# if !@HAVE__BOOL@
+typedef bool _Bool;
+# endif
+#else
+# if !defined __GNUC__
+   /* If @HAVE__BOOL@:
+        Some HP-UX cc and AIX IBM C compiler versions have compiler bugs when
+        the built-in _Bool type is used.  See
+          http://gcc.gnu.org/ml/gcc-patches/2003-12/msg02303.html
+          http://lists.gnu.org/archive/html/bug-coreutils/2005-11/msg00161.html
+          http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html
+        Similar bugs are likely with other compilers as well; this file
+        wouldn't be used if <stdbool.h> was working.
+        So we override the _Bool type.
+      If !@HAVE__BOOL@:
+        Need to define _Bool ourselves. As 'signed char' or as an enum type?
+        Use of a typedef, with SunPRO C, leads to a stupid
+          "warning: _Bool is a keyword in ISO C99".
+        Use of an enum type, with IRIX cc, leads to a stupid
+          "warning(1185): enumerated type mixed with another type".
+        Even the existence of an enum type, without a typedef,
+          "Invalid enumerator. (badenum)" with HP-UX cc on Tru64.
+        The only benefit of the enum, debuggability, is not important
+        with these compilers.  So use 'signed char' and no enum.  */
+#  define _Bool signed char
+# else
+   /* With this compiler, trust the _Bool type if the compiler has it.  */
+#  if !@HAVE__BOOL@
+typedef enum { _Bool_must_promote_to_int = -1, false = 0, true = 1 } _Bool;
+#  endif
+# endif
+#endif
+#define bool _Bool
+
+/* The other macros must be usable in preprocessor directives.  */
+#define false 0
+#define true 1
+#define __bool_true_false_are_defined 1
+
+#endif /* _GL_STDBOOL_H */
--- /dev/null
+++ b/gltests/stdint.in.h
@@ -0,0 +1,568 @@
+/* Copyright (C) 2001-2002, 2004-2010 Free Software Foundation, Inc.
+   Written by Paul Eggert, Bruno Haible, Sam Steingold, Peter Burwood.
+   This file is part of gnulib.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/*
+ * ISO C 99 <stdint.h> for platforms that lack it.
+ * <http://www.opengroup.org/susv3xbd/stdint.h.html>
+ */
+
+#ifndef _GL_STDINT_H
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+/* When including a system file that in turn includes <inttypes.h>,
+   use the system <inttypes.h>, not our substitute.  This avoids
+   problems with (for example) VMS, whose <sys/bitypes.h> includes
+   <inttypes.h>.  */
+#define _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H
+
+/* Get those types that are already defined in other system include
+   files, so that we can "#define int8_t signed char" below without
+   worrying about a later system include file containing a "typedef
+   signed char int8_t;" that will get messed up by our macro.  Our
+   macros should all be consistent with the system versions, except
+   for the "fast" types and macros, which we recommend against using
+   in public interfaces due to compiler differences.  */
+
+#if @HAVE_STDINT_H@
+# if defined __sgi && ! defined __c99
+   /* Bypass IRIX's <stdint.h> if in C89 mode, since it merely annoys users
+      with "This header file is to be used only for c99 mode compilations"
+      diagnostics.  */
+#  define __STDINT_H__
+# endif
+  /* Other systems may have an incomplete or buggy <stdint.h>.
+     Include it before <inttypes.h>, since any "#include <stdint.h>"
+     in <inttypes.h> would reinclude us, skipping our contents because
+     _GL_STDINT_H is defined.
+     The include_next requires a split double-inclusion guard.  */
+# @INCLUDE_NEXT@ @NEXT_STDINT_H@
+#endif
+
+#if ! defined _GL_STDINT_H && ! defined _GL_JUST_INCLUDE_SYSTEM_STDINT_H
+#define _GL_STDINT_H
+
+/* <sys/types.h> defines some of the stdint.h types as well, on glibc,
+   IRIX 6.5, and OpenBSD 3.8 (via <machine/types.h>).
+   AIX 5.2 <sys/types.h> isn't needed and causes troubles.
+   MacOS X 10.4.6 <sys/types.h> includes <stdint.h> (which is us), but
+   relies on the system <stdint.h> definitions, so include
+   <sys/types.h> after @NEXT_STDINT_H@.  */
+#if @HAVE_SYS_TYPES_H@ && ! defined _AIX
+# include <sys/types.h>
+#endif
+
+/* Get LONG_MIN, LONG_MAX, ULONG_MAX.  */
+#include <limits.h>
+
+#if @HAVE_INTTYPES_H@
+  /* In OpenBSD 3.8, <inttypes.h> includes <machine/types.h>, which defines
+     int{8,16,32,64}_t, uint{8,16,32,64}_t and __BIT_TYPES_DEFINED__.
+     <inttypes.h> also defines intptr_t and uintptr_t.  */
+# include <inttypes.h>
+#elif @HAVE_SYS_INTTYPES_H@
+  /* Solaris 7 <sys/inttypes.h> has the types except the *_fast*_t types, and
+     the macros except for *_FAST*_*, INTPTR_MIN, PTRDIFF_MIN, PTRDIFF_MAX.  */
+# include <sys/inttypes.h>
+#endif
+
+#if @HAVE_SYS_BITYPES_H@ && ! defined __BIT_TYPES_DEFINED__
+  /* Linux libc4 >= 4.6.7 and libc5 have a <sys/bitypes.h> that defines
+     int{8,16,32,64}_t and __BIT_TYPES_DEFINED__.  In libc5 >= 5.2.2 it is
+     included by <sys/types.h>.  */
+# include <sys/bitypes.h>
+#endif
+
+#undef _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H
+
+/* Minimum and maximum values for a integer type under the usual assumption.
+   Return an unspecified value if BITS == 0, adding a check to pacify
+   picky compilers.  */
+
+#define _STDINT_MIN(signed, bits, zero) \
+  ((signed) ? (- ((zero) + 1) << ((bits) ? (bits) - 1 : 0)) : (zero))
+
+#define _STDINT_MAX(signed, bits, zero) \
+  ((signed) \
+   ? ~ _STDINT_MIN (signed, bits, zero) \
+   : /* The expression for the unsigned case.  The subtraction of (signed) \
+        is a nop in the unsigned case and avoids "signed integer overflow" \
+        warnings in the signed case.  */ \
+     ((((zero) + 1) << ((bits) ? (bits) - 1 - (signed) : 0)) - 1) * 2 + 1)
+
+/* 7.18.1.1. Exact-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits.  */
+
+#undef int8_t
+#undef uint8_t
+typedef signed char gl_int8_t;
+typedef unsigned char gl_uint8_t;
+#define int8_t gl_int8_t
+#define uint8_t gl_uint8_t
+
+#undef int16_t
+#undef uint16_t
+typedef short int gl_int16_t;
+typedef unsigned short int gl_uint16_t;
+#define int16_t gl_int16_t
+#define uint16_t gl_uint16_t
+
+#undef int32_t
+#undef uint32_t
+typedef int gl_int32_t;
+typedef unsigned int gl_uint32_t;
+#define int32_t gl_int32_t
+#define uint32_t gl_uint32_t
+
+/* Do not undefine int64_t if gnulib is not being used with 64-bit
+   types, since otherwise it breaks platforms like Tandem/NSK.  */
+#if LONG_MAX >> 31 >> 31 == 1
+# undef int64_t
+typedef long int gl_int64_t;
+# define int64_t gl_int64_t
+# define GL_INT64_T
+#elif defined _MSC_VER
+# undef int64_t
+typedef __int64 gl_int64_t;
+# define int64_t gl_int64_t
+# define GL_INT64_T
+#elif @HAVE_LONG_LONG_INT@
+# undef int64_t
+typedef long long int gl_int64_t;
+# define int64_t gl_int64_t
+# define GL_INT64_T
+#endif
+
+#if ULONG_MAX >> 31 >> 31 >> 1 == 1
+# undef uint64_t
+typedef unsigned long int gl_uint64_t;
+# define uint64_t gl_uint64_t
+# define GL_UINT64_T
+#elif defined _MSC_VER
+# undef uint64_t
+typedef unsigned __int64 gl_uint64_t;
+# define uint64_t gl_uint64_t
+# define GL_UINT64_T
+#elif @HAVE_UNSIGNED_LONG_LONG_INT@
+# undef uint64_t
+typedef unsigned long long int gl_uint64_t;
+# define uint64_t gl_uint64_t
+# define GL_UINT64_T
+#endif
+
+/* Avoid collision with Solaris 2.5.1 <pthread.h> etc.  */
+#define _UINT8_T
+#define _UINT32_T
+#define _UINT64_T
+
+
+/* 7.18.1.2. Minimum-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits. Therefore the leastN_t types
+   are the same as the corresponding N_t types.  */
+
+#undef int_least8_t
+#undef uint_least8_t
+#undef int_least16_t
+#undef uint_least16_t
+#undef int_least32_t
+#undef uint_least32_t
+#undef int_least64_t
+#undef uint_least64_t
+#define int_least8_t int8_t
+#define uint_least8_t uint8_t
+#define int_least16_t int16_t
+#define uint_least16_t uint16_t
+#define int_least32_t int32_t
+#define uint_least32_t uint32_t
+#ifdef GL_INT64_T
+# define int_least64_t int64_t
+#endif
+#ifdef GL_UINT64_T
+# define uint_least64_t uint64_t
+#endif
+
+/* 7.18.1.3. Fastest minimum-width integer types */
+
+/* Note: Other <stdint.h> substitutes may define these types differently.
+   It is not recommended to use these types in public header files. */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits. Therefore the fastN_t types
+   are taken from the same list of types.  Assume that 'long int'
+   is fast enough for all narrower integers.  */
+
+#undef int_fast8_t
+#undef uint_fast8_t
+#undef int_fast16_t
+#undef uint_fast16_t
+#undef int_fast32_t
+#undef uint_fast32_t
+#undef int_fast64_t
+#undef uint_fast64_t
+typedef long int gl_int_fast8_t;
+typedef unsigned long int gl_uint_fast8_t;
+typedef long int gl_int_fast16_t;
+typedef unsigned long int gl_uint_fast16_t;
+typedef long int gl_int_fast32_t;
+typedef unsigned long int gl_uint_fast32_t;
+#define int_fast8_t gl_int_fast8_t
+#define uint_fast8_t gl_uint_fast8_t
+#define int_fast16_t gl_int_fast16_t
+#define uint_fast16_t gl_uint_fast16_t
+#define int_fast32_t gl_int_fast32_t
+#define uint_fast32_t gl_uint_fast32_t
+#ifdef GL_INT64_T
+# define int_fast64_t int64_t
+#endif
+#ifdef GL_UINT64_T
+# define uint_fast64_t uint64_t
+#endif
+
+/* 7.18.1.4. Integer types capable of holding object pointers */
+
+#undef intptr_t
+#undef uintptr_t
+typedef long int gl_intptr_t;
+typedef unsigned long int gl_uintptr_t;
+#define intptr_t gl_intptr_t
+#define uintptr_t gl_uintptr_t
+
+/* 7.18.1.5. Greatest-width integer types */
+
+/* Note: These types are compiler dependent. It may be unwise to use them in
+   public header files. */
+
+#undef intmax_t
+#if @HAVE_LONG_LONG_INT@ && LONG_MAX >> 30 == 1
+typedef long long int gl_intmax_t;
+# define intmax_t gl_intmax_t
+#elif defined GL_INT64_T
+# define intmax_t int64_t
+#else
+typedef long int gl_intmax_t;
+# define intmax_t gl_intmax_t
+#endif
+
+#undef uintmax_t
+#if @HAVE_UNSIGNED_LONG_LONG_INT@ && ULONG_MAX >> 31 == 1
+typedef unsigned long long int gl_uintmax_t;
+# define uintmax_t gl_uintmax_t
+#elif defined GL_UINT64_T
+# define uintmax_t uint64_t
+#else
+typedef unsigned long int gl_uintmax_t;
+# define uintmax_t gl_uintmax_t
+#endif
+
+/* Verify that intmax_t and uintmax_t have the same size.  Too much code
+   breaks if this is not the case.  If this check fails, the reason is likely
+   to be found in the autoconf macros.  */
+typedef int _verify_intmax_size[2 * (sizeof (intmax_t) == sizeof (uintmax_t)) - 1];
+
+/* 7.18.2. Limits of specified-width integer types */
+
+#if ! defined __cplusplus || defined __STDC_LIMIT_MACROS
+
+/* 7.18.2.1. Limits of exact-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits.  */
+
+#undef INT8_MIN
+#undef INT8_MAX
+#undef UINT8_MAX
+#define INT8_MIN  (~ INT8_MAX)
+#define INT8_MAX  127
+#define UINT8_MAX  255
+
+#undef INT16_MIN
+#undef INT16_MAX
+#undef UINT16_MAX
+#define INT16_MIN  (~ INT16_MAX)
+#define INT16_MAX  32767
+#define UINT16_MAX  65535
+
+#undef INT32_MIN
+#undef INT32_MAX
+#undef UINT32_MAX
+#define INT32_MIN  (~ INT32_MAX)
+#define INT32_MAX  2147483647
+#define UINT32_MAX  4294967295U
+
+#undef INT64_MIN
+#undef INT64_MAX
+#ifdef GL_INT64_T
+/* Prefer (- INTMAX_C (1) << 63) over (~ INT64_MAX) because SunPRO C 5.0
+   evaluates the latter incorrectly in preprocessor expressions.  */
+# define INT64_MIN  (- INTMAX_C (1) << 63)
+# define INT64_MAX  INTMAX_C (9223372036854775807)
+#endif
+
+#undef UINT64_MAX
+#ifdef GL_UINT64_T
+# define UINT64_MAX  UINTMAX_C (18446744073709551615)
+#endif
+
+/* 7.18.2.2. Limits of minimum-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits. Therefore the leastN_t types
+   are the same as the corresponding N_t types.  */
+
+#undef INT_LEAST8_MIN
+#undef INT_LEAST8_MAX
+#undef UINT_LEAST8_MAX
+#define INT_LEAST8_MIN  INT8_MIN
+#define INT_LEAST8_MAX  INT8_MAX
+#define UINT_LEAST8_MAX  UINT8_MAX
+
+#undef INT_LEAST16_MIN
+#undef INT_LEAST16_MAX
+#undef UINT_LEAST16_MAX
+#define INT_LEAST16_MIN  INT16_MIN
+#define INT_LEAST16_MAX  INT16_MAX
+#define UINT_LEAST16_MAX  UINT16_MAX
+
+#undef INT_LEAST32_MIN
+#undef INT_LEAST32_MAX
+#undef UINT_LEAST32_MAX
+#define INT_LEAST32_MIN  INT32_MIN
+#define INT_LEAST32_MAX  INT32_MAX
+#define UINT_LEAST32_MAX  UINT32_MAX
+
+#undef INT_LEAST64_MIN
+#undef INT_LEAST64_MAX
+#ifdef GL_INT64_T
+# define INT_LEAST64_MIN  INT64_MIN
+# define INT_LEAST64_MAX  INT64_MAX
+#endif
+
+#undef UINT_LEAST64_MAX
+#ifdef GL_UINT64_T
+# define UINT_LEAST64_MAX  UINT64_MAX
+#endif
+
+/* 7.18.2.3. Limits of fastest minimum-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits. Therefore the fastN_t types
+   are taken from the same list of types.  */
+
+#undef INT_FAST8_MIN
+#undef INT_FAST8_MAX
+#undef UINT_FAST8_MAX
+#define INT_FAST8_MIN  LONG_MIN
+#define INT_FAST8_MAX  LONG_MAX
+#define UINT_FAST8_MAX  ULONG_MAX
+
+#undef INT_FAST16_MIN
+#undef INT_FAST16_MAX
+#undef UINT_FAST16_MAX
+#define INT_FAST16_MIN  LONG_MIN
+#define INT_FAST16_MAX  LONG_MAX
+#define UINT_FAST16_MAX  ULONG_MAX
+
+#undef INT_FAST32_MIN
+#undef INT_FAST32_MAX
+#undef UINT_FAST32_MAX
+#define INT_FAST32_MIN  LONG_MIN
+#define INT_FAST32_MAX  LONG_MAX
+#define UINT_FAST32_MAX  ULONG_MAX
+
+#undef INT_FAST64_MIN
+#undef INT_FAST64_MAX
+#ifdef GL_INT64_T
+# define INT_FAST64_MIN  INT64_MIN
+# define INT_FAST64_MAX  INT64_MAX
+#endif
+
+#undef UINT_FAST64_MAX
+#ifdef GL_UINT64_T
+# define UINT_FAST64_MAX  UINT64_MAX
+#endif
+
+/* 7.18.2.4. Limits of integer types capable of holding object pointers */
+
+#undef INTPTR_MIN
+#undef INTPTR_MAX
+#undef UINTPTR_MAX
+#define INTPTR_MIN  LONG_MIN
+#define INTPTR_MAX  LONG_MAX
+#define UINTPTR_MAX  ULONG_MAX
+
+/* 7.18.2.5. Limits of greatest-width integer types */
+
+#undef INTMAX_MIN
+#undef INTMAX_MAX
+#ifdef INT64_MAX
+# define INTMAX_MIN  INT64_MIN
+# define INTMAX_MAX  INT64_MAX
+#else
+# define INTMAX_MIN  INT32_MIN
+# define INTMAX_MAX  INT32_MAX
+#endif
+
+#undef UINTMAX_MAX
+#ifdef UINT64_MAX
+# define UINTMAX_MAX  UINT64_MAX
+#else
+# define UINTMAX_MAX  UINT32_MAX
+#endif
+
+/* 7.18.3. Limits of other integer types */
+
+/* ptrdiff_t limits */
+#undef PTRDIFF_MIN
+#undef PTRDIFF_MAX
+#if @APPLE_UNIVERSAL_BUILD@
+# ifdef _LP64
+#  define PTRDIFF_MIN  _STDINT_MIN (1, 64, 0l)
+#  define PTRDIFF_MAX  _STDINT_MAX (1, 64, 0l)
+# else
+#  define PTRDIFF_MIN  _STDINT_MIN (1, 32, 0)
+#  define PTRDIFF_MAX  _STDINT_MAX (1, 32, 0)
+# endif
+#else
+# define PTRDIFF_MIN  \
+    _STDINT_MIN (1, @BITSIZEOF_PTRDIFF_T@, 0@PTRDIFF_T_SUFFIX@)
+# define PTRDIFF_MAX  \
+    _STDINT_MAX (1, @BITSIZEOF_PTRDIFF_T@, 0@PTRDIFF_T_SUFFIX@)
+#endif
+
+/* sig_atomic_t limits */
+#undef SIG_ATOMIC_MIN
+#undef SIG_ATOMIC_MAX
+#define SIG_ATOMIC_MIN  \
+   _STDINT_MIN (@HAVE_SIGNED_SIG_ATOMIC_T@, @BITSIZEOF_SIG_ATOMIC_T@, \
+                0@SIG_ATOMIC_T_SUFFIX@)
+#define SIG_ATOMIC_MAX  \
+   _STDINT_MAX (@HAVE_SIGNED_SIG_ATOMIC_T@, @BITSIZEOF_SIG_ATOMIC_T@, \
+                0@SIG_ATOMIC_T_SUFFIX@)
+
+
+/* size_t limit */
+#undef SIZE_MAX
+#if @APPLE_UNIVERSAL_BUILD@
+# ifdef _LP64
+#  define SIZE_MAX  _STDINT_MAX (0, 64, 0ul)
+# else
+#  define SIZE_MAX  _STDINT_MAX (0, 32, 0ul)
+# endif
+#else
+# define SIZE_MAX  _STDINT_MAX (0, @BITSIZEOF_SIZE_T@, 0@SIZE_T_SUFFIX@)
+#endif
+
+/* wchar_t limits */
+/* Get WCHAR_MIN, WCHAR_MAX.
+   This include is not on the top, above, because on OSF/1 4.0 we have a sequence of nested
+   includes <wchar.h> -> <stdio.h> -> <getopt.h> -> <stdlib.h>, and the latter includes
+   <stdint.h> and assumes its types are already defined.  */
+#if ! (defined WCHAR_MIN && defined WCHAR_MAX)
+# define _GL_JUST_INCLUDE_SYSTEM_WCHAR_H
+# include <wchar.h>
+# undef _GL_JUST_INCLUDE_SYSTEM_WCHAR_H
+#endif
+#undef WCHAR_MIN
+#undef WCHAR_MAX
+#define WCHAR_MIN  \
+   _STDINT_MIN (@HAVE_SIGNED_WCHAR_T@, @BITSIZEOF_WCHAR_T@, 0@WCHAR_T_SUFFIX@)
+#define WCHAR_MAX  \
+   _STDINT_MAX (@HAVE_SIGNED_WCHAR_T@, @BITSIZEOF_WCHAR_T@, 0@WCHAR_T_SUFFIX@)
+
+/* wint_t limits */
+#undef WINT_MIN
+#undef WINT_MAX
+#define WINT_MIN  \
+   _STDINT_MIN (@HAVE_SIGNED_WINT_T@, @BITSIZEOF_WINT_T@, 0@WINT_T_SUFFIX@)
+#define WINT_MAX  \
+   _STDINT_MAX (@HAVE_SIGNED_WINT_T@, @BITSIZEOF_WINT_T@, 0@WINT_T_SUFFIX@)
+
+#endif /* !defined __cplusplus || defined __STDC_LIMIT_MACROS */
+
+/* 7.18.4. Macros for integer constants */
+
+#if ! defined __cplusplus || defined __STDC_CONSTANT_MACROS
+
+/* 7.18.4.1. Macros for minimum-width integer constants */
+/* According to ISO C 99 Technical Corrigendum 1 */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits, and int is 32 bits.  */
+
+#undef INT8_C
+#undef UINT8_C
+#define INT8_C(x) x
+#define UINT8_C(x) x
+
+#undef INT16_C
+#undef UINT16_C
+#define INT16_C(x) x
+#define UINT16_C(x) x
+
+#undef INT32_C
+#undef UINT32_C
+#define INT32_C(x) x
+#define UINT32_C(x) x ## U
+
+#undef INT64_C
+#undef UINT64_C
+#if LONG_MAX >> 31 >> 31 == 1
+# define INT64_C(x) x##L
+#elif defined _MSC_VER
+# define INT64_C(x) x##i64
+#elif @HAVE_LONG_LONG_INT@
+# define INT64_C(x) x##LL
+#endif
+#if ULONG_MAX >> 31 >> 31 >> 1 == 1
+# define UINT64_C(x) x##UL
+#elif defined _MSC_VER
+# define UINT64_C(x) x##ui64
+#elif @HAVE_UNSIGNED_LONG_LONG_INT@
+# define UINT64_C(x) x##ULL
+#endif
+
+/* 7.18.4.2. Macros for greatest-width integer constants */
+
+#undef INTMAX_C
+#if @HAVE_LONG_LONG_INT@ && LONG_MAX >> 30 == 1
+# define INTMAX_C(x)   x##LL
+#elif defined GL_INT64_T
+# define INTMAX_C(x)   INT64_C(x)
+#else
+# define INTMAX_C(x)   x##L
+#endif
+
+#undef UINTMAX_C
+#if @HAVE_UNSIGNED_LONG_LONG_INT@ && ULONG_MAX >> 31 == 1
+# define UINTMAX_C(x)  x##ULL
+#elif defined GL_UINT64_T
+# define UINTMAX_C(x)  UINT64_C(x)
+#else
+# define UINTMAX_C(x)  x##UL
+#endif
+
+#endif /* !defined __cplusplus || defined __STDC_CONSTANT_MACROS */
+
+#endif /* _GL_STDINT_H */
+#endif /* !defined _GL_STDINT_H && !defined _GL_JUST_INCLUDE_SYSTEM_STDINT_H */
--- /dev/null
+++ b/gltests/stdlib.in.h
@@ -0,0 +1,687 @@
+/* A GNU-like <stdlib.h>.
+
+   Copyright (C) 1995, 2001-2004, 2006-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+#if defined __need_malloc_and_calloc
+/* Special invocation convention inside glibc header files.  */
+
+#@INCLUDE_NEXT@ @NEXT_STDLIB_H@
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_STDLIB_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#@INCLUDE_NEXT@ @NEXT_STDLIB_H@
+
+#ifndef _GL_STDLIB_H
+#define _GL_STDLIB_H
+
+/* NetBSD 5.0 mis-defines NULL.  */
+#include <stddef.h>
+
+/* Solaris declares getloadavg() in <sys/loadavg.h>.  */
+#if (@GNULIB_GETLOADAVG@ || defined GNULIB_POSIXCHECK) && @HAVE_SYS_LOADAVG_H@
+# include <sys/loadavg.h>
+#endif
+
+/* OSF/1 5.1 declares 'struct random_data' in <random.h>, which is included
+   from <stdlib.h> if _REENTRANT is defined.  Include it always.  */
+#if @HAVE_RANDOM_H@
+# include <random.h>
+#endif
+
+#if !@HAVE_STRUCT_RANDOM_DATA@ || (@GNULIB_RANDOM_R@ && !@HAVE_RANDOM_R@) \
+    || defined GNULIB_POSIXCHECK
+# include <stdint.h>
+#endif
+
+#if !@HAVE_STRUCT_RANDOM_DATA@
+struct random_data
+{
+  int32_t *fptr;                /* Front pointer.  */
+  int32_t *rptr;                /* Rear pointer.  */
+  int32_t *state;               /* Array of state values.  */
+  int rand_type;                /* Type of random number generator.  */
+  int rand_deg;                 /* Degree of random number generator.  */
+  int rand_sep;                 /* Distance between front and rear.  */
+  int32_t *end_ptr;             /* Pointer behind state table.  */
+};
+#endif
+
+#if (@GNULIB_MKSTEMP@ || @GNULIB_GETSUBOPT@ || defined GNULIB_POSIXCHECK) && ! defined __GLIBC__ && !((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)
+/* On MacOS X 10.3, only <unistd.h> declares mkstemp.  */
+/* On Cygwin 1.7.1, only <unistd.h> declares getsubopt.  */
+/* But avoid namespace pollution on glibc systems and native Windows.  */
+# include <unistd.h>
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+
+
+/* Some systems do not define EXIT_*, despite otherwise supporting C89.  */
+#ifndef EXIT_SUCCESS
+# define EXIT_SUCCESS 0
+#endif
+/* Tandem/NSK and other platforms that define EXIT_FAILURE as -1 interfere
+   with proper operation of xargs.  */
+#ifndef EXIT_FAILURE
+# define EXIT_FAILURE 1
+#elif EXIT_FAILURE != 1
+# undef EXIT_FAILURE
+# define EXIT_FAILURE 1
+#endif
+
+
+#if @GNULIB_ATOLL@
+/* Parse a signed decimal integer.
+   Returns the value of the integer.  Errors are not detected.  */
+# if !@HAVE_ATOLL@
+_GL_FUNCDECL_SYS (atoll, long long, (const char *string) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (atoll, long long, (const char *string));
+_GL_CXXALIASWARN (atoll);
+#elif defined GNULIB_POSIXCHECK
+# undef atoll
+# if HAVE_RAW_DECL_ATOLL
+_GL_WARN_ON_USE (atoll, "atoll is unportable - "
+                 "use gnulib module atoll for portability");
+# endif
+#endif
+
+#if @GNULIB_CALLOC_POSIX@
+# if !@HAVE_CALLOC_POSIX@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef calloc
+#   define calloc rpl_calloc
+#  endif
+_GL_FUNCDECL_RPL (calloc, void *, (size_t nmemb, size_t size));
+_GL_CXXALIAS_RPL (calloc, void *, (size_t nmemb, size_t size));
+# else
+_GL_CXXALIAS_SYS (calloc, void *, (size_t nmemb, size_t size));
+# endif
+_GL_CXXALIASWARN (calloc);
+#elif defined GNULIB_POSIXCHECK
+# undef calloc
+/* Assume calloc is always declared.  */
+_GL_WARN_ON_USE (calloc, "calloc is not POSIX compliant everywhere - "
+                 "use gnulib module calloc-posix for portability");
+#endif
+
+#if @GNULIB_CANONICALIZE_FILE_NAME@
+# if @REPLACE_CANONICALIZE_FILE_NAME@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define canonicalize_file_name rpl_canonicalize_file_name
+#  endif
+_GL_FUNCDECL_RPL (canonicalize_file_name, char *, (const char *name)
+                                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (canonicalize_file_name, char *, (const char *name));
+# else
+#  if !@HAVE_CANONICALIZE_FILE_NAME@
+_GL_FUNCDECL_SYS (canonicalize_file_name, char *, (const char *name)
+                                                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (canonicalize_file_name, char *, (const char *name));
+# endif
+_GL_CXXALIASWARN (canonicalize_file_name);
+#elif defined GNULIB_POSIXCHECK
+# undef canonicalize_file_name
+# if HAVE_RAW_DECL_CANONICALIZE_FILE_NAME
+_GL_WARN_ON_USE (canonicalize_file_name, "canonicalize_file_name is unportable - "
+                 "use gnulib module canonicalize-lgpl for portability");
+# endif
+#endif
+
+#if @GNULIB_GETLOADAVG@
+/* Store max(NELEM,3) load average numbers in LOADAVG[].
+   The three numbers are the load average of the last 1 minute, the last 5
+   minutes, and the last 15 minutes, respectively.
+   LOADAVG is an array of NELEM numbers.  */
+# if !@HAVE_DECL_GETLOADAVG@
+_GL_FUNCDECL_SYS (getloadavg, int, (double loadavg[], int nelem)
+                                   _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (getloadavg, int, (double loadavg[], int nelem));
+_GL_CXXALIASWARN (getloadavg);
+#elif defined GNULIB_POSIXCHECK
+# undef getloadavg
+# if HAVE_RAW_DECL_GETLOADAVG
+_GL_WARN_ON_USE (getloadavg, "getloadavg is not portable - "
+                 "use gnulib module getloadavg for portability");
+# endif
+#endif
+
+#if @GNULIB_GETSUBOPT@
+/* Assuming *OPTIONP is a comma separated list of elements of the form
+   "token" or "token=value", getsubopt parses the first of these elements.
+   If the first element refers to a "token" that is member of the given
+   NULL-terminated array of tokens:
+     - It replaces the comma with a NUL byte, updates *OPTIONP to point past
+       the first option and the comma, sets *VALUEP to the value of the
+       element (or NULL if it doesn't contain an "=" sign),
+     - It returns the index of the "token" in the given array of tokens.
+   Otherwise it returns -1, and *OPTIONP and *VALUEP are undefined.
+   For more details see the POSIX:2001 specification.
+   http://www.opengroup.org/susv3xsh/getsubopt.html */
+# if !@HAVE_GETSUBOPT@
+_GL_FUNCDECL_SYS (getsubopt, int,
+                  (char **optionp, char *const *tokens, char **valuep)
+                  _GL_ARG_NONNULL ((1, 2, 3)));
+# endif
+_GL_CXXALIAS_SYS (getsubopt, int,
+                  (char **optionp, char *const *tokens, char **valuep));
+_GL_CXXALIASWARN (getsubopt);
+#elif defined GNULIB_POSIXCHECK
+# undef getsubopt
+# if HAVE_RAW_DECL_GETSUBOPT
+_GL_WARN_ON_USE (getsubopt, "getsubopt is unportable - "
+                 "use gnulib module getsubopt for portability");
+# endif
+#endif
+
+#if @GNULIB_GRANTPT@
+/* Change the ownership and access permission of the slave side of the
+   pseudo-terminal whose master side is specified by FD.  */
+# if !@HAVE_GRANTPT@
+_GL_FUNCDECL_SYS (grantpt, int, (int fd));
+# endif
+_GL_CXXALIAS_SYS (grantpt, int, (int fd));
+_GL_CXXALIASWARN (grantpt);
+#elif defined GNULIB_POSIXCHECK
+# undef grantpt
+# if HAVE_RAW_DECL_GRANTPT
+_GL_WARN_ON_USE (ptsname, "grantpt is not portable - "
+                 "use gnulib module grantpt for portability");
+# endif
+#endif
+
+#if @GNULIB_MALLOC_POSIX@
+# if !@HAVE_MALLOC_POSIX@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef malloc
+#   define malloc rpl_malloc
+#  endif
+_GL_FUNCDECL_RPL (malloc, void *, (size_t size));
+_GL_CXXALIAS_RPL (malloc, void *, (size_t size));
+# else
+_GL_CXXALIAS_SYS (malloc, void *, (size_t size));
+# endif
+_GL_CXXALIASWARN (malloc);
+#elif defined GNULIB_POSIXCHECK
+# undef malloc
+/* Assume malloc is always declared.  */
+_GL_WARN_ON_USE (malloc, "malloc is not POSIX compliant everywhere - "
+                 "use gnulib module malloc-posix for portability");
+#endif
+
+#if @GNULIB_MKDTEMP@
+/* Create a unique temporary directory from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the directory name unique.
+   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
+   The directory is created mode 700.  */
+# if !@HAVE_MKDTEMP@
+_GL_FUNCDECL_SYS (mkdtemp, char *, (char * /*template*/) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (mkdtemp, char *, (char * /*template*/));
+_GL_CXXALIASWARN (mkdtemp);
+#elif defined GNULIB_POSIXCHECK
+# undef mkdtemp
+# if HAVE_RAW_DECL_MKDTEMP
+_GL_WARN_ON_USE (mkdtemp, "mkdtemp is unportable - "
+                 "use gnulib module mkdtemp for portability");
+# endif
+#endif
+
+#if @GNULIB_MKOSTEMP@
+/* Create a unique temporary file from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)
+   and O_TEXT, O_BINARY (defined in "binary-io.h").
+   The file is then created, with the specified flags, ensuring it didn't exist
+   before.
+   The file is created read-write (mask at least 0600 & ~umask), but it may be
+   world-readable and world-writable (mask 0666 & ~umask), depending on the
+   implementation.
+   Returns the open file descriptor if successful, otherwise -1 and errno
+   set.  */
+# if !@HAVE_MKOSTEMP@
+_GL_FUNCDECL_SYS (mkostemp, int, (char * /*template*/, int /*flags*/)
+                                 _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (mkostemp, int, (char * /*template*/, int /*flags*/));
+_GL_CXXALIASWARN (mkostemp);
+#elif defined GNULIB_POSIXCHECK
+# undef mkostemp
+# if HAVE_RAW_DECL_MKOSTEMP
+_GL_WARN_ON_USE (mkostemp, "mkostemp is unportable - "
+                 "use gnulib module mkostemp for portability");
+# endif
+#endif
+
+#if @GNULIB_MKOSTEMPS@
+/* Create a unique temporary file from TEMPLATE.
+   The last six characters of TEMPLATE before a suffix of length
+   SUFFIXLEN must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)
+   and O_TEXT, O_BINARY (defined in "binary-io.h").
+   The file is then created, with the specified flags, ensuring it didn't exist
+   before.
+   The file is created read-write (mask at least 0600 & ~umask), but it may be
+   world-readable and world-writable (mask 0666 & ~umask), depending on the
+   implementation.
+   Returns the open file descriptor if successful, otherwise -1 and errno
+   set.  */
+# if !@HAVE_MKOSTEMPS@
+_GL_FUNCDECL_SYS (mkostemps, int,
+                  (char * /*template*/, int /*suffixlen*/, int /*flags*/)
+                  _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (mkostemps, int,
+                  (char * /*template*/, int /*suffixlen*/, int /*flags*/));
+_GL_CXXALIASWARN (mkostemps);
+#elif defined GNULIB_POSIXCHECK
+# undef mkostemps
+# if HAVE_RAW_DECL_MKOSTEMPS
+_GL_WARN_ON_USE (mkostemps, "mkostemps is unportable - "
+                 "use gnulib module mkostemps for portability");
+# endif
+#endif
+
+#if @GNULIB_MKSTEMP@
+/* Create a unique temporary file from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   The file is then created, ensuring it didn't exist before.
+   The file is created read-write (mask at least 0600 & ~umask), but it may be
+   world-readable and world-writable (mask 0666 & ~umask), depending on the
+   implementation.
+   Returns the open file descriptor if successful, otherwise -1 and errno
+   set.  */
+# if @REPLACE_MKSTEMP@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mkstemp rpl_mkstemp
+#  endif
+_GL_FUNCDECL_RPL (mkstemp, int, (char * /*template*/) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mkstemp, int, (char * /*template*/));
+# else
+#  if ! @HAVE_MKSTEMP@
+_GL_FUNCDECL_SYS (mkstemp, int, (char * /*template*/) _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (mkstemp, int, (char * /*template*/));
+# endif
+_GL_CXXALIASWARN (mkstemp);
+#elif defined GNULIB_POSIXCHECK
+# undef mkstemp
+# if HAVE_RAW_DECL_MKSTEMP
+_GL_WARN_ON_USE (mkstemp, "mkstemp is unportable - "
+                 "use gnulib module mkstemp for portability");
+# endif
+#endif
+
+#if @GNULIB_MKSTEMPS@
+/* Create a unique temporary file from TEMPLATE.
+   The last six characters of TEMPLATE prior to a suffix of length
+   SUFFIXLEN must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   The file is then created, ensuring it didn't exist before.
+   The file is created read-write (mask at least 0600 & ~umask), but it may be
+   world-readable and world-writable (mask 0666 & ~umask), depending on the
+   implementation.
+   Returns the open file descriptor if successful, otherwise -1 and errno
+   set.  */
+# if !@HAVE_MKSTEMPS@
+_GL_FUNCDECL_SYS (mkstemps, int, (char * /*template*/, int /*suffixlen*/)
+                                 _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (mkstemps, int, (char * /*template*/, int /*suffixlen*/));
+_GL_CXXALIASWARN (mkstemps);
+#elif defined GNULIB_POSIXCHECK
+# undef mkstemps
+# if HAVE_RAW_DECL_MKSTEMPS
+_GL_WARN_ON_USE (mkstemps, "mkstemps is unportable - "
+                 "use gnulib module mkstemps for portability");
+# endif
+#endif
+
+#if @GNULIB_PTSNAME@
+/* Return the pathname of the pseudo-terminal slave associated with
+   the master FD is open on, or NULL on errors.  */
+# if !@HAVE_PTSNAME@
+_GL_FUNCDECL_SYS (ptsname, char *, (int fd));
+# endif
+_GL_CXXALIAS_SYS (ptsname, char *, (int fd));
+_GL_CXXALIASWARN (ptsname);
+#elif defined GNULIB_POSIXCHECK
+# undef ptsname
+# if HAVE_RAW_DECL_PTSNAME
+_GL_WARN_ON_USE (ptsname, "ptsname is not portable - "
+                 "use gnulib module ptsname for portability");
+# endif
+#endif
+
+#if @GNULIB_PUTENV@
+# if @REPLACE_PUTENV@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef putenv
+#   define putenv rpl_putenv
+#  endif
+_GL_FUNCDECL_RPL (putenv, int, (char *string) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (putenv, int, (char *string));
+# else
+_GL_CXXALIAS_SYS (putenv, int, (char *string));
+# endif
+_GL_CXXALIASWARN (putenv);
+#endif
+
+
+#if @GNULIB_RANDOM_R@
+# if !@HAVE_RANDOM_R@
+#  ifndef RAND_MAX
+#   define RAND_MAX 2147483647
+#  endif
+# endif
+#endif
+
+#if @GNULIB_RANDOM_R@
+# if !@HAVE_RANDOM_R@
+_GL_FUNCDECL_SYS (random_r, int, (struct random_data *buf, int32_t *result)
+                                 _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (random_r, int, (struct random_data *buf, int32_t *result));
+_GL_CXXALIASWARN (random_r);
+#elif defined GNULIB_POSIXCHECK
+# undef random_r
+# if HAVE_RAW_DECL_RANDOM_R
+_GL_WARN_ON_USE (random_r, "random_r is unportable - "
+                 "use gnulib module random_r for portability");
+# endif
+#endif
+
+#if @GNULIB_RANDOM_R@
+# if !@HAVE_RANDOM_R@
+_GL_FUNCDECL_SYS (srandom_r, int,
+                  (unsigned int seed, struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((2)));
+# endif
+_GL_CXXALIAS_SYS (srandom_r, int,
+                  (unsigned int seed, struct random_data *rand_state));
+_GL_CXXALIASWARN (srandom_r);
+#elif defined GNULIB_POSIXCHECK
+# undef srandom_r
+# if HAVE_RAW_DECL_SRANDOM_R
+_GL_WARN_ON_USE (srandom_r, "srandom_r is unportable - "
+                 "use gnulib module random_r for portability");
+# endif
+#endif
+
+#if @GNULIB_RANDOM_R@
+# if !@HAVE_RANDOM_R@
+_GL_FUNCDECL_SYS (initstate_r, int,
+                  (unsigned int seed, char *buf, size_t buf_size,
+                   struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((2, 4)));
+# endif
+_GL_CXXALIAS_SYS (initstate_r, int,
+                  (unsigned int seed, char *buf, size_t buf_size,
+                   struct random_data *rand_state));
+_GL_CXXALIASWARN (initstate_r);
+#elif defined GNULIB_POSIXCHECK
+# undef initstate_r
+# if HAVE_RAW_DECL_INITSTATE_R
+_GL_WARN_ON_USE (initstate_r, "initstate_r is unportable - "
+                 "use gnulib module random_r for portability");
+# endif
+#endif
+
+#if @GNULIB_RANDOM_R@
+# if !@HAVE_RANDOM_R@
+_GL_FUNCDECL_SYS (setstate_r, int,
+                  (char *arg_state, struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (setstate_r, int,
+                  (char *arg_state, struct random_data *rand_state));
+_GL_CXXALIASWARN (setstate_r);
+#elif defined GNULIB_POSIXCHECK
+# undef setstate_r
+# if HAVE_RAW_DECL_SETSTATE_R
+_GL_WARN_ON_USE (setstate_r, "setstate_r is unportable - "
+                 "use gnulib module random_r for portability");
+# endif
+#endif
+
+
+#if @GNULIB_REALLOC_POSIX@
+# if !@HAVE_REALLOC_POSIX@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef realloc
+#   define realloc rpl_realloc
+#  endif
+_GL_FUNCDECL_RPL (realloc, void *, (void *ptr, size_t size));
+_GL_CXXALIAS_RPL (realloc, void *, (void *ptr, size_t size));
+# else
+_GL_CXXALIAS_SYS (realloc, void *, (void *ptr, size_t size));
+# endif
+_GL_CXXALIASWARN (realloc);
+#elif defined GNULIB_POSIXCHECK
+# undef realloc
+/* Assume realloc is always declared.  */
+_GL_WARN_ON_USE (realloc, "realloc is not POSIX compliant everywhere - "
+                 "use gnulib module realloc-posix for portability");
+#endif
+
+#if @GNULIB_REALPATH@
+# if @REPLACE_REALPATH@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define realpath rpl_realpath
+#  endif
+_GL_FUNCDECL_RPL (realpath, char *, (const char *name, char *resolved)
+                                    _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (realpath, char *, (const char *name, char *resolved));
+# else
+#  if !@HAVE_REALPATH@
+_GL_FUNCDECL_SYS (realpath, char *, (const char *name, char *resolved)
+                                    _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (realpath, char *, (const char *name, char *resolved));
+# endif
+_GL_CXXALIASWARN (realpath);
+#elif defined GNULIB_POSIXCHECK
+# undef realpath
+# if HAVE_RAW_DECL_REALPATH
+_GL_WARN_ON_USE (realpath, "realpath is unportable - use gnulib module "
+                 "canonicalize or canonicalize-lgpl for portability");
+# endif
+#endif
+
+#if @GNULIB_RPMATCH@
+/* Test a user response to a question.
+   Return 1 if it is affirmative, 0 if it is negative, or -1 if not clear.  */
+# if !@HAVE_RPMATCH@
+_GL_FUNCDECL_SYS (rpmatch, int, (const char *response) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (rpmatch, int, (const char *response));
+_GL_CXXALIASWARN (rpmatch);
+#elif defined GNULIB_POSIXCHECK
+# undef rpmatch
+# if HAVE_RAW_DECL_RPMATCH
+_GL_WARN_ON_USE (rpmatch, "rpmatch is unportable - "
+                 "use gnulib module rpmatch for portability");
+# endif
+#endif
+
+#if @GNULIB_SETENV@
+/* Set NAME to VALUE in the environment.
+   If REPLACE is nonzero, overwrite an existing value.  */
+# if @REPLACE_SETENV@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef setenv
+#   define setenv rpl_setenv
+#  endif
+_GL_FUNCDECL_RPL (setenv, int,
+                  (const char *name, const char *value, int replace)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (setenv, int,
+                  (const char *name, const char *value, int replace));
+# else
+#  if !@HAVE_SETENV@
+_GL_FUNCDECL_SYS (setenv, int,
+                  (const char *name, const char *value, int replace)
+                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (setenv, int,
+                  (const char *name, const char *value, int replace));
+# endif
+_GL_CXXALIASWARN (setenv);
+#elif defined GNULIB_POSIXCHECK
+# undef setenv
+# if HAVE_RAW_DECL_SETENV
+_GL_WARN_ON_USE (setenv, "setenv is unportable - "
+                 "use gnulib module setenv for portability");
+# endif
+#endif
+
+#if @GNULIB_STRTOD@
+ /* Parse a double from STRING, updating ENDP if appropriate.  */
+# if @REPLACE_STRTOD@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strtod rpl_strtod
+#  endif
+_GL_FUNCDECL_RPL (strtod, double, (const char *str, char **endp)
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strtod, double, (const char *str, char **endp));
+# else
+#  if !@HAVE_STRTOD@
+_GL_FUNCDECL_SYS (strtod, double, (const char *str, char **endp)
+                                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strtod, double, (const char *str, char **endp));
+# endif
+_GL_CXXALIASWARN (strtod);
+#elif defined GNULIB_POSIXCHECK
+# undef strtod
+# if HAVE_RAW_DECL_STRTOD
+_GL_WARN_ON_USE (strtod, "strtod is unportable - "
+                 "use gnulib module strtod for portability");
+# endif
+#endif
+
+#if @GNULIB_STRTOLL@
+/* Parse a signed integer whose textual representation starts at STRING.
+   The integer is expected to be in base BASE (2 <= BASE <= 36); if BASE == 0,
+   it may be decimal or octal (with prefix "0") or hexadecimal (with prefix
+   "0x").
+   If ENDPTR is not NULL, the address of the first byte after the integer is
+   stored in *ENDPTR.
+   Upon overflow, the return value is LLONG_MAX or LLONG_MIN, and errno is set
+   to ERANGE.  */
+# if !@HAVE_STRTOLL@
+_GL_FUNCDECL_SYS (strtoll, long long,
+                  (const char *string, char **endptr, int base)
+                  _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (strtoll, long long,
+                  (const char *string, char **endptr, int base));
+_GL_CXXALIASWARN (strtoll);
+#elif defined GNULIB_POSIXCHECK
+# undef strtoll
+# if HAVE_RAW_DECL_STRTOLL
+_GL_WARN_ON_USE (strtoll, "strtoll is unportable - "
+                 "use gnulib module strtoll for portability");
+# endif
+#endif
+
+#if @GNULIB_STRTOULL@
+/* Parse an unsigned integer whose textual representation starts at STRING.
+   The integer is expected to be in base BASE (2 <= BASE <= 36); if BASE == 0,
+   it may be decimal or octal (with prefix "0") or hexadecimal (with prefix
+   "0x").
+   If ENDPTR is not NULL, the address of the first byte after the integer is
+   stored in *ENDPTR.
+   Upon overflow, the return value is ULLONG_MAX, and errno is set to
+   ERANGE.  */
+# if !@HAVE_STRTOULL@
+_GL_FUNCDECL_SYS (strtoull, unsigned long long,
+                  (const char *string, char **endptr, int base)
+                  _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (strtoull, unsigned long long,
+                  (const char *string, char **endptr, int base));
+_GL_CXXALIASWARN (strtoull);
+#elif defined GNULIB_POSIXCHECK
+# undef strtoull
+# if HAVE_RAW_DECL_STRTOULL
+_GL_WARN_ON_USE (strtoull, "strtoull is unportable - "
+                 "use gnulib module strtoull for portability");
+# endif
+#endif
+
+#if @GNULIB_UNLOCKPT@
+/* Unlock the slave side of the pseudo-terminal whose master side is specified
+   by FD, so that it can be opened.  */
+# if !@HAVE_UNLOCKPT@
+_GL_FUNCDECL_SYS (unlockpt, int, (int fd));
+# endif
+_GL_CXXALIAS_SYS (unlockpt, int, (int fd));
+_GL_CXXALIASWARN (unlockpt);
+#elif defined GNULIB_POSIXCHECK
+# undef unlockpt
+# if HAVE_RAW_DECL_UNLOCKPT
+_GL_WARN_ON_USE (ptsname, "unlockpt is not portable - "
+                 "use gnulib module unlockpt for portability");
+# endif
+#endif
+
+#if @GNULIB_UNSETENV@
+/* Remove the variable NAME from the environment.  */
+# if @REPLACE_UNSETENV@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef unsetenv
+#   define unsetenv rpl_unsetenv
+#  endif
+_GL_FUNCDECL_RPL (unsetenv, int, (const char *name) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (unsetenv, int, (const char *name));
+# else
+#  if !@HAVE_UNSETENV@
+_GL_FUNCDECL_SYS (unsetenv, int, (const char *name) _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (unsetenv, int, (const char *name));
+# endif
+_GL_CXXALIASWARN (unsetenv);
+#elif defined GNULIB_POSIXCHECK
+# undef unsetenv
+# if HAVE_RAW_DECL_UNSETENV
+_GL_WARN_ON_USE (unsetenv, "unsetenv is unportable - "
+                 "use gnulib module unsetenv for portability");
+# endif
+#endif
+
+
+#endif /* _GL_STDLIB_H */
+#endif /* _GL_STDLIB_H */
+#endif
--- /dev/null
+++ b/gltests/symlink.c
@@ -0,0 +1,57 @@
+/* Stub for symlink().
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+/* Specification.  */
+#include <unistd.h>
+
+#include <errno.h>
+#include <string.h>
+#include <sys/stat.h>
+
+
+#if HAVE_SYMLINK
+
+# undef symlink
+
+/* Create a symlink, but reject trailing slash.  */
+int
+rpl_symlink (char const *contents, char const *name)
+{
+  size_t len = strlen (name);
+  if (len && name[len - 1] == '/')
+    {
+      struct stat st;
+      if (lstat (name, &st) == 0)
+        errno = EEXIST;
+      return -1;
+    }
+  return symlink (contents, name);
+}
+
+#else /* !HAVE_SYMLINK */
+
+/* The system does not support symlinks.  */
+int
+symlink (char const *contents _GL_UNUSED,
+         char const *name _GL_UNUSED)
+{
+  errno = ENOSYS;
+  return -1;
+}
+
+#endif /* !HAVE_SYMLINK */
--- /dev/null
+++ b/gltests/sys_stat.in.h
@@ -0,0 +1,640 @@
+/* Provide a more complete sys/stat header file.
+   Copyright (C) 2005-2010 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Written by Eric Blake, Paul Eggert, and Jim Meyering.  */
+
+/* This file is supposed to be used on platforms where <sys/stat.h> is
+   incomplete.  It is intended to provide definitions and prototypes
+   needed by an application.  Start with what the system provides.  */
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+#if defined __need_system_sys_stat_h
+/* Special invocation convention.  */
+
+#@INCLUDE_NEXT@ @NEXT_SYS_STAT_H@
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_SYS_STAT_H
+
+/* Get nlink_t.  */
+#include <sys/types.h>
+
+/* Get struct timespec.  */
+#include <time.h>
+
+/* The include_next requires a split double-inclusion guard.  */
+#@INCLUDE_NEXT@ @NEXT_SYS_STAT_H@
+
+#ifndef _GL_SYS_STAT_H
+#define _GL_SYS_STAT_H
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+
+/* Before doing "#define mkdir rpl_mkdir" below, we need to include all
+   headers that may declare mkdir().  */
+#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+# include <io.h>     /* mingw32, mingw64 */
+# include <direct.h> /* mingw64 */
+#endif
+
+#ifndef S_IFMT
+# define S_IFMT 0170000
+#endif
+
+#if STAT_MACROS_BROKEN
+# undef S_ISBLK
+# undef S_ISCHR
+# undef S_ISDIR
+# undef S_ISFIFO
+# undef S_ISLNK
+# undef S_ISNAM
+# undef S_ISMPB
+# undef S_ISMPC
+# undef S_ISNWK
+# undef S_ISREG
+# undef S_ISSOCK
+#endif
+
+#ifndef S_ISBLK
+# ifdef S_IFBLK
+#  define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
+# else
+#  define S_ISBLK(m) 0
+# endif
+#endif
+
+#ifndef S_ISCHR
+# ifdef S_IFCHR
+#  define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
+# else
+#  define S_ISCHR(m) 0
+# endif
+#endif
+
+#ifndef S_ISDIR
+# ifdef S_IFDIR
+#  define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+# else
+#  define S_ISDIR(m) 0
+# endif
+#endif
+
+#ifndef S_ISDOOR /* Solaris 2.5 and up */
+# define S_ISDOOR(m) 0
+#endif
+
+#ifndef S_ISFIFO
+# ifdef S_IFIFO
+#  define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
+# else
+#  define S_ISFIFO(m) 0
+# endif
+#endif
+
+#ifndef S_ISLNK
+# ifdef S_IFLNK
+#  define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+# else
+#  define S_ISLNK(m) 0
+# endif
+#endif
+
+#ifndef S_ISMPB /* V7 */
+# ifdef S_IFMPB
+#  define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
+#  define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
+# else
+#  define S_ISMPB(m) 0
+#  define S_ISMPC(m) 0
+# endif
+#endif
+
+#ifndef S_ISNAM /* Xenix */
+# ifdef S_IFNAM
+#  define S_ISNAM(m) (((m) & S_IFMT) == S_IFNAM)
+# else
+#  define S_ISNAM(m) 0
+# endif
+#endif
+
+#ifndef S_ISNWK /* HP/UX */
+# ifdef S_IFNWK
+#  define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
+# else
+#  define S_ISNWK(m) 0
+# endif
+#endif
+
+#ifndef S_ISPORT /* Solaris 10 and up */
+# define S_ISPORT(m) 0
+#endif
+
+#ifndef S_ISREG
+# ifdef S_IFREG
+#  define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+# else
+#  define S_ISREG(m) 0
+# endif
+#endif
+
+#ifndef S_ISSOCK
+# ifdef S_IFSOCK
+#  define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
+# else
+#  define S_ISSOCK(m) 0
+# endif
+#endif
+
+
+#ifndef S_TYPEISMQ
+# define S_TYPEISMQ(p) 0
+#endif
+
+#ifndef S_TYPEISTMO
+# define S_TYPEISTMO(p) 0
+#endif
+
+
+#ifndef S_TYPEISSEM
+# ifdef S_INSEM
+#  define S_TYPEISSEM(p) (S_ISNAM ((p)->st_mode) && (p)->st_rdev == S_INSEM)
+# else
+#  define S_TYPEISSEM(p) 0
+# endif
+#endif
+
+#ifndef S_TYPEISSHM
+# ifdef S_INSHD
+#  define S_TYPEISSHM(p) (S_ISNAM ((p)->st_mode) && (p)->st_rdev == S_INSHD)
+# else
+#  define S_TYPEISSHM(p) 0
+# endif
+#endif
+
+/* high performance ("contiguous data") */
+#ifndef S_ISCTG
+# define S_ISCTG(p) 0
+#endif
+
+/* Cray DMF (data migration facility): off line, with data  */
+#ifndef S_ISOFD
+# define S_ISOFD(p) 0
+#endif
+
+/* Cray DMF (data migration facility): off line, with no data  */
+#ifndef S_ISOFL
+# define S_ISOFL(p) 0
+#endif
+
+/* 4.4BSD whiteout */
+#ifndef S_ISWHT
+# define S_ISWHT(m) 0
+#endif
+
+/* If any of the following are undefined,
+   define them to their de facto standard values.  */
+#if !S_ISUID
+# define S_ISUID 04000
+#endif
+#if !S_ISGID
+# define S_ISGID 02000
+#endif
+
+/* S_ISVTX is a common extension to POSIX.  */
+#ifndef S_ISVTX
+# define S_ISVTX 01000
+#endif
+
+#if !S_IRUSR && S_IREAD
+# define S_IRUSR S_IREAD
+#endif
+#if !S_IRUSR
+# define S_IRUSR 00400
+#endif
+#if !S_IRGRP
+# define S_IRGRP (S_IRUSR >> 3)
+#endif
+#if !S_IROTH
+# define S_IROTH (S_IRUSR >> 6)
+#endif
+
+#if !S_IWUSR && S_IWRITE
+# define S_IWUSR S_IWRITE
+#endif
+#if !S_IWUSR
+# define S_IWUSR 00200
+#endif
+#if !S_IWGRP
+# define S_IWGRP (S_IWUSR >> 3)
+#endif
+#if !S_IWOTH
+# define S_IWOTH (S_IWUSR >> 6)
+#endif
+
+#if !S_IXUSR && S_IEXEC
+# define S_IXUSR S_IEXEC
+#endif
+#if !S_IXUSR
+# define S_IXUSR 00100
+#endif
+#if !S_IXGRP
+# define S_IXGRP (S_IXUSR >> 3)
+#endif
+#if !S_IXOTH
+# define S_IXOTH (S_IXUSR >> 6)
+#endif
+
+#if !S_IRWXU
+# define S_IRWXU (S_IRUSR | S_IWUSR | S_IXUSR)
+#endif
+#if !S_IRWXG
+# define S_IRWXG (S_IRGRP | S_IWGRP | S_IXGRP)
+#endif
+#if !S_IRWXO
+# define S_IRWXO (S_IROTH | S_IWOTH | S_IXOTH)
+#endif
+
+/* S_IXUGO is a common extension to POSIX.  */
+#if !S_IXUGO
+# define S_IXUGO (S_IXUSR | S_IXGRP | S_IXOTH)
+#endif
+
+#ifndef S_IRWXUGO
+# define S_IRWXUGO (S_IRWXU | S_IRWXG | S_IRWXO)
+#endif
+
+/* Macros for futimens and utimensat.  */
+#ifndef UTIME_NOW
+# define UTIME_NOW (-1)
+# define UTIME_OMIT (-2)
+#endif
+
+
+#if @GNULIB_FCHMODAT@
+# if !@HAVE_FCHMODAT@
+_GL_FUNCDECL_SYS (fchmodat, int,
+                  (int fd, char const *file, mode_t mode, int flag)
+                  _GL_ARG_NONNULL ((2)));
+# endif
+_GL_CXXALIAS_SYS (fchmodat, int,
+                  (int fd, char const *file, mode_t mode, int flag));
+_GL_CXXALIASWARN (fchmodat);
+#elif defined GNULIB_POSIXCHECK
+# undef fchmodat
+# if HAVE_RAW_DECL_FCHMODAT
+_GL_WARN_ON_USE (fchmodat, "fchmodat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+#if @REPLACE_FSTAT@
+# if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#  define fstat rpl_fstat
+# endif
+_GL_FUNCDECL_RPL (fstat, int, (int fd, struct stat *buf) _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (fstat, int, (int fd, struct stat *buf));
+#else
+_GL_CXXALIAS_SYS (fstat, int, (int fd, struct stat *buf));
+#endif
+_GL_CXXALIASWARN (fstat);
+
+
+#if @GNULIB_FSTATAT@
+# if @REPLACE_FSTATAT@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fstatat
+#   define fstatat rpl_fstatat
+#  endif
+_GL_FUNCDECL_RPL (fstatat, int,
+                  (int fd, char const *name, struct stat *st, int flags)
+                  _GL_ARG_NONNULL ((2, 3)));
+_GL_CXXALIAS_RPL (fstatat, int,
+                  (int fd, char const *name, struct stat *st, int flags));
+# else
+#  if !@HAVE_FSTATAT@
+_GL_FUNCDECL_SYS (fstatat, int,
+                  (int fd, char const *name, struct stat *st, int flags)
+                  _GL_ARG_NONNULL ((2, 3)));
+#  endif
+_GL_CXXALIAS_SYS (fstatat, int,
+                  (int fd, char const *name, struct stat *st, int flags));
+# endif
+_GL_CXXALIASWARN (fstatat);
+#elif defined GNULIB_POSIXCHECK
+# undef fstatat
+# if HAVE_RAW_DECL_FSTATAT
+_GL_WARN_ON_USE (fstatat, "fstatat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+#if @GNULIB_FUTIMENS@
+# if @REPLACE_FUTIMENS@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef futimens
+#   define futimens rpl_futimens
+#  endif
+_GL_FUNCDECL_RPL (futimens, int, (int fd, struct timespec const times[2]));
+_GL_CXXALIAS_RPL (futimens, int, (int fd, struct timespec const times[2]));
+# else
+#  if !@HAVE_FUTIMENS@
+_GL_FUNCDECL_SYS (futimens, int, (int fd, struct timespec const times[2]));
+#  endif
+_GL_CXXALIAS_SYS (futimens, int, (int fd, struct timespec const times[2]));
+# endif
+_GL_CXXALIASWARN (futimens);
+#elif defined GNULIB_POSIXCHECK
+# undef futimens
+# if HAVE_RAW_DECL_FUTIMENS
+_GL_WARN_ON_USE (futimens, "futimens is not portable - "
+                 "use gnulib module futimens for portability");
+# endif
+#endif
+
+
+#if @GNULIB_LCHMOD@
+/* Change the mode of FILENAME to MODE, without dereferencing it if FILENAME
+   denotes a symbolic link.  */
+# if !@HAVE_LCHMOD@
+/* The lchmod replacement follows symbolic links.  Callers should take
+   this into account; lchmod should be applied only to arguments that
+   are known to not be symbolic links.  On hosts that lack lchmod,
+   this can lead to race conditions between the check and the
+   invocation of lchmod, but we know of no workarounds that are
+   reliable in general.  You might try requesting support for lchmod
+   from your operating system supplier.  */
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define lchmod chmod
+#  endif
+/* Need to cast, because on mingw, the second parameter of chmod is
+                                                int mode.  */
+_GL_CXXALIAS_RPL_CAST_1 (lchmod, chmod, int,
+                         (const char *filename, mode_t mode));
+# else
+#  if 0 /* assume already declared */
+_GL_FUNCDECL_SYS (lchmod, int, (const char *filename, mode_t mode)
+                               _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (lchmod, int, (const char *filename, mode_t mode));
+# endif
+# if @HAVE_LCHMOD@
+_GL_CXXALIASWARN (lchmod);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef lchmod
+# if HAVE_RAW_DECL_LCHMOD
+_GL_WARN_ON_USE (lchmod, "lchmod is unportable - "
+                 "use gnulib module lchmod for portability");
+# endif
+#endif
+
+
+#if @GNULIB_LSTAT@
+# if ! @HAVE_LSTAT@
+/* mingw does not support symlinks, therefore it does not have lstat.  But
+   without links, stat does just fine.  */
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define lstat stat
+#  endif
+_GL_CXXALIAS_RPL_1 (lstat, stat, int, (const char *name, struct stat *buf));
+# elif @REPLACE_LSTAT@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef lstat
+#   define lstat rpl_lstat
+#  endif
+_GL_FUNCDECL_RPL (lstat, int, (const char *name, struct stat *buf)
+                              _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (lstat, int, (const char *name, struct stat *buf));
+# else
+_GL_CXXALIAS_SYS (lstat, int, (const char *name, struct stat *buf));
+# endif
+# if @HAVE_LSTAT@
+_GL_CXXALIASWARN (lstat);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef lstat
+# if HAVE_RAW_DECL_LSTAT
+_GL_WARN_ON_USE (lstat, "lstat is unportable - "
+                 "use gnulib module lstat for portability");
+# endif
+#endif
+
+
+#if @REPLACE_MKDIR@
+# if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#  undef mkdir
+#  define mkdir rpl_mkdir
+# endif
+_GL_FUNCDECL_RPL (mkdir, int, (char const *name, mode_t mode)
+                              _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mkdir, int, (char const *name, mode_t mode));
+#else
+/* mingw's _mkdir() function has 1 argument, but we pass 2 arguments.
+   Additionally, it declares _mkdir (and depending on compile flags, an
+   alias mkdir), only in the nonstandard includes <direct.h> and <io.h>,
+   which are included above.  */
+# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+
+static inline int
+rpl_mkdir (char const *name, mode_t mode)
+{
+  return _mkdir (name);
+}
+
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mkdir rpl_mkdir
+#  endif
+_GL_CXXALIAS_RPL (mkdir, int, (char const *name, mode_t mode));
+# else
+_GL_CXXALIAS_SYS (mkdir, int, (char const *name, mode_t mode));
+# endif
+#endif
+_GL_CXXALIASWARN (mkdir);
+
+
+#if @GNULIB_MKDIRAT@
+# if !@HAVE_MKDIRAT@
+_GL_FUNCDECL_SYS (mkdirat, int, (int fd, char const *file, mode_t mode)
+                                _GL_ARG_NONNULL ((2)));
+# endif
+_GL_CXXALIAS_SYS (mkdirat, int, (int fd, char const *file, mode_t mode));
+_GL_CXXALIASWARN (mkdirat);
+#elif defined GNULIB_POSIXCHECK
+# undef mkdirat
+# if HAVE_RAW_DECL_MKDIRAT
+_GL_WARN_ON_USE (mkdirat, "mkdirat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+#if @GNULIB_MKFIFO@
+# if @REPLACE_MKFIFO@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mkfifo
+#   define mkfifo rpl_mkfifo
+#  endif
+_GL_FUNCDECL_RPL (mkfifo, int, (char const *file, mode_t mode)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mkfifo, int, (char const *file, mode_t mode));
+# else
+#  if !@HAVE_MKFIFO@
+_GL_FUNCDECL_SYS (mkfifo, int, (char const *file, mode_t mode)
+                               _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (mkfifo, int, (char const *file, mode_t mode));
+# endif
+_GL_CXXALIASWARN (mkfifo);
+#elif defined GNULIB_POSIXCHECK
+# undef mkfifo
+# if HAVE_RAW_DECL_MKFIFO
+_GL_WARN_ON_USE (mkfifo, "mkfifo is not portable - "
+                 "use gnulib module mkfifo for portability");
+# endif
+#endif
+
+
+#if @GNULIB_MKFIFOAT@
+# if !@HAVE_MKFIFOAT@
+_GL_FUNCDECL_SYS (mkfifoat, int, (int fd, char const *file, mode_t mode)
+                                 _GL_ARG_NONNULL ((2)));
+# endif
+_GL_CXXALIAS_SYS (mkfifoat, int, (int fd, char const *file, mode_t mode));
+_GL_CXXALIASWARN (mkfifoat);
+#elif defined GNULIB_POSIXCHECK
+# undef mkfifoat
+# if HAVE_RAW_DECL_MKFIFOAT
+_GL_WARN_ON_USE (mkfifoat, "mkfifoat is not portable - "
+                 "use gnulib module mkfifoat for portability");
+# endif
+#endif
+
+
+#if @GNULIB_MKNOD@
+# if @REPLACE_MKNOD@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mknod
+#   define mknod rpl_mknod
+#  endif
+_GL_FUNCDECL_RPL (mknod, int, (char const *file, mode_t mode, dev_t dev)
+                              _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mknod, int, (char const *file, mode_t mode, dev_t dev));
+# else
+#  if !@HAVE_MKNOD@
+_GL_FUNCDECL_SYS (mknod, int, (char const *file, mode_t mode, dev_t dev)
+                              _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (mknod, int, (char const *file, mode_t mode, dev_t dev));
+# endif
+_GL_CXXALIASWARN (mknod);
+#elif defined GNULIB_POSIXCHECK
+# undef mknod
+# if HAVE_RAW_DECL_MKNOD
+_GL_WARN_ON_USE (mknod, "mknod is not portable - "
+                 "use gnulib module mknod for portability");
+# endif
+#endif
+
+
+#if @GNULIB_MKNODAT@
+# if !@HAVE_MKNODAT@
+_GL_FUNCDECL_SYS (mknodat, int,
+                  (int fd, char const *file, mode_t mode, dev_t dev)
+                  _GL_ARG_NONNULL ((2)));
+# endif
+_GL_CXXALIAS_SYS (mknodat, int,
+                  (int fd, char const *file, mode_t mode, dev_t dev));
+_GL_CXXALIASWARN (mknodat);
+#elif defined GNULIB_POSIXCHECK
+# undef mknodat
+# if HAVE_RAW_DECL_MKNODAT
+_GL_WARN_ON_USE (mknodat, "mknodat is not portable - "
+                 "use gnulib module mkfifoat for portability");
+# endif
+#endif
+
+
+#if @GNULIB_STAT@
+# if @REPLACE_STAT@
+/* We can't use the object-like #define stat rpl_stat, because of
+   struct stat.  This means that rpl_stat will not be used if the user
+   does (stat)(a,b).  Oh well.  */
+#  undef stat
+#  ifdef _LARGE_FILES
+    /* With _LARGE_FILES defined, AIX (only) defines stat to stat64,
+       so we have to replace stat64() instead of stat(). */
+#   define stat stat64
+#   undef stat64
+#   define stat64(name, st) rpl_stat (name, st)
+#  else /* !_LARGE_FILES */
+#   define stat(name, st) rpl_stat (name, st)
+#  endif /* !_LARGE_FILES */
+_GL_EXTERN_C int stat (const char *name, struct stat *buf) _GL_ARG_NONNULL ((1, 2));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef stat
+# if HAVE_RAW_DECL_STAT
+_GL_WARN_ON_USE (stat, "stat is unportable - "
+                 "use gnulib module stat for portability");
+# endif
+#endif
+
+
+#if @GNULIB_UTIMENSAT@
+# if @REPLACE_UTIMENSAT@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef utimensat
+#   define utimensat rpl_utimensat
+#  endif
+_GL_FUNCDECL_RPL (utimensat, int, (int fd, char const *name,
+                                   struct timespec const times[2], int flag)
+                                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (utimensat, int, (int fd, char const *name,
+                                   struct timespec const times[2], int flag));
+# else
+#  if !@HAVE_UTIMENSAT@
+_GL_FUNCDECL_SYS (utimensat, int, (int fd, char const *name,
+                                   struct timespec const times[2], int flag)
+                                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (utimensat, int, (int fd, char const *name,
+                                   struct timespec const times[2], int flag));
+# endif
+_GL_CXXALIASWARN (utimensat);
+#elif defined GNULIB_POSIXCHECK
+# undef utimensat
+# if HAVE_RAW_DECL_UTIMENSAT
+_GL_WARN_ON_USE (utimensat, "utimensat is not portable - "
+                 "use gnulib module utimensat for portability");
+# endif
+#endif
+
+
+#endif /* _GL_SYS_STAT_H */
+#endif /* _GL_SYS_STAT_H */
+#endif
--- /dev/null
+++ b/gltests/test-alloca-opt.c
@@ -0,0 +1,62 @@
+/* Test of optional automatic memory allocation.
+   Copyright (C) 2005, 2007, 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2007.  */
+
+#include <config.h>
+
+#include <alloca.h>
+
+#if HAVE_ALLOCA
+
+static void
+do_allocation (int n)
+{
+  void *ptr = alloca (n);
+  (void) ptr;
+}
+
+void (*func) (int) = do_allocation;
+
+#endif
+
+int
+main ()
+{
+#if HAVE_ALLOCA
+  int i;
+
+  /* Repeat a lot of times, to make sure there's no memory leak.  */
+  for (i = 0; i < 100000; i++)
+    {
+      /* Try various values.
+         n = 0 gave a crash on Alpha with gcc-2.5.8.
+         Some versions of MacOS X have a stack size limit of 512 KB.  */
+      func (34);
+      func (134);
+      func (399);
+      func (510823);
+      func (129321);
+      func (0);
+      func (4070);
+      func (4095);
+      func (1);
+      func (16582);
+    }
+#endif
+
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-binary-io.c
@@ -0,0 +1,64 @@
+/* Test of binary mode I/O.
+   Copyright (C) 2005, 2007-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2005.  */
+
+#include <config.h>
+
+#include "binary-io.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "macros.h"
+
+int
+main ()
+{
+  /* Test the O_BINARY macro.  */
+  {
+    int fd =
+      open ("t-bin-out2.tmp", O_CREAT | O_TRUNC | O_RDWR | O_BINARY, 0600);
+    if (write (fd, "Hello\n", 6) < 0)
+      exit (1);
+    close (fd);
+  }
+  {
+    struct stat statbuf;
+    if (stat ("t-bin-out2.tmp", &statbuf) < 0)
+      exit (1);
+    ASSERT (statbuf.st_size == 6);
+  }
+  unlink ("t-bin-out2.tmp");
+
+  /* Test the SET_BINARY macro.  */
+  SET_BINARY (1);
+  fputs ("Hello\n", stdout);
+  fclose (stdout);
+  fclose (stderr);
+  {
+    struct stat statbuf;
+    if (stat ("t-bin-out1.tmp", &statbuf) < 0)
+      exit (1);
+    ASSERT (statbuf.st_size == 6);
+  }
+
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-binary-io.sh
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+tmpfiles=""
+trap 'rm -fr $tmpfiles' 1 2 3 15
+
+tmpfiles="$tmpfiles t-bin-out1.tmp t-bin-out2.tmp"
+./test-binary-io${EXEEXT} > t-bin-out1.tmp || exit 1
+
+rm -fr $tmpfiles
+
+exit 0
--- /dev/null
+++ b/gltests/test-dup2.c
@@ -0,0 +1,193 @@
+/* Test duplicating file descriptors.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake <ebb9@byu.net>, 2009.  */
+
+#include <config.h>
+
+#include <unistd.h>
+
+#include "signature.h"
+SIGNATURE_CHECK (dup2, int, (int, int));
+
+#include <errno.h>
+#include <fcntl.h>
+
+#include "binary-io.h"
+
+#if GNULIB_TEST_CLOEXEC
+# include "cloexec.h"
+#endif
+
+#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+/* Get declarations of the Win32 API functions.  */
+# define WIN32_LEAN_AND_MEAN
+# include <windows.h>
+#endif
+
+#include "macros.h"
+
+/* Return non-zero if FD is open.  */
+static int
+is_open (int fd)
+{
+#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+  /* On Win32, the initial state of unassigned standard file
+     descriptors is that they are open but point to an
+     INVALID_HANDLE_VALUE, and there is no fcntl.  */
+  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;
+#else
+# ifndef F_GETFL
+#  error Please port fcntl to your platform
+# endif
+  return 0 <= fcntl (fd, F_GETFL);
+#endif
+}
+
+#if GNULIB_TEST_CLOEXEC
+/* Return non-zero if FD is open and inheritable across exec/spawn.  */
+static int
+is_inheritable (int fd)
+{
+# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+  /* On Win32, the initial state of unassigned standard file
+     descriptors is that they are open but point to an
+     INVALID_HANDLE_VALUE, and there is no fcntl.  */
+  HANDLE h = (HANDLE) _get_osfhandle (fd);
+  DWORD flags;
+  if (h == INVALID_HANDLE_VALUE || GetHandleInformation (h, &flags) == 0)
+    return 0;
+  return (flags & HANDLE_FLAG_INHERIT) != 0;
+# else
+#  ifndef F_GETFD
+#   error Please port fcntl to your platform
+#  endif
+  int i = fcntl (fd, F_GETFD);
+  return 0 <= i && (i & FD_CLOEXEC) == 0;
+# endif
+}
+#endif /* GNULIB_TEST_CLOEXEC */
+
+#if !O_BINARY
+# define setmode(f,m) zero ()
+static int zero (void) { return 0; }
+#endif
+
+/* Return non-zero if FD is open in the given MODE, which is either
+   O_TEXT or O_BINARY.  */
+static int
+is_mode (int fd, int mode)
+{
+  int value = setmode (fd, O_BINARY);
+  setmode (fd, value);
+  return mode == value;
+}
+
+int
+main (void)
+{
+  const char *file = "test-dup2.tmp";
+  char buffer[1];
+  int fd = open (file, O_CREAT | O_TRUNC | O_RDWR, 0600);
+
+  /* Assume std descriptors were provided by invoker.  */
+  ASSERT (STDERR_FILENO < fd);
+  ASSERT (is_open (fd));
+  /* Ignore any other fd's leaked into this process.  */
+  close (fd + 1);
+  close (fd + 2);
+  ASSERT (!is_open (fd + 1));
+  ASSERT (!is_open (fd + 2));
+
+  /* Assigning to self must be a no-op.  */
+  ASSERT (dup2 (fd, fd) == fd);
+  ASSERT (is_open (fd));
+
+  /* The source must be valid.  */
+  errno = 0;
+  ASSERT (dup2 (-1, fd) == -1);
+  ASSERT (errno == EBADF);
+  errno = 0;
+  ASSERT (dup2 (AT_FDCWD, fd) == -1);
+  ASSERT (errno == EBADF);
+  ASSERT (is_open (fd));
+
+  /* If the source is not open, then the destination is unaffected.  */
+  errno = 0;
+  ASSERT (dup2 (fd + 1, fd + 1) == -1);
+  ASSERT (errno == EBADF);
+  ASSERT (!is_open (fd + 1));
+  errno = 0;
+  ASSERT (dup2 (fd + 1, fd) == -1);
+  ASSERT (errno == EBADF);
+  ASSERT (is_open (fd));
+
+  /* The destination must be valid.  */
+  errno = 0;
+  ASSERT (dup2 (fd, -2) == -1);
+  ASSERT (errno == EBADF);
+  errno = 0;
+  ASSERT (dup2 (fd, 10000000) == -1);
+  ASSERT (errno == EBADF);
+
+  /* Using dup2 can skip fds.  */
+  ASSERT (dup2 (fd, fd + 2) == fd + 2);
+  ASSERT (is_open (fd));
+  ASSERT (!is_open (fd + 1));
+  ASSERT (is_open (fd + 2));
+
+  /* Verify that dup2 closes the previous occupant of a fd.  */
+  ASSERT (open ("/dev/null", O_WRONLY, 0600) == fd + 1);
+  ASSERT (dup2 (fd + 1, fd) == fd);
+  ASSERT (close (fd + 1) == 0);
+  ASSERT (write (fd, "1", 1) == 1);
+  ASSERT (dup2 (fd + 2, fd) == fd);
+  ASSERT (lseek (fd, 0, SEEK_END) == 0);
+  ASSERT (write (fd + 2, "2", 1) == 1);
+  ASSERT (lseek (fd, 0, SEEK_SET) == 0);
+  ASSERT (read (fd, buffer, 1) == 1);
+  ASSERT (*buffer == '2');
+
+#if GNULIB_TEST_CLOEXEC
+  /* Any new fd created by dup2 must not be cloexec.  */
+  ASSERT (close (fd + 2) == 0);
+  ASSERT (dup_cloexec (fd) == fd + 1);
+  ASSERT (!is_inheritable (fd + 1));
+  ASSERT (dup2 (fd + 1, fd + 1) == fd + 1);
+  ASSERT (!is_inheritable (fd + 1));
+  ASSERT (dup2 (fd + 1, fd + 2) == fd + 2);
+  ASSERT (is_inheritable (fd + 2));
+#endif
+
+  /* On systems that distinguish between text and binary mode, dup2
+     reuses the mode of the source.  */
+  setmode (fd, O_BINARY);
+  ASSERT (is_mode (fd, O_BINARY));
+  ASSERT (dup2 (fd, fd + 1) == fd + 1);
+  ASSERT (is_mode (fd + 1, O_BINARY));
+  setmode (fd, O_TEXT);
+  ASSERT (is_mode (fd, O_TEXT));
+  ASSERT (dup2 (fd, fd + 1) == fd + 1);
+  ASSERT (is_mode (fd + 1, O_TEXT));
+
+  /* Clean up.  */
+  ASSERT (close (fd + 2) == 0);
+  ASSERT (close (fd + 1) == 0);
+  ASSERT (close (fd) == 0);
+  ASSERT (unlink (file) == 0);
+
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-environ.c
@@ -0,0 +1,44 @@
+/* Test of environ variable.
+   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2008.  */
+
+#include <config.h>
+
+#include <unistd.h>
+
+#include <string.h>
+
+int
+main ()
+{
+  /* The environment variables that are set even in the weirdest situations
+     are HOME and PATH.
+     POSIX says that HOME is initialized by the system, and that PATH may be
+     unset.  But in practice it's more frequent to see HOME unset and PATH
+     set.  So we test the presence of PATH.  */
+  char **remaining_variables = environ;
+  char *string;
+
+  for (; (string = *remaining_variables) != NULL; remaining_variables++)
+    {
+      if (strncmp (string, "PATH=", 5) == 0)
+        /* Found the PATH environment variable.  */
+        return 0;
+    }
+  /* Failed to find the PATH environment variable.  */
+  return 1;
+}
--- a/gltests/test-errno.c
+++ b/gltests/test-errno.c
@@ -1,5 +1,5 @@
 /* Test of <errno.h> substitute.
-   Copyright (C) 2008 Free Software Foundation, Inc.
+   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
--- /dev/null
+++ b/gltests/test-fcntl-h.c
@@ -0,0 +1,38 @@
+/* Test of <fcntl.h> substitute.
+   Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2007.  */
+
+#include <config.h>
+
+#include <fcntl.h>
+
+/* Check that the various O_* macros are defined.  */
+int o = O_DIRECT | O_DIRECTORY | O_DSYNC | O_NDELAY | O_NOATIME | O_NONBLOCK
+        | O_NOCTTY | O_NOFOLLOW | O_NOLINKS | O_RSYNC | O_SYNC | O_TTY_INIT
+        | O_BINARY | O_TEXT;
+
+/* Check that the various SEEK_* macros are defined.  */
+int sk[] = { SEEK_CUR, SEEK_END, SEEK_SET };
+
+/* Check that the FD_* macros are defined.  */
+int fd = FD_CLOEXEC;
+
+int
+main (void)
+{
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-getopt.c
@@ -0,0 +1,99 @@
+/* Test of command line argument processing.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2009.  */
+
+#include <config.h>
+
+/* None of the files accessed by this test are large, so disable the
+   ftell link warning if we are not using the gnulib ftell module.  */
+#define _GL_NO_LARGE_FILES
+
+#if GNULIB_TEST_GETOPT_GNU
+# include <getopt.h>
+
+# ifndef __getopt_argv_const
+#  define __getopt_argv_const const
+# endif
+# include "signature.h"
+SIGNATURE_CHECK (getopt_long, int, (int, char *__getopt_argv_const *,
+                                    char const *, struct option const *,
+                                    int *));
+SIGNATURE_CHECK (getopt_long_only, int, (int, char *__getopt_argv_const *,
+                                         char const *, struct option const *,
+                                         int *));
+
+#endif
+
+#include <unistd.h>
+
+#include "signature.h"
+SIGNATURE_CHECK (getopt, int, (int, char * const[], char const *));
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+/* This test intentionally remaps stderr.  So, we arrange to have fd 10
+   (outside the range of interesting fd's during the test) set up to
+   duplicate the original stderr.  */
+
+#define BACKUP_STDERR_FILENO 10
+#define ASSERT_STREAM myerr
+#include "macros.h"
+
+static FILE *myerr;
+
+#include "test-getopt.h"
+#if GNULIB_TEST_GETOPT_GNU
+# include "test-getopt_long.h"
+#endif
+
+int
+main (void)
+{
+   /* This test validates that stderr is used correctly, so move the
+      original into fd 10.  */
+  if (dup2 (STDERR_FILENO, BACKUP_STDERR_FILENO) != BACKUP_STDERR_FILENO
+      || (myerr = fdopen (BACKUP_STDERR_FILENO, "w")) == NULL)
+    return 2;
+
+  ASSERT (freopen ("test-getopt.tmp", "w", stderr) == stderr);
+
+  /* These default values are required by POSIX.  */
+  ASSERT (optind == 1);
+  ASSERT (opterr != 0);
+
+  setenv ("POSIXLY_CORRECT", "1", 1);
+  test_getopt ();
+
+#if GNULIB_TEST_GETOPT_GNU
+  test_getopt_long_posix ();
+#endif
+
+  unsetenv ("POSIXLY_CORRECT");
+  test_getopt ();
+
+#if GNULIB_TEST_GETOPT_GNU
+  test_getopt_long ();
+  test_getopt_long_only ();
+#endif
+
+  ASSERT (fclose (stderr) == 0);
+  ASSERT (remove ("test-getopt.tmp") == 0);
+
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-getopt.h
@@ -0,0 +1,1369 @@
+/* Test of command line argument processing.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2009.  */
+
+#include <stdbool.h>
+
+/* The glibc/gnulib implementation of getopt supports setting optind =
+   0, but not all other implementations do.  This matters for getopt.
+   But for getopt_long, we require GNU compatibility.  */
+#if defined __GETOPT_PREFIX || (__GLIBC__ >= 2)
+# define OPTIND_MIN 0
+#elif HAVE_DECL_OPTRESET
+# define OPTIND_MIN (optreset = 1)
+#else
+# define OPTIND_MIN 1
+#endif
+
+static void
+getopt_loop (int argc, const char **argv,
+             const char *options,
+             int *a_seen, int *b_seen,
+             const char **p_value, const char **q_value,
+             int *non_options_count, const char **non_options,
+             int *unrecognized, bool *message_issued)
+{
+  int c;
+  int pos = ftell (stderr);
+
+  while ((c = getopt (argc, (char **) argv, options)) != -1)
+    {
+      switch (c)
+        {
+        case 'a':
+          (*a_seen)++;
+          break;
+        case 'b':
+          (*b_seen)++;
+          break;
+        case 'p':
+          *p_value = optarg;
+          break;
+        case 'q':
+          *q_value = optarg;
+          break;
+        case '\1':
+          /* Must only happen with option '-' at the beginning.  */
+          ASSERT (options[0] == '-');
+          non_options[(*non_options_count)++] = optarg;
+          break;
+        case ':':
+          /* Must only happen with option ':' at the beginning.  */
+          ASSERT (options[0] == ':'
+                  || ((options[0] == '-' || options[0] == '+')
+                      && options[1] == ':'));
+          /* fall through */
+        case '?':
+          *unrecognized = optopt;
+          break;
+        default:
+          *unrecognized = c;
+          break;
+        }
+    }
+
+  *message_issued = pos < ftell (stderr);
+}
+
+static void
+test_getopt (void)
+{
+  int start;
+  bool posixly = !!getenv ("POSIXLY_CORRECT");
+  /* See comment in getopt.c:
+     glibc gets a LSB-compliant getopt.
+     Standalone applications get a POSIX-compliant getopt.  */
+#if defined __GETOPT_PREFIX || !(__GLIBC__ >= 2 || defined __MINGW32__)
+  /* Using getopt from gnulib or from a non-glibc system.  */
+  posixly = true;
+#endif
+
+  /* Test processing of boolean options.  */
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-a";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "ab",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+      ASSERT (!output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-b";
+      argv[argc++] = "-a";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "ab",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 3);
+      ASSERT (!output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-ba";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "ab",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+      ASSERT (!output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-ab";
+      argv[argc++] = "-a";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "ab",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 2);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 3);
+      ASSERT (!output);
+    }
+
+  /* Test processing of options with arguments.  */
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-pfoo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "p:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+      ASSERT (!output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "p:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 3);
+      ASSERT (!output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-ab";
+      argv[argc++] = "-q";
+      argv[argc++] = "baz";
+      argv[argc++] = "-pfoo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value != NULL && strcmp (q_value, "baz") == 0);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 5);
+      ASSERT (!output);
+    }
+
+#if GNULIB_TEST_GETOPT_GNU
+  /* Test processing of options with optional arguments.  */
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-pfoo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "p::q::",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+      ASSERT (!output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "p::q::",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+      ASSERT (!output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "abp::q::",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 3);
+      ASSERT (!output);
+    }
+#endif /* GNULIB_TEST_GETOPT_GNU */
+
+  /* Check that invalid options are recognized; and that both opterr
+     and leading ':' can silence output.  */
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "foo";
+      argv[argc++] = "-x";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 42;
+      getopt_loop (argc, argv, "abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 'x');
+      ASSERT (optind == 5);
+      ASSERT (output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "foo";
+      argv[argc++] = "-x";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 0;
+      getopt_loop (argc, argv, "abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 'x');
+      ASSERT (optind == 5);
+      ASSERT (!output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "foo";
+      argv[argc++] = "-x";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, ":abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 'x');
+      ASSERT (optind == 5);
+      ASSERT (!output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "foo";
+      argv[argc++] = "-:";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 42;
+      getopt_loop (argc, argv, "abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == ':');
+      ASSERT (optind == 5);
+      ASSERT (output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "foo";
+      argv[argc++] = "-:";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 0;
+      getopt_loop (argc, argv, "abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == ':');
+      ASSERT (optind == 5);
+      ASSERT (!output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "foo";
+      argv[argc++] = "-:";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, ":abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == ':');
+      ASSERT (optind == 5);
+      ASSERT (!output);
+    }
+
+  /* Check for missing argument behavior.  */
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-ap";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 'p');
+      ASSERT (optind == 2);
+      ASSERT (output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-ap";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 0;
+      getopt_loop (argc, argv, "abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 'p');
+      ASSERT (optind == 2);
+      ASSERT (!output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-ap";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, ":abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 'p');
+      ASSERT (optind == 2);
+      ASSERT (!output);
+    }
+
+  /* Check that by default, non-options arguments are moved to the end.  */
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      if (posixly)
+        {
+          ASSERT (strcmp (argv[0], "program") == 0);
+          ASSERT (strcmp (argv[1], "donald") == 0);
+          ASSERT (strcmp (argv[2], "-p") == 0);
+          ASSERT (strcmp (argv[3], "billy") == 0);
+          ASSERT (strcmp (argv[4], "duck") == 0);
+          ASSERT (strcmp (argv[5], "-a") == 0);
+          ASSERT (strcmp (argv[6], "bar") == 0);
+          ASSERT (argv[7] == NULL);
+          ASSERT (a_seen == 0);
+          ASSERT (b_seen == 0);
+          ASSERT (p_value == NULL);
+          ASSERT (q_value == NULL);
+          ASSERT (non_options_count == 0);
+          ASSERT (unrecognized == 0);
+          ASSERT (optind == 1);
+          ASSERT (!output);
+        }
+      else
+        {
+          ASSERT (strcmp (argv[0], "program") == 0);
+          ASSERT (strcmp (argv[1], "-p") == 0);
+          ASSERT (strcmp (argv[2], "billy") == 0);
+          ASSERT (strcmp (argv[3], "-a") == 0);
+          ASSERT (strcmp (argv[4], "donald") == 0);
+          ASSERT (strcmp (argv[5], "duck") == 0);
+          ASSERT (strcmp (argv[6], "bar") == 0);
+          ASSERT (argv[7] == NULL);
+          ASSERT (a_seen == 1);
+          ASSERT (b_seen == 0);
+          ASSERT (p_value != NULL && strcmp (p_value, "billy") == 0);
+          ASSERT (q_value == NULL);
+          ASSERT (non_options_count == 0);
+          ASSERT (unrecognized == 0);
+          ASSERT (optind == 4);
+          ASSERT (!output);
+        }
+    }
+
+  /* Check that '--' ends the argument processing.  */
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[20];
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "--";
+      argv[argc++] = "-b";
+      argv[argc++] = "foo";
+      argv[argc++] = "-q";
+      argv[argc++] = "johnny";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      if (posixly)
+        {
+          ASSERT (strcmp (argv[0], "program") == 0);
+          ASSERT (strcmp (argv[1], "donald") == 0);
+          ASSERT (strcmp (argv[2], "-p") == 0);
+          ASSERT (strcmp (argv[3], "billy") == 0);
+          ASSERT (strcmp (argv[4], "duck") == 0);
+          ASSERT (strcmp (argv[5], "-a") == 0);
+          ASSERT (strcmp (argv[6], "--") == 0);
+          ASSERT (strcmp (argv[7], "-b") == 0);
+          ASSERT (strcmp (argv[8], "foo") == 0);
+          ASSERT (strcmp (argv[9], "-q") == 0);
+          ASSERT (strcmp (argv[10], "johnny") == 0);
+          ASSERT (strcmp (argv[11], "bar") == 0);
+          ASSERT (argv[12] == NULL);
+          ASSERT (a_seen == 0);
+          ASSERT (b_seen == 0);
+          ASSERT (p_value == NULL);
+          ASSERT (q_value == NULL);
+          ASSERT (non_options_count == 0);
+          ASSERT (unrecognized == 0);
+          ASSERT (optind == 1);
+          ASSERT (!output);
+        }
+      else
+        {
+          ASSERT (strcmp (argv[0], "program") == 0);
+          ASSERT (strcmp (argv[1], "-p") == 0);
+          ASSERT (strcmp (argv[2], "billy") == 0);
+          ASSERT (strcmp (argv[3], "-a") == 0);
+          ASSERT (strcmp (argv[4], "--") == 0);
+          ASSERT (strcmp (argv[5], "donald") == 0);
+          ASSERT (strcmp (argv[6], "duck") == 0);
+          ASSERT (strcmp (argv[7], "-b") == 0);
+          ASSERT (strcmp (argv[8], "foo") == 0);
+          ASSERT (strcmp (argv[9], "-q") == 0);
+          ASSERT (strcmp (argv[10], "johnny") == 0);
+          ASSERT (strcmp (argv[11], "bar") == 0);
+          ASSERT (argv[12] == NULL);
+          ASSERT (a_seen == 1);
+          ASSERT (b_seen == 0);
+          ASSERT (p_value != NULL && strcmp (p_value, "billy") == 0);
+          ASSERT (q_value == NULL);
+          ASSERT (non_options_count == 0);
+          ASSERT (unrecognized == 0);
+          ASSERT (optind == 5);
+          ASSERT (!output);
+        }
+    }
+
+#if GNULIB_TEST_GETOPT_GNU
+  /* Check that the '-' flag causes non-options to be returned in order.  */
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "-abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (strcmp (argv[0], "program") == 0);
+      ASSERT (strcmp (argv[1], "donald") == 0);
+      ASSERT (strcmp (argv[2], "-p") == 0);
+      ASSERT (strcmp (argv[3], "billy") == 0);
+      ASSERT (strcmp (argv[4], "duck") == 0);
+      ASSERT (strcmp (argv[5], "-a") == 0);
+      ASSERT (strcmp (argv[6], "bar") == 0);
+      ASSERT (argv[7] == NULL);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "billy") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 3);
+      ASSERT (strcmp (non_options[0], "donald") == 0);
+      ASSERT (strcmp (non_options[1], "duck") == 0);
+      ASSERT (strcmp (non_options[2], "bar") == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 7);
+      ASSERT (!output);
+    }
+
+  /* Check that '--' ends the argument processing.  */
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[20];
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "--";
+      argv[argc++] = "-b";
+      argv[argc++] = "foo";
+      argv[argc++] = "-q";
+      argv[argc++] = "johnny";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "-abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (strcmp (argv[0], "program") == 0);
+      ASSERT (strcmp (argv[1], "donald") == 0);
+      ASSERT (strcmp (argv[2], "-p") == 0);
+      ASSERT (strcmp (argv[3], "billy") == 0);
+      ASSERT (strcmp (argv[4], "duck") == 0);
+      ASSERT (strcmp (argv[5], "-a") == 0);
+      ASSERT (strcmp (argv[6], "--") == 0);
+      ASSERT (strcmp (argv[7], "-b") == 0);
+      ASSERT (strcmp (argv[8], "foo") == 0);
+      ASSERT (strcmp (argv[9], "-q") == 0);
+      ASSERT (strcmp (argv[10], "johnny") == 0);
+      ASSERT (strcmp (argv[11], "bar") == 0);
+      ASSERT (argv[12] == NULL);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "billy") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (!output);
+      if (non_options_count == 2)
+        {
+          /* glibc behaviour.  */
+          ASSERT (non_options_count == 2);
+          ASSERT (strcmp (non_options[0], "donald") == 0);
+          ASSERT (strcmp (non_options[1], "duck") == 0);
+          ASSERT (unrecognized == 0);
+          ASSERT (optind == 7);
+        }
+      else
+        {
+          /* Another valid behaviour.  */
+          ASSERT (non_options_count == 7);
+          ASSERT (strcmp (non_options[0], "donald") == 0);
+          ASSERT (strcmp (non_options[1], "duck") == 0);
+          ASSERT (strcmp (non_options[2], "-b") == 0);
+          ASSERT (strcmp (non_options[3], "foo") == 0);
+          ASSERT (strcmp (non_options[4], "-q") == 0);
+          ASSERT (strcmp (non_options[5], "johnny") == 0);
+          ASSERT (strcmp (non_options[6], "bar") == 0);
+          ASSERT (unrecognized == 0);
+          ASSERT (optind == 12);
+        }
+    }
+
+  /* Check that the '-' flag has to come first.  */
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "abp:q:-",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      if (posixly)
+        {
+          ASSERT (strcmp (argv[0], "program") == 0);
+          ASSERT (strcmp (argv[1], "donald") == 0);
+          ASSERT (strcmp (argv[2], "-p") == 0);
+          ASSERT (strcmp (argv[3], "billy") == 0);
+          ASSERT (strcmp (argv[4], "duck") == 0);
+          ASSERT (strcmp (argv[5], "-a") == 0);
+          ASSERT (strcmp (argv[6], "bar") == 0);
+          ASSERT (argv[7] == NULL);
+          ASSERT (a_seen == 0);
+          ASSERT (b_seen == 0);
+          ASSERT (p_value == NULL);
+          ASSERT (q_value == NULL);
+          ASSERT (non_options_count == 0);
+          ASSERT (unrecognized == 0);
+          ASSERT (optind == 1);
+          ASSERT (!output);
+        }
+      else
+        {
+          ASSERT (strcmp (argv[0], "program") == 0);
+          ASSERT (strcmp (argv[1], "-p") == 0);
+          ASSERT (strcmp (argv[2], "billy") == 0);
+          ASSERT (strcmp (argv[3], "-a") == 0);
+          ASSERT (strcmp (argv[4], "donald") == 0);
+          ASSERT (strcmp (argv[5], "duck") == 0);
+          ASSERT (strcmp (argv[6], "bar") == 0);
+          ASSERT (argv[7] == NULL);
+          ASSERT (a_seen == 1);
+          ASSERT (b_seen == 0);
+          ASSERT (p_value != NULL && strcmp (p_value, "billy") == 0);
+          ASSERT (q_value == NULL);
+          ASSERT (non_options_count == 0);
+          ASSERT (unrecognized == 0);
+          ASSERT (optind == 4);
+          ASSERT (!output);
+        }
+    }
+
+  /* Check that the '+' flag causes the first non-option to terminate the
+     loop.  */
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "+abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (strcmp (argv[0], "program") == 0);
+      ASSERT (strcmp (argv[1], "donald") == 0);
+      ASSERT (strcmp (argv[2], "-p") == 0);
+      ASSERT (strcmp (argv[3], "billy") == 0);
+      ASSERT (strcmp (argv[4], "duck") == 0);
+      ASSERT (strcmp (argv[5], "-a") == 0);
+      ASSERT (strcmp (argv[6], "bar") == 0);
+      ASSERT (argv[7] == NULL);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 1);
+      ASSERT (!output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-+";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_loop (argc, argv, "+abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == '+');
+      ASSERT (optind == 2);
+      ASSERT (output);
+    }
+
+  /* Check that '--' ends the argument processing.  */
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[20];
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "--";
+      argv[argc++] = "-b";
+      argv[argc++] = "foo";
+      argv[argc++] = "-q";
+      argv[argc++] = "johnny";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "+abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (strcmp (argv[0], "program") == 0);
+      ASSERT (strcmp (argv[1], "donald") == 0);
+      ASSERT (strcmp (argv[2], "-p") == 0);
+      ASSERT (strcmp (argv[3], "billy") == 0);
+      ASSERT (strcmp (argv[4], "duck") == 0);
+      ASSERT (strcmp (argv[5], "-a") == 0);
+      ASSERT (strcmp (argv[6], "--") == 0);
+      ASSERT (strcmp (argv[7], "-b") == 0);
+      ASSERT (strcmp (argv[8], "foo") == 0);
+      ASSERT (strcmp (argv[9], "-q") == 0);
+      ASSERT (strcmp (argv[10], "johnny") == 0);
+      ASSERT (strcmp (argv[11], "bar") == 0);
+      ASSERT (argv[12] == NULL);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind = 1);
+      ASSERT (!output);
+    }
+#endif /* GNULIB_TEST_GETOPT_GNU */
+
+  /* Check that the '+' flag has to come first.  */
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "abp:q:+",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      if (posixly)
+        {
+          ASSERT (strcmp (argv[0], "program") == 0);
+          ASSERT (strcmp (argv[1], "donald") == 0);
+          ASSERT (strcmp (argv[2], "-p") == 0);
+          ASSERT (strcmp (argv[3], "billy") == 0);
+          ASSERT (strcmp (argv[4], "duck") == 0);
+          ASSERT (strcmp (argv[5], "-a") == 0);
+          ASSERT (strcmp (argv[6], "bar") == 0);
+          ASSERT (argv[7] == NULL);
+          ASSERT (a_seen == 0);
+          ASSERT (b_seen == 0);
+          ASSERT (p_value == NULL);
+          ASSERT (q_value == NULL);
+          ASSERT (non_options_count == 0);
+          ASSERT (unrecognized == 0);
+          ASSERT (optind == 1);
+          ASSERT (!output);
+        }
+      else
+        {
+          ASSERT (strcmp (argv[0], "program") == 0);
+          ASSERT (strcmp (argv[1], "-p") == 0);
+          ASSERT (strcmp (argv[2], "billy") == 0);
+          ASSERT (strcmp (argv[3], "-a") == 0);
+          ASSERT (strcmp (argv[4], "donald") == 0);
+          ASSERT (strcmp (argv[5], "duck") == 0);
+          ASSERT (strcmp (argv[6], "bar") == 0);
+          ASSERT (argv[7] == NULL);
+          ASSERT (a_seen == 1);
+          ASSERT (b_seen == 0);
+          ASSERT (p_value != NULL && strcmp (p_value, "billy") == 0);
+          ASSERT (q_value == NULL);
+          ASSERT (non_options_count == 0);
+          ASSERT (unrecognized == 0);
+          ASSERT (optind == 4);
+          ASSERT (!output);
+        }
+    }
+
+#if GNULIB_TEST_GETOPT_GNU
+  /* If GNU extensions are supported, require compliance with POSIX
+     interpretation on leading '+' behavior.
+     http://austingroupbugs.net/view.php?id=191  */
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      opterr = 1;
+      getopt_loop (argc, argv, "+:abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (strcmp (argv[0], "program") == 0);
+      ASSERT (strcmp (argv[1], "donald") == 0);
+      ASSERT (strcmp (argv[2], "-p") == 0);
+      ASSERT (strcmp (argv[3], "billy") == 0);
+      ASSERT (strcmp (argv[4], "duck") == 0);
+      ASSERT (strcmp (argv[5], "-a") == 0);
+      ASSERT (strcmp (argv[6], "bar") == 0);
+      ASSERT (argv[7] == NULL);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 1);
+      ASSERT (!output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_loop (argc, argv, "+:abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 'p');
+      ASSERT (optind == 2);
+      ASSERT (!output);
+    }
+  for (start = OPTIND_MIN; start <= 1; start++)
+    {
+      int a_seen = 0;
+      int b_seen = 0;
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      bool output;
+      int argc = 0;
+      const char *argv[10];
+
+      argv[argc++] = "program";
+      argv[argc++] = "-b";
+      argv[argc++] = "-p";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_loop (argc, argv, "+:abp:q:",
+                   &a_seen, &b_seen, &p_value, &q_value,
+                   &non_options_count, non_options, &unrecognized, &output);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 'p');
+      ASSERT (optind == 3);
+      ASSERT (!output);
+    }
+#endif /* GNULIB_TEST_GETOPT_GNU */
+}
--- /dev/null
+++ b/gltests/test-getopt_long.h
@@ -0,0 +1,2125 @@
+/* Test of command line argument processing.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2009.  */
+
+static int a_seen;
+static int b_seen;
+static int q_seen;
+
+static const struct option long_options_required[] =
+  {
+    { "alpha",    no_argument,       NULL, 'a' },
+    { "beta",     no_argument,       &b_seen, 1 },
+    { "prune",    required_argument, NULL, 'p' },
+    { "quetsche", required_argument, &q_seen, 1 },
+    { "xtremely-",no_argument,       NULL, 1003 },
+    { "xtra",     no_argument,       NULL, 1001 },
+    { "xtreme",   no_argument,       NULL, 1002 },
+    { "xtremely", no_argument,       NULL, 1003 },
+    { NULL,       0,                 NULL, 0 }
+  };
+
+static const struct option long_options_optional[] =
+  {
+    { "alpha",    no_argument,       NULL, 'a' },
+    { "beta",     no_argument,       &b_seen, 1 },
+    { "prune",    optional_argument, NULL, 'p' },
+    { "quetsche", optional_argument, &q_seen, 1 },
+    { NULL,       0,                 NULL, 0 }
+  };
+
+static void
+getopt_long_loop (int argc, const char **argv,
+                  const char *options, const struct option *long_options,
+                  const char **p_value, const char **q_value,
+                  int *non_options_count, const char **non_options,
+                  int *unrecognized)
+{
+  int option_index = -1;
+  int c;
+
+  opterr = 0;
+  q_seen = 0;
+  while ((c = getopt_long (argc, (char **) argv, options, long_options,
+                           &option_index))
+         != -1)
+    {
+      switch (c)
+        {
+        case 0:
+          /* An option with a non-NULL flag pointer was processed.  */
+          if (q_seen)
+            *q_value = optarg;
+          break;
+        case 'a':
+          a_seen++;
+          break;
+        case 'b':
+          b_seen = 1;
+          break;
+        case 'p':
+          *p_value = optarg;
+          break;
+        case 'q':
+          *q_value = optarg;
+          break;
+        case '\1':
+          /* Must only happen with option '-' at the beginning.  */
+          ASSERT (options[0] == '-');
+          non_options[(*non_options_count)++] = optarg;
+          break;
+        case ':':
+          /* Must only happen with option ':' at the beginning.  */
+          ASSERT (options[0] == ':'
+                  || ((options[0] == '-' || options[0] == '+')
+                      && options[1] == ':'));
+          /* fall through */
+        case '?':
+          *unrecognized = optopt;
+          break;
+        default:
+          *unrecognized = c;
+          break;
+        }
+    }
+}
+
+/* Reduce casting, so we can use string literals elsewhere.
+   getopt_long takes an array of char*, but luckily does not modify
+   those elements, so we can pass const char*.  */
+static int
+do_getopt_long (int argc, const char **argv, const char *shortopts,
+                const struct option *longopts, int *longind)
+{
+  return getopt_long (argc, (char **) argv, shortopts, longopts, longind);
+}
+
+static void
+test_getopt_long (void)
+{
+  int start;
+
+  /* Test disambiguation of options.  */
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "--x";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long (argc, argv, "ab", long_options_required, &option_index);
+    ASSERT (c == '?');
+    ASSERT (optopt == 0);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "--xt";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long (argc, argv, "ab", long_options_required, &option_index);
+    ASSERT (c == '?');
+    ASSERT (optopt == 0);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "--xtr";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long (argc, argv, "ab", long_options_required, &option_index);
+    ASSERT (c == '?');
+    ASSERT (optopt == 0);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "--xtra";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long (argc, argv, "ab", long_options_required, &option_index);
+    ASSERT (c == 1001);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "--xtre";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long (argc, argv, "ab", long_options_required, &option_index);
+    ASSERT (c == '?');
+    ASSERT (optopt == 0);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "--xtrem";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long (argc, argv, "ab", long_options_required, &option_index);
+    ASSERT (c == '?');
+    ASSERT (optopt == 0);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "--xtreme";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long (argc, argv, "ab", long_options_required, &option_index);
+    ASSERT (c == 1002);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "--xtremel";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long (argc, argv, "ab", long_options_required, &option_index);
+    ASSERT (c == 1003);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "--xtremely";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long (argc, argv, "ab", long_options_required, &option_index);
+    ASSERT (c == 1003);
+  }
+
+  /* Check that -W handles unknown options.  */
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "-W";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long (argc, argv, "W;", long_options_required, &option_index);
+    ASSERT (c == '?');
+    ASSERT (optopt == 'W');
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "-Wunknown";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long (argc, argv, "W;", long_options_required, &option_index);
+    /* glibc and BSD behave differently here, but for now, we allow
+       both behaviors since W support is not frequently used.  */
+    if (c == '?')
+      {
+        ASSERT (optopt == 0);
+        ASSERT (optarg == NULL);
+      }
+    else
+      {
+        ASSERT (c == 'W');
+        ASSERT (strcmp (optarg, "unknown") == 0);
+      }
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "-W";
+    argv[argc++] = "unknown";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long (argc, argv, "W;", long_options_required, &option_index);
+    /* glibc and BSD behave differently here, but for now, we allow
+       both behaviors since W support is not frequently used.  */
+    if (c == '?')
+      {
+        ASSERT (optopt == 0);
+        ASSERT (optarg == NULL);
+      }
+    else
+      {
+        ASSERT (c == 'W');
+        ASSERT (strcmp (optarg, "unknown") == 0);
+      }
+  }
+
+  /* Test processing of boolean short options.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-a";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "ab", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-b";
+      argv[argc++] = "-a";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "ab", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 3);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-ba";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "ab", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-ab";
+      argv[argc++] = "-a";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "ab", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 2);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 3);
+    }
+
+  /* Test processing of boolean long options.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "--alpha";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "ab", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "--beta";
+      argv[argc++] = "--alpha";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "ab", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 3);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "--alpha";
+      argv[argc++] = "--beta";
+      argv[argc++] = "--alpha";
+      argv[argc++] = "--beta";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "ab", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 2);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 5);
+    }
+
+  /* Test processing of boolean long options via -W.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-Walpha";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "abW;", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-W";
+      argv[argc++] = "beta";
+      argv[argc++] = "-W";
+      argv[argc++] = "alpha";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "aW;b", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 5);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-Walpha";
+      argv[argc++] = "-Wbeta";
+      argv[argc++] = "-Walpha";
+      argv[argc++] = "-Wbeta";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "W;ab", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 2);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 5);
+    }
+
+  /* Test processing of short options with arguments.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-pfoo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "p:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "p:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 3);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-ab";
+      argv[argc++] = "-q";
+      argv[argc++] = "baz";
+      argv[argc++] = "-pfoo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value != NULL && strcmp (q_value, "baz") == 0);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 5);
+    }
+
+  /* Test processing of long options with arguments.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "--p=foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "p:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "--p";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "p:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 3);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-ab";
+      argv[argc++] = "--q";
+      argv[argc++] = "baz";
+      argv[argc++] = "--p=foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value != NULL && strcmp (q_value, "baz") == 0);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 5);
+    }
+
+  /* Test processing of long options with arguments via -W.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-Wp=foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "p:q:W;", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-W";
+      argv[argc++] = "p";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "p:W;q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 4);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-ab";
+      argv[argc++] = "-Wq";
+      argv[argc++] = "baz";
+      argv[argc++] = "-W";
+      argv[argc++] = "p=foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "W;abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value != NULL && strcmp (q_value, "baz") == 0);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 6);
+    }
+
+  /* Test processing of short options with optional arguments.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-pfoo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "p::q::", long_options_optional,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "p::q::", long_options_optional,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "abp::q::", long_options_optional,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 3);
+    }
+
+  /* Test processing of long options with optional arguments.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "--p=foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "p::q::", long_options_optional,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "--p";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "p::q::", long_options_optional,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "--p=";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "p::q::", long_options_optional,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && *p_value == '\0');
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "--p";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "abp::q::", long_options_optional,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 3);
+    }
+
+  /* Test processing of long options with optional arguments via -W.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-Wp=foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "p::q::W;", long_options_optional,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-Wp";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "p::q::W;", long_options_optional,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-Wp=";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "W;p::q::", long_options_optional,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && *p_value == '\0');
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-W";
+      argv[argc++] = "p=";
+      argv[argc++] = "foo";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "W;p::q::", long_options_optional,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && *p_value == '\0');
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 3);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-W";
+      argv[argc++] = "p";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "W;abp::q::", long_options_optional,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      /* ASSERT (p_value == NULL); */
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 4);
+    }
+
+  /* Check that invalid options are recognized.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "foo";
+      argv[argc++] = "-x";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 'x');
+      ASSERT (optind == 5);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "foo";
+      argv[argc++] = "-:";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == ':');
+      ASSERT (optind == 5);
+    }
+
+  /* Check that unexpected arguments are recognized.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "foo";
+      argv[argc++] = "--a=";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 'a');
+      ASSERT (optind == 4);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "foo";
+      argv[argc++] = "--b=";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "foo") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      /* When flag is non-zero, glibc sets optopt anyway, but BSD
+         leaves optopt unchanged.  */
+      ASSERT (unrecognized == 1 || unrecognized == 0);
+      ASSERT (optind == 4);
+    }
+
+  /* Check that by default, non-options arguments are moved to the end.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (strcmp (argv[0], "program") == 0);
+      ASSERT (strcmp (argv[1], "-p") == 0);
+      ASSERT (strcmp (argv[2], "billy") == 0);
+      ASSERT (strcmp (argv[3], "-a") == 0);
+      ASSERT (strcmp (argv[4], "donald") == 0);
+      ASSERT (strcmp (argv[5], "duck") == 0);
+      ASSERT (strcmp (argv[6], "bar") == 0);
+      ASSERT (argv[7] == NULL);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "billy") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 4);
+    }
+
+  /* Check that '--' ends the argument processing.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[20];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "--";
+      argv[argc++] = "-b";
+      argv[argc++] = "foo";
+      argv[argc++] = "-q";
+      argv[argc++] = "johnny";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (strcmp (argv[0], "program") == 0);
+      ASSERT (strcmp (argv[1], "-p") == 0);
+      ASSERT (strcmp (argv[2], "billy") == 0);
+      ASSERT (strcmp (argv[3], "-a") == 0);
+      ASSERT (strcmp (argv[4], "--") == 0);
+      ASSERT (strcmp (argv[5], "donald") == 0);
+      ASSERT (strcmp (argv[6], "duck") == 0);
+      ASSERT (strcmp (argv[7], "-b") == 0);
+      ASSERT (strcmp (argv[8], "foo") == 0);
+      ASSERT (strcmp (argv[9], "-q") == 0);
+      ASSERT (strcmp (argv[10], "johnny") == 0);
+      ASSERT (strcmp (argv[11], "bar") == 0);
+      ASSERT (argv[12] == NULL);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "billy") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 5);
+    }
+
+  /* Check that the '-' flag causes non-options to be returned in order.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "-abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (strcmp (argv[0], "program") == 0);
+      ASSERT (strcmp (argv[1], "donald") == 0);
+      ASSERT (strcmp (argv[2], "-p") == 0);
+      ASSERT (strcmp (argv[3], "billy") == 0);
+      ASSERT (strcmp (argv[4], "duck") == 0);
+      ASSERT (strcmp (argv[5], "-a") == 0);
+      ASSERT (strcmp (argv[6], "bar") == 0);
+      ASSERT (argv[7] == NULL);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "billy") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 3);
+      ASSERT (strcmp (non_options[0], "donald") == 0);
+      ASSERT (strcmp (non_options[1], "duck") == 0);
+      ASSERT (strcmp (non_options[2], "bar") == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 7);
+    }
+
+  /* Check that '--' ends the argument processing.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[20];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "--";
+      argv[argc++] = "-b";
+      argv[argc++] = "foo";
+      argv[argc++] = "-q";
+      argv[argc++] = "johnny";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "-abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (strcmp (argv[0], "program") == 0);
+      ASSERT (strcmp (argv[1], "donald") == 0);
+      ASSERT (strcmp (argv[2], "-p") == 0);
+      ASSERT (strcmp (argv[3], "billy") == 0);
+      ASSERT (strcmp (argv[4], "duck") == 0);
+      ASSERT (strcmp (argv[5], "-a") == 0);
+      ASSERT (strcmp (argv[6], "--") == 0);
+      ASSERT (strcmp (argv[7], "-b") == 0);
+      ASSERT (strcmp (argv[8], "foo") == 0);
+      ASSERT (strcmp (argv[9], "-q") == 0);
+      ASSERT (strcmp (argv[10], "johnny") == 0);
+      ASSERT (strcmp (argv[11], "bar") == 0);
+      ASSERT (argv[12] == NULL);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "billy") == 0);
+      ASSERT (q_value == NULL);
+      if (non_options_count == 2)
+      {
+        /* glibc behaviour.  */
+        ASSERT (non_options_count == 2);
+        ASSERT (strcmp (non_options[0], "donald") == 0);
+        ASSERT (strcmp (non_options[1], "duck") == 0);
+        ASSERT (unrecognized == 0);
+        ASSERT (optind == 7);
+      }
+      else
+      {
+        /* Another valid behaviour.  */
+        ASSERT (non_options_count == 7);
+        ASSERT (strcmp (non_options[0], "donald") == 0);
+        ASSERT (strcmp (non_options[1], "duck") == 0);
+        ASSERT (strcmp (non_options[2], "-b") == 0);
+        ASSERT (strcmp (non_options[3], "foo") == 0);
+        ASSERT (strcmp (non_options[4], "-q") == 0);
+        ASSERT (strcmp (non_options[5], "johnny") == 0);
+        ASSERT (strcmp (non_options[6], "bar") == 0);
+        ASSERT (unrecognized == 0);
+        ASSERT (optind == 12);
+      }
+    }
+
+  /* Check that the '-' flag has to come first.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "abp:q:-", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (strcmp (argv[0], "program") == 0);
+      ASSERT (strcmp (argv[1], "-p") == 0);
+      ASSERT (strcmp (argv[2], "billy") == 0);
+      ASSERT (strcmp (argv[3], "-a") == 0);
+      ASSERT (strcmp (argv[4], "donald") == 0);
+      ASSERT (strcmp (argv[5], "duck") == 0);
+      ASSERT (strcmp (argv[6], "bar") == 0);
+      ASSERT (argv[7] == NULL);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "billy") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 4);
+    }
+
+  /* Check that the '+' flag causes the first non-option to terminate the
+     loop.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "+abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (strcmp (argv[0], "program") == 0);
+      ASSERT (strcmp (argv[1], "donald") == 0);
+      ASSERT (strcmp (argv[2], "-p") == 0);
+      ASSERT (strcmp (argv[3], "billy") == 0);
+      ASSERT (strcmp (argv[4], "duck") == 0);
+      ASSERT (strcmp (argv[5], "-a") == 0);
+      ASSERT (strcmp (argv[6], "bar") == 0);
+      ASSERT (argv[7] == NULL);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 1);
+    }
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-+";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "+abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == '+');
+      ASSERT (optind == 2);
+    }
+
+  /* Check that '--' ends the argument processing.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[20];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "--";
+      argv[argc++] = "-b";
+      argv[argc++] = "foo";
+      argv[argc++] = "-q";
+      argv[argc++] = "johnny";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "+abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (strcmp (argv[0], "program") == 0);
+      ASSERT (strcmp (argv[1], "donald") == 0);
+      ASSERT (strcmp (argv[2], "-p") == 0);
+      ASSERT (strcmp (argv[3], "billy") == 0);
+      ASSERT (strcmp (argv[4], "duck") == 0);
+      ASSERT (strcmp (argv[5], "-a") == 0);
+      ASSERT (strcmp (argv[6], "--") == 0);
+      ASSERT (strcmp (argv[7], "-b") == 0);
+      ASSERT (strcmp (argv[8], "foo") == 0);
+      ASSERT (strcmp (argv[9], "-q") == 0);
+      ASSERT (strcmp (argv[10], "johnny") == 0);
+      ASSERT (strcmp (argv[11], "bar") == 0);
+      ASSERT (argv[12] == NULL);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind = 1);
+    }
+
+  /* Check that the '+' flag has to come first.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "abp:q:+", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (strcmp (argv[0], "program") == 0);
+      ASSERT (strcmp (argv[1], "-p") == 0);
+      ASSERT (strcmp (argv[2], "billy") == 0);
+      ASSERT (strcmp (argv[3], "-a") == 0);
+      ASSERT (strcmp (argv[4], "donald") == 0);
+      ASSERT (strcmp (argv[5], "duck") == 0);
+      ASSERT (strcmp (argv[6], "bar") == 0);
+      ASSERT (argv[7] == NULL);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value != NULL && strcmp (p_value, "billy") == 0);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 4);
+    }
+}
+
+/* Test behavior of getopt_long when POSIXLY_CORRECT is set in the
+   environment.  Options with optional arguments should not change
+   behavior just because of an environment variable.
+   http://lists.gnu.org/archive/html/bug-m4/2006-09/msg00028.html  */
+static void
+test_getopt_long_posix (void)
+{
+  int start;
+
+  /* Check that POSIXLY_CORRECT stops parsing the same as leading '+'.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "donald";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc++] = "duck";
+      argv[argc++] = "-a";
+      argv[argc++] = "bar";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "abp:q:", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (strcmp (argv[0], "program") == 0);
+      ASSERT (strcmp (argv[1], "donald") == 0);
+      ASSERT (strcmp (argv[2], "-p") == 0);
+      ASSERT (strcmp (argv[3], "billy") == 0);
+      ASSERT (strcmp (argv[4], "duck") == 0);
+      ASSERT (strcmp (argv[5], "-a") == 0);
+      ASSERT (strcmp (argv[6], "bar") == 0);
+      ASSERT (argv[7] == NULL);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 1);
+    }
+
+  /* Check that POSIXLY_CORRECT doesn't change optional arguments.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-p";
+      argv[argc++] = "billy";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "p::", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 0);
+      ASSERT (b_seen == 0);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 2);
+    }
+
+  /* Check that leading - still sees options after non-options.  */
+  for (start = 0; start <= 1; start++)
+    {
+      const char *p_value = NULL;
+      const char *q_value = NULL;
+      int non_options_count = 0;
+      const char *non_options[10];
+      int unrecognized = 0;
+      int argc = 0;
+      const char *argv[10];
+      a_seen = 0;
+      b_seen = 0;
+
+      argv[argc++] = "program";
+      argv[argc++] = "-a";
+      argv[argc++] = "billy";
+      argv[argc++] = "-b";
+      argv[argc] = NULL;
+      optind = start;
+      getopt_long_loop (argc, argv, "-ab", long_options_required,
+                        &p_value, &q_value,
+                        &non_options_count, non_options, &unrecognized);
+      ASSERT (a_seen == 1);
+      ASSERT (b_seen == 1);
+      ASSERT (p_value == NULL);
+      ASSERT (q_value == NULL);
+      ASSERT (non_options_count == 1);
+      ASSERT (strcmp (non_options[0], "billy") == 0);
+      ASSERT (unrecognized == 0);
+      ASSERT (optind == 4);
+    }
+}
+
+/* Reduce casting, so we can use string literals elsewhere.
+   getopt_long_only takes an array of char*, but luckily does not
+   modify those elements, so we can pass const char*.  */
+static int
+do_getopt_long_only (int argc, const char **argv, const char *shortopts,
+                     const struct option *longopts, int *longind)
+{
+  return getopt_long_only (argc, (char **) argv, shortopts, longopts, longind);
+}
+
+static void
+test_getopt_long_only (void)
+{
+  /* Test disambiguation of options.  */
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "-x";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long_only (argc, argv, "ab", long_options_required,
+                             &option_index);
+    ASSERT (c == '?');
+    ASSERT (optopt == 0);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "-x";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long_only (argc, argv, "abx", long_options_required,
+                             &option_index);
+    ASSERT (c == 'x');
+    ASSERT (optopt == 0);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "--x";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long_only (argc, argv, "abx", long_options_required,
+                             &option_index);
+    ASSERT (c == '?');
+    ASSERT (optopt == 0);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "-b";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    b_seen = 0;
+    c = do_getopt_long_only (argc, argv, "abx", long_options_required,
+                             &option_index);
+    ASSERT (c == 'b');
+    ASSERT (b_seen == 0);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "--b";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    b_seen = 0;
+    c = do_getopt_long_only (argc, argv, "abx", long_options_required,
+                             &option_index);
+    ASSERT (c == 0);
+    ASSERT (b_seen == 1);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "-xt";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long_only (argc, argv, "ab", long_options_required,
+                             &option_index);
+    ASSERT (c == '?');
+    ASSERT (optopt == 0);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "-xt";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long_only (argc, argv, "abx", long_options_required,
+                             &option_index);
+    ASSERT (c == '?');
+    ASSERT (optopt == 0);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "-xtra";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long_only (argc, argv, "ab", long_options_required,
+                             &option_index);
+    ASSERT (c == 1001);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "-xtreme";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long_only (argc, argv, "abx:", long_options_required,
+                             &option_index);
+    ASSERT (c == 1002);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "-xtremel";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long_only (argc, argv, "ab", long_options_required,
+                             &option_index);
+    /* glibc getopt_long_only is intentionally different from
+       getopt_long when handling a prefix that is common to two
+       spellings, when both spellings have the same option directives.
+       BSD getopt_long_only treats both cases the same.  */
+    ASSERT (c == 1003 || c == '?');
+    ASSERT (optind == 2);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "-xtremel";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long_only (argc, argv, "abx::", long_options_required,
+                             &option_index);
+    /* glibc getopt_long_only is intentionally different from
+       getopt_long when handling a prefix that is common to two
+       spellings, when both spellings have the same option directives.
+       BSD getopt_long_only treats both cases the same.  */
+    ASSERT (c == 1003 || c == '?');
+    ASSERT (optind == 2);
+    ASSERT (optarg == NULL);
+  }
+  {
+    int argc = 0;
+    const char *argv[10];
+    int option_index;
+    int c;
+
+    argv[argc++] = "program";
+    argv[argc++] = "-xtras";
+    argv[argc] = NULL;
+    optind = 1;
+    opterr = 0;
+    c = do_getopt_long_only (argc, argv, "abx::", long_options_required,
+                             &option_index);
+    ASSERT (c == 'x');
+    ASSERT (strcmp (optarg, "tras") == 0);
+  }
+}
--- /dev/null
+++ b/gltests/test-lstat.c
@@ -0,0 +1,60 @@
+/* Test of lstat() function.
+   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Simon Josefsson, 2008; and Eric Blake, 2009.  */
+
+#include <config.h>
+
+#include <sys/stat.h>
+
+/* Caution: lstat may be a function-like macro.  Although this
+   signature check must pass, it may be the signature of the real (and
+   broken) lstat rather than rpl_lstat.  Most code should not use the
+   address of lstat.  */
+#include "signature.h"
+SIGNATURE_CHECK (lstat, int, (char const *, struct stat *));
+
+#include <fcntl.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "same-inode.h"
+#include "ignore-value.h"
+#include "macros.h"
+
+#define BASE "test-lstat.t"
+
+#include "test-lstat.h"
+
+/* Wrapper around lstat, which works even if lstat is a function-like
+   macro, where test_lstat_func(lstat) would do the wrong thing.  */
+static int
+do_lstat (char const *name, struct stat *st)
+{
+  return lstat (name, st);
+}
+
+int
+main (void)
+{
+  /* Remove any leftovers from a previous partial run.  */
+  ignore_value (system ("rm -rf " BASE "*"));
+
+  return test_lstat_func (do_lstat, true);
+}
--- /dev/null
+++ b/gltests/test-lstat.h
@@ -0,0 +1,116 @@
+/* Test of lstat() function.
+   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Simon Josefsson, 2008; and Eric Blake, 2009.  */
+
+/* This file is designed to test both lstat(n,buf) and
+   fstatat(AT_FDCWD,n,buf,AT_SYMLINK_NOFOLLOW).  FUNC is the function
+   to test.  Assumes that BASE and ASSERT are already defined, and
+   that appropriate headers are already included.  If PRINT, warn
+   before skipping symlink tests with status 77.  */
+
+static int
+test_lstat_func (int (*func) (char const *, struct stat *), bool print)
+{
+  struct stat st1;
+  struct stat st2;
+
+  /* Test for common directories.  */
+  ASSERT (func (".", &st1) == 0);
+  ASSERT (func ("./", &st2) == 0);
+  ASSERT (SAME_INODE (st1, st2));
+  ASSERT (S_ISDIR (st1.st_mode));
+  ASSERT (S_ISDIR (st2.st_mode));
+  ASSERT (func ("/", &st1) == 0);
+  ASSERT (func ("///", &st2) == 0);
+  ASSERT (SAME_INODE (st1, st2));
+  ASSERT (S_ISDIR (st1.st_mode));
+  ASSERT (S_ISDIR (st2.st_mode));
+  ASSERT (func ("..", &st1) == 0);
+  ASSERT (S_ISDIR (st1.st_mode));
+
+  /* Test for error conditions.  */
+  errno = 0;
+  ASSERT (func ("", &st1) == -1);
+  ASSERT (errno == ENOENT);
+  errno = 0;
+  ASSERT (func ("nosuch", &st1) == -1);
+  ASSERT (errno == ENOENT);
+  errno = 0;
+  ASSERT (func ("nosuch/", &st1) == -1);
+  ASSERT (errno == ENOENT);
+
+  ASSERT (close (creat (BASE "file", 0600)) == 0);
+  ASSERT (func (BASE "file", &st1) == 0);
+  ASSERT (S_ISREG (st1.st_mode));
+  errno = 0;
+  ASSERT (func (BASE "file/", &st1) == -1);
+  ASSERT (errno == ENOTDIR);
+
+  /* Now for some symlink tests, where supported.  We set up:
+     link1 -> directory
+     link2 -> file
+     link3 -> dangling
+     link4 -> loop
+     then test behavior both with and without trailing slash.
+  */
+  if (symlink (".", BASE "link1") != 0)
+    {
+      ASSERT (unlink (BASE "file") == 0);
+      if (print)
+        fputs ("skipping test: symlinks not supported on this file system\n",
+               stderr);
+      return 77;
+    }
+  ASSERT (symlink (BASE "file", BASE "link2") == 0);
+  ASSERT (symlink (BASE "nosuch", BASE "link3") == 0);
+  ASSERT (symlink (BASE "link4", BASE "link4") == 0);
+
+  ASSERT (func (BASE "link1", &st1) == 0);
+  ASSERT (S_ISLNK (st1.st_mode));
+  ASSERT (func (BASE "link1/", &st1) == 0);
+  ASSERT (stat (BASE "link1", &st2) == 0);
+  ASSERT (S_ISDIR (st1.st_mode));
+  ASSERT (S_ISDIR (st2.st_mode));
+  ASSERT (SAME_INODE (st1, st2));
+
+  ASSERT (func (BASE "link2", &st1) == 0);
+  ASSERT (S_ISLNK (st1.st_mode));
+  errno = 0;
+  ASSERT (func (BASE "link2/", &st1) == -1);
+  ASSERT (errno == ENOTDIR);
+
+  ASSERT (func (BASE "link3", &st1) == 0);
+  ASSERT (S_ISLNK (st1.st_mode));
+  errno = 0;
+  ASSERT (func (BASE "link3/", &st1) == -1);
+  ASSERT (errno == ENOENT);
+
+  ASSERT (func (BASE "link4", &st1) == 0);
+  ASSERT (S_ISLNK (st1.st_mode));
+  errno = 0;
+  ASSERT (func (BASE "link4/", &st1) == -1);
+  ASSERT (errno == ELOOP);
+
+  /* Cleanup.  */
+  ASSERT (unlink (BASE "file") == 0);
+  ASSERT (unlink (BASE "link1") == 0);
+  ASSERT (unlink (BASE "link2") == 0);
+  ASSERT (unlink (BASE "link3") == 0);
+  ASSERT (unlink (BASE "link4") == 0);
+
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-malloca.c
@@ -0,0 +1,59 @@
+/* Test of safe automatic memory allocation.
+   Copyright (C) 2005, 2007, 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2005.  */
+
+#include <config.h>
+
+#include "malloca.h"
+
+#include <stdlib.h>
+
+static void
+do_allocation (int n)
+{
+  void *ptr = malloca (n);
+  freea (ptr);
+  ptr = safe_alloca (n);
+}
+
+void (*func) (int) = do_allocation;
+
+int
+main ()
+{
+  int i;
+
+  /* Repeat a lot of times, to make sure there's no memory leak.  */
+  for (i = 0; i < 50000; i++)
+    {
+      /* Try various values.
+         n = 0 gave a crash on Alpha with gcc-2.5.8.
+         Some versions of MacOS X have a stack size limit of 512 KB.  */
+      func (34);
+      func (134);
+      func (399);
+      func (510823);
+      func (129321);
+      func (0);
+      func (4070);
+      func (4095);
+      func (1);
+      func (16582);
+    }
+
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-open.c
@@ -0,0 +1,41 @@
+/* Test of opening a file descriptor.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2007.  */
+
+#include <config.h>
+
+#include <fcntl.h>
+
+#include "signature.h"
+SIGNATURE_CHECK (open, int, (char const *, int, ...));
+
+#include <errno.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include "macros.h"
+
+#define BASE "test-open.t"
+
+#include "test-open.h"
+
+int
+main (void)
+{
+  return test_open (open, true);
+}
--- /dev/null
+++ b/gltests/test-open.h
@@ -0,0 +1,87 @@
+/* Test of opening a file descriptor.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2007.  */
+
+/* This file is designed to test both open(n,buf[,mode]) and
+   openat(AT_FDCWD,n,buf[,mode]).  FUNC is the function to test.
+   Assumes that BASE and ASSERT are already defined, and that
+   appropriate headers are already included.  If PRINT, warn before
+   skipping symlink tests with status 77.  */
+
+static int
+test_open (int (*func) (char const *, int, ...), bool print)
+{
+  int fd;
+  /* Remove anything from prior partial run.  */
+  unlink (BASE "file");
+
+  /* Cannot create directory.  */
+  errno = 0;
+  ASSERT (func ("nonexist.ent/", O_CREAT | O_RDONLY, 0600) == -1);
+  ASSERT (errno == ENOTDIR || errno == EISDIR || errno == ENOENT
+          || errno == EINVAL);
+
+  /* Create a regular file.  */
+  fd = func (BASE "file", O_CREAT | O_RDONLY, 0600);
+  ASSERT (0 <= fd);
+  ASSERT (close (fd) == 0);
+
+  /* Trailing slash handling.  */
+  errno = 0;
+  ASSERT (func (BASE "file/", O_RDONLY) == -1);
+  ASSERT (errno == ENOTDIR || errno == EISDIR || errno == EINVAL);
+
+  /* Directories cannot be opened for writing.  */
+  errno = 0;
+  ASSERT (func (".", O_WRONLY) == -1);
+  ASSERT (errno == EISDIR || errno == EACCES);
+
+  /* /dev/null must exist, and be writable.  */
+  fd = func ("/dev/null", O_RDONLY);
+  ASSERT (0 <= fd);
+  {
+    char c;
+    ASSERT (read (fd, &c, 1) == 0);
+  }
+  ASSERT (close (fd) == 0);
+  fd = func ("/dev/null", O_WRONLY);
+  ASSERT (0 <= fd);
+  ASSERT (write (fd, "c", 1) == 1);
+  ASSERT (close (fd) == 0);
+
+  /* Symlink handling, where supported.  */
+  if (symlink (BASE "file", BASE "link") != 0)
+    {
+      ASSERT (unlink (BASE "file") == 0);
+      if (print)
+        fputs ("skipping test: symlinks not supported on this file system\n",
+               stderr);
+      return 77;
+    }
+  errno = 0;
+  ASSERT (func (BASE "link/", O_RDONLY) == -1);
+  ASSERT (errno == ENOTDIR);
+  fd = func (BASE "link", O_RDONLY);
+  ASSERT (0 <= fd);
+  ASSERT (close (fd) == 0);
+
+  /* Cleanup.  */
+  ASSERT (unlink (BASE "file") == 0);
+  ASSERT (unlink (BASE "link") == 0);
+
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-setenv.c
@@ -0,0 +1,56 @@
+/* Tests of setenv.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake <ebb9@byu.net>, 2009.  */
+
+#include <config.h>
+
+#include <stdlib.h>
+
+#include "signature.h"
+SIGNATURE_CHECK (setenv, int, (char const *, char const *, int));
+
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "macros.h"
+
+int
+main (void)
+{
+  /* Test overwriting.  */
+  ASSERT (setenv ("a", "==", -1) == 0);
+  ASSERT (setenv ("a", "2", 0) == 0);
+  ASSERT (strcmp (getenv ("a"), "==") == 0);
+
+  /* Required to fail with EINVAL.  */
+  errno = 0;
+  ASSERT (setenv ("", "", 1) == -1);
+  ASSERT (errno == EINVAL);
+  errno = 0;
+  ASSERT (setenv ("a=b", "", 0) == -1);
+  ASSERT (errno == EINVAL);
+#if 0
+  /* glibc and gnulib's implementation guarantee this, but POSIX no
+     longer requires it: http://austingroupbugs.net/view.php?id=185  */
+  errno = 0;
+  ASSERT (setenv (NULL, "", 0) == -1);
+  ASSERT (errno == EINVAL);
+#endif
+
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-stat.c
@@ -0,0 +1,56 @@
+/* Tests of stat.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake <ebb9@byu.net>, 2009.  */
+
+#include <config.h>
+
+#include <sys/stat.h>
+
+/* Caution: stat may be a function-like macro.  Although this
+   signature check must pass, it may be the signature of the real (and
+   broken) stat rather than rpl_stat.  Most code should not use the
+   address of stat.  */
+#include "signature.h"
+SIGNATURE_CHECK (stat, int, (char const *, struct stat *));
+
+#include <fcntl.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include "pathmax.h"
+#include "same-inode.h"
+#include "macros.h"
+
+#define BASE "test-stat.t"
+
+#include "test-stat.h"
+
+/* Wrapper around stat, which works even if stat is a function-like
+   macro, where test_stat_func(stat) would do the wrong thing.  */
+static int
+do_stat (char const *name, struct stat *st)
+{
+  return stat (name, st);
+}
+
+int
+main (void)
+{
+  return test_stat_func (do_stat, true);
+}
--- /dev/null
+++ b/gltests/test-stat.h
@@ -0,0 +1,100 @@
+/* Tests of stat.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake <ebb9@byu.net>, 2009.  */
+
+/* This file is designed to test both stat(n,buf) and
+   fstatat(AT_FDCWD,n,buf,0).  FUNC is the function to test.  Assumes
+   that BASE and ASSERT are already defined, and that appropriate
+   headers are already included.  If PRINT, warn before skipping
+   symlink tests with status 77.  */
+
+static int
+test_stat_func (int (*func) (char const *, struct stat *), bool print)
+{
+  struct stat st1;
+  struct stat st2;
+  char cwd[PATH_MAX];
+
+  ASSERT (getcwd (cwd, PATH_MAX) == cwd);
+  ASSERT (func (".", &st1) == 0);
+  ASSERT (func ("./", &st2) == 0);
+  ASSERT (SAME_INODE (st1, st2));
+  ASSERT (func (cwd, &st2) == 0);
+  ASSERT (SAME_INODE (st1, st2));
+  ASSERT (func ("/", &st1) == 0);
+  ASSERT (func ("///", &st2) == 0);
+  ASSERT (SAME_INODE (st1, st2));
+
+  errno = 0;
+  ASSERT (func ("", &st1) == -1);
+  ASSERT (errno == ENOENT);
+  errno = 0;
+  ASSERT (func ("nosuch", &st1) == -1);
+  ASSERT (errno == ENOENT);
+  errno = 0;
+  ASSERT (func ("nosuch/", &st1) == -1);
+  ASSERT (errno == ENOENT);
+
+  ASSERT (close (creat (BASE "file", 0600)) == 0);
+  ASSERT (func (BASE "file", &st1) == 0);
+  errno = 0;
+  ASSERT (func (BASE "file/", &st1) == -1);
+  ASSERT (errno == ENOTDIR);
+
+  /* Now for some symlink tests, where supported.  We set up:
+     link1 -> directory
+     link2 -> file
+     link3 -> dangling
+     link4 -> loop
+     then test behavior with trailing slash.
+  */
+  if (symlink (".", BASE "link1") != 0)
+    {
+      ASSERT (unlink (BASE "file") == 0);
+      if (print)
+        fputs ("skipping test: symlinks not supported on this file system\n",
+               stderr);
+      return 77;
+    }
+  ASSERT (symlink (BASE "file", BASE "link2") == 0);
+  ASSERT (symlink (BASE "nosuch", BASE "link3") == 0);
+  ASSERT (symlink (BASE "link4", BASE "link4") == 0);
+
+  ASSERT (func (BASE "link1/", &st1) == 0);
+  ASSERT (S_ISDIR (st1.st_mode));
+
+  errno = 0;
+  ASSERT (func (BASE "link2/", &st1) == -1);
+  ASSERT (errno == ENOTDIR);
+
+  errno = 0;
+  ASSERT (func (BASE "link3/", &st1) == -1);
+  ASSERT (errno == ENOENT);
+
+  errno = 0;
+  ASSERT (func (BASE "link4/", &st1) == -1);
+  ASSERT (errno == ELOOP);
+
+  /* Cleanup.  */
+  ASSERT (unlink (BASE "file") == 0);
+  ASSERT (unlink (BASE "link1") == 0);
+  ASSERT (unlink (BASE "link2") == 0);
+  ASSERT (unlink (BASE "link3") == 0);
+  ASSERT (unlink (BASE "link4") == 0);
+
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-stdbool.c
@@ -0,0 +1,96 @@
+/* Test of <stdbool.h> substitute.
+   Copyright (C) 2002-2007, 2009-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2007.  */
+
+#include <config.h>
+
+#include <stdbool.h>
+
+#ifndef bool
+ "error: bool is not defined"
+#endif
+#ifndef false
+ "error: false is not defined"
+#endif
+#if false
+ "error: false is not 0"
+#endif
+#ifndef true
+ "error: true is not defined"
+#endif
+#if true != 1
+ "error: true is not 1"
+#endif
+#ifndef __bool_true_false_are_defined
+ "error: __bool_true_false_are_defined is not defined"
+#endif
+
+#if 0 /* Cannot be guaranteed with gnulib's <stdbool.h>.  */
+struct s { _Bool s: 1; _Bool t; } s;
+#endif
+
+char a[true == 1 ? 1 : -1];
+char b[false == 0 ? 1 : -1];
+char c[__bool_true_false_are_defined == 1 ? 1 : -1];
+#if 0 /* Cannot be guaranteed with gnulib's <stdbool.h>, at least,
+not for all compilers.  */
+char d[(bool) 0.5 == true ? 1 : -1];
+bool e = &s;
+char f[(_Bool) 0.0 == false ? 1 : -1];
+#endif
+char g[true];
+char h[sizeof (_Bool)];
+#if 0 /* See above.  */
+char i[sizeof s.t];
+#endif
+enum { j = false, k = true, l = false * true, m = true * 256 };
+_Bool n[m];
+char o[sizeof n == m * sizeof n[0] ? 1 : -1];
+char p[-1 - (_Bool) 0 < 0 && -1 - (bool) 0 < 0 ? 1 : -1];
+#if 0 /* Cannot be guaranteed with gnulib's <stdbool.h>.  */
+#if defined __xlc__ || defined __GNUC__
+ /* Catch a bug in IBM AIX xlc compiler version 6.0.0.0
+    reported by James Lemley on 2005-10-05; see
+    http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html
+    This test is not quite right, since xlc is allowed to
+    reject this program, as the initializer for xlcbug is
+    not one of the forms that C requires support for.
+    However, doing the test right would require a run-time
+    test, and that would make cross-compilation harder.
+    Let us hope that IBM fixes the xlc bug, and also adds
+    support for this kind of constant expression.  In the
+    meantime, this test will reject xlc, which is OK, since
+    our stdbool.h substitute should suffice.  We also test
+    this with GCC, where it should work, to detect more
+    quickly whether someone messes up the test in the
+    future.  */
+ char digs[] = "0123456789";
+ int xlcbug = 1 / (&(digs + 5)[-2 + (bool) 1] == &digs[4] ? 1 : -1);
+#endif
+#endif
+/* Catch a bug in an HP-UX C compiler.  See
+   http://gcc.gnu.org/ml/gcc-patches/2003-12/msg02303.html
+   http://lists.gnu.org/archive/html/bug-coreutils/2005-11/msg00161.html
+ */
+_Bool q = true;
+_Bool *pq = &q;
+
+int
+main ()
+{
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-stddef.c
@@ -0,0 +1,38 @@
+/* Test of <stddef.h> substitute.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake <ebb9@byu.net>, 2009.  */
+
+#include <config.h>
+
+#include <stddef.h>
+
+#include "verify.h"
+
+/* Check that appropriate types are defined.  */
+wchar_t a = 'c';
+ptrdiff_t b = 1;
+size_t c = 2;
+
+/* Check that NULL can be passed through varargs as a pointer type,
+   per POSIX 2008.  */
+verify (sizeof NULL == sizeof (void *));
+
+int
+main (void)
+{
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-stdint.c
@@ -0,0 +1,361 @@
+/* Test of <stdint.h> substitute.
+   Copyright (C) 2006-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2006.  */
+
+#include <config.h>
+
+/* Whether to enable pedantic checks. */
+#define DO_PEDANTIC 0
+
+#define __STDC_LIMIT_MACROS 1 /* to make it work also in C++ mode */
+#define __STDC_CONSTANT_MACROS 1 /* likewise */
+#include <stdint.h>
+
+#include "verify.h"
+#include "intprops.h"
+
+#if __GNUC__ >= 2 && DO_PEDANTIC
+# define verify_same_types(expr1,expr2)  \
+    extern void _verify_func(__LINE__) (__typeof__ (expr1) *); \
+    extern void _verify_func(__LINE__) (__typeof__ (expr2) *);
+# define _verify_func(line) _verify_func2(line)
+# define _verify_func2(line) verify_func_ ## line
+#else
+# define verify_same_types(expr1,expr2) extern void verify_func (int)
+#endif
+
+/* 7.18.1.1. Exact-width integer types */
+/* 7.18.2.1. Limits of exact-width integer types */
+
+int8_t a1[3] = { INT8_C (17), INT8_MIN, INT8_MAX };
+verify (TYPE_MINIMUM (int8_t) == INT8_MIN);
+verify (TYPE_MAXIMUM (int8_t) == INT8_MAX);
+verify_same_types (INT8_MIN, (int8_t) 0 + 0);
+verify_same_types (INT8_MAX, (int8_t) 0 + 0);
+
+int16_t a2[3] = { INT16_C (17), INT16_MIN, INT16_MAX };
+verify (TYPE_MINIMUM (int16_t) == INT16_MIN);
+verify (TYPE_MAXIMUM (int16_t) == INT16_MAX);
+verify_same_types (INT16_MIN, (int16_t) 0 + 0);
+verify_same_types (INT16_MAX, (int16_t) 0 + 0);
+
+int32_t a3[3] = { INT32_C (17), INT32_MIN, INT32_MAX };
+verify (TYPE_MINIMUM (int32_t) == INT32_MIN);
+verify (TYPE_MAXIMUM (int32_t) == INT32_MAX);
+verify_same_types (INT32_MIN, (int32_t) 0 + 0);
+verify_same_types (INT32_MAX, (int32_t) 0 + 0);
+
+#ifdef INT64_MAX
+int64_t a4[3] = { INT64_C (17), INT64_MIN, INT64_MAX };
+verify (TYPE_MINIMUM (int64_t) == INT64_MIN);
+verify (TYPE_MAXIMUM (int64_t) == INT64_MAX);
+verify_same_types (INT64_MIN, (int64_t) 0 + 0);
+verify_same_types (INT64_MAX, (int64_t) 0 + 0);
+#endif
+
+uint8_t b1[2] = { UINT8_C (17), UINT8_MAX };
+verify (TYPE_MAXIMUM (uint8_t) == UINT8_MAX);
+verify_same_types (UINT8_MAX, (uint8_t) 0 + 0);
+
+uint16_t b2[2] = { UINT16_C (17), UINT16_MAX };
+verify (TYPE_MAXIMUM (uint16_t) == UINT16_MAX);
+verify_same_types (UINT16_MAX, (uint16_t) 0 + 0);
+
+uint32_t b3[2] = { UINT32_C (17), UINT32_MAX };
+verify (TYPE_MAXIMUM (uint32_t) == UINT32_MAX);
+verify_same_types (UINT32_MAX, (uint32_t) 0 + 0);
+
+#ifdef UINT64_MAX
+uint64_t b4[2] = { UINT64_C (17), UINT64_MAX };
+verify (TYPE_MAXIMUM (uint64_t) == UINT64_MAX);
+verify_same_types (UINT64_MAX, (uint64_t) 0 + 0);
+#endif
+
+#if INT8_MIN && INT8_MAX && INT16_MIN && INT16_MAX && INT32_MIN && INT32_MAX
+/* ok */
+#else
+err or;
+#endif
+
+#if UINT8_MAX && UINT16_MAX && UINT32_MAX
+/* ok */
+#else
+err or;
+#endif
+
+/* 7.18.1.2. Minimum-width integer types */
+/* 7.18.2.2. Limits of minimum-width integer types */
+
+int_least8_t c1[3] = { 17, INT_LEAST8_MIN, INT_LEAST8_MAX };
+verify (TYPE_MINIMUM (int_least8_t) == INT_LEAST8_MIN);
+verify (TYPE_MAXIMUM (int_least8_t) == INT_LEAST8_MAX);
+verify_same_types (INT_LEAST8_MIN, (int_least8_t) 0 + 0);
+verify_same_types (INT_LEAST8_MAX, (int_least8_t) 0 + 0);
+
+int_least16_t c2[3] = { 17, INT_LEAST16_MIN, INT_LEAST16_MAX };
+verify (TYPE_MINIMUM (int_least16_t) == INT_LEAST16_MIN);
+verify (TYPE_MAXIMUM (int_least16_t) == INT_LEAST16_MAX);
+verify_same_types (INT_LEAST16_MIN, (int_least16_t) 0 + 0);
+verify_same_types (INT_LEAST16_MAX, (int_least16_t) 0 + 0);
+
+int_least32_t c3[3] = { 17, INT_LEAST32_MIN, INT_LEAST32_MAX };
+verify (TYPE_MINIMUM (int_least32_t) == INT_LEAST32_MIN);
+verify (TYPE_MAXIMUM (int_least32_t) == INT_LEAST32_MAX);
+verify_same_types (INT_LEAST32_MIN, (int_least32_t) 0 + 0);
+verify_same_types (INT_LEAST32_MAX, (int_least32_t) 0 + 0);
+
+#ifdef INT_LEAST64_MAX
+int_least64_t c4[3] = { 17, INT_LEAST64_MIN, INT_LEAST64_MAX };
+verify (TYPE_MINIMUM (int_least64_t) == INT_LEAST64_MIN);
+verify (TYPE_MAXIMUM (int_least64_t) == INT_LEAST64_MAX);
+verify_same_types (INT_LEAST64_MIN, (int_least64_t) 0 + 0);
+verify_same_types (INT_LEAST64_MAX, (int_least64_t) 0 + 0);
+#endif
+
+uint_least8_t d1[2] = { 17, UINT_LEAST8_MAX };
+verify (TYPE_MAXIMUM (uint_least8_t) == UINT_LEAST8_MAX);
+verify_same_types (UINT_LEAST8_MAX, (uint_least8_t) 0 + 0);
+
+uint_least16_t d2[2] = { 17, UINT_LEAST16_MAX };
+verify (TYPE_MAXIMUM (uint_least16_t) == UINT_LEAST16_MAX);
+verify_same_types (UINT_LEAST16_MAX, (uint_least16_t) 0 + 0);
+
+uint_least32_t d3[2] = { 17, UINT_LEAST32_MAX };
+verify (TYPE_MAXIMUM (uint_least32_t) == UINT_LEAST32_MAX);
+verify_same_types (UINT_LEAST32_MAX, (uint_least32_t) 0 + 0);
+
+#ifdef UINT_LEAST64_MAX
+uint_least64_t d4[2] = { 17, UINT_LEAST64_MAX };
+verify (TYPE_MAXIMUM (uint_least64_t) == UINT_LEAST64_MAX);
+verify_same_types (UINT_LEAST64_MAX, (uint_least64_t) 0 + 0);
+#endif
+
+#if INT_LEAST8_MIN && INT_LEAST8_MAX && INT_LEAST16_MIN && INT_LEAST16_MAX && INT_LEAST32_MIN && INT_LEAST32_MAX
+/* ok */
+#else
+err or;
+#endif
+
+#if UINT_LEAST8_MAX && UINT_LEAST16_MAX && UINT_LEAST32_MAX
+/* ok */
+#else
+err or;
+#endif
+
+/* 7.18.1.3. Fastest minimum-width integer types */
+/* 7.18.2.3. Limits of fastest minimum-width integer types */
+
+int_fast8_t e1[3] = { 17, INT_FAST8_MIN, INT_FAST8_MAX };
+verify (TYPE_MINIMUM (int_fast8_t) == INT_FAST8_MIN);
+verify (TYPE_MAXIMUM (int_fast8_t) == INT_FAST8_MAX);
+verify_same_types (INT_FAST8_MIN, (int_fast8_t) 0 + 0);
+verify_same_types (INT_FAST8_MAX, (int_fast8_t) 0 + 0);
+
+int_fast16_t e2[3] = { 17, INT_FAST16_MIN, INT_FAST16_MAX };
+verify (TYPE_MINIMUM (int_fast16_t) == INT_FAST16_MIN);
+verify (TYPE_MAXIMUM (int_fast16_t) == INT_FAST16_MAX);
+verify_same_types (INT_FAST16_MIN, (int_fast16_t) 0 + 0);
+verify_same_types (INT_FAST16_MAX, (int_fast16_t) 0 + 0);
+
+int_fast32_t e3[3] = { 17, INT_FAST32_MIN, INT_FAST32_MAX };
+verify (TYPE_MINIMUM (int_fast32_t) == INT_FAST32_MIN);
+verify (TYPE_MAXIMUM (int_fast32_t) == INT_FAST32_MAX);
+verify_same_types (INT_FAST32_MIN, (int_fast32_t) 0 + 0);
+verify_same_types (INT_FAST32_MAX, (int_fast32_t) 0 + 0);
+
+#ifdef INT_FAST64_MAX
+int_fast64_t e4[3] = { 17, INT_FAST64_MIN, INT_FAST64_MAX };
+verify (TYPE_MINIMUM (int_fast64_t) == INT_FAST64_MIN);
+verify (TYPE_MAXIMUM (int_fast64_t) == INT_FAST64_MAX);
+verify_same_types (INT_FAST64_MIN, (int_fast64_t) 0 + 0);
+verify_same_types (INT_FAST64_MAX, (int_fast64_t) 0 + 0);
+#endif
+
+uint_fast8_t f1[2] = { 17, UINT_FAST8_MAX };
+verify (TYPE_MAXIMUM (uint_fast8_t) == UINT_FAST8_MAX);
+verify_same_types (UINT_FAST8_MAX, (uint_fast8_t) 0 + 0);
+
+uint_fast16_t f2[2] = { 17, UINT_FAST16_MAX };
+verify (TYPE_MAXIMUM (uint_fast16_t) == UINT_FAST16_MAX);
+verify_same_types (UINT_FAST16_MAX, (uint_fast16_t) 0 + 0);
+
+uint_fast32_t f3[2] = { 17, UINT_FAST32_MAX };
+verify (TYPE_MAXIMUM (uint_fast32_t) == UINT_FAST32_MAX);
+verify_same_types (UINT_FAST32_MAX, (uint_fast32_t) 0 + 0);
+
+#ifdef UINT_FAST64_MAX
+uint_fast64_t f4[2] = { 17, UINT_FAST64_MAX };
+verify (TYPE_MAXIMUM (uint_fast64_t) == UINT_FAST64_MAX);
+verify_same_types (UINT_FAST64_MAX, (uint_fast64_t) 0 + 0);
+#endif
+
+#if INT_FAST8_MIN && INT_FAST8_MAX && INT_FAST16_MIN && INT_FAST16_MAX && INT_FAST32_MIN && INT_FAST32_MAX
+/* ok */
+#else
+err or;
+#endif
+
+#if UINT_FAST8_MAX && UINT_FAST16_MAX && UINT_FAST32_MAX
+/* ok */
+#else
+err or;
+#endif
+
+/* 7.18.1.4. Integer types capable of holding object pointers */
+/* 7.18.2.4. Limits of integer types capable of holding object pointers */
+
+intptr_t g[3] = { 17, INTPTR_MIN, INTPTR_MAX };
+verify (TYPE_MINIMUM (intptr_t) == INTPTR_MIN);
+verify (TYPE_MAXIMUM (intptr_t) == INTPTR_MAX);
+verify_same_types (INTPTR_MIN, (intptr_t) 0 + 0);
+verify_same_types (INTPTR_MAX, (intptr_t) 0 + 0);
+
+uintptr_t h[2] = { 17, UINTPTR_MAX };
+verify (TYPE_MAXIMUM (uintptr_t) == UINTPTR_MAX);
+verify_same_types (UINTPTR_MAX, (uintptr_t) 0 + 0);
+
+#if INTPTR_MIN && INTPTR_MAX && UINTPTR_MAX
+/* ok */
+#else
+err or;
+#endif
+
+/* 7.18.1.5. Greatest-width integer types */
+/* 7.18.2.5. Limits of greatest-width integer types */
+
+intmax_t i[3] = { INTMAX_C (17), INTMAX_MIN, INTMAX_MAX };
+verify (TYPE_MINIMUM (intmax_t) == INTMAX_MIN);
+verify (TYPE_MAXIMUM (intmax_t) == INTMAX_MAX);
+verify_same_types (INTMAX_MIN, (intmax_t) 0 + 0);
+verify_same_types (INTMAX_MAX, (intmax_t) 0 + 0);
+
+uintmax_t j[2] = { UINTMAX_C (17), UINTMAX_MAX };
+verify (TYPE_MAXIMUM (uintmax_t) == UINTMAX_MAX);
+verify_same_types (UINTMAX_MAX, (uintmax_t) 0 + 0);
+
+/* As of 2007, Sun C and HP-UX 10.20 cc don't support 'long long' constants in
+   the preprocessor.  */
+#if !(defined __SUNPRO_C || (defined __hpux && !defined __GNUC__))
+#if INTMAX_MIN && INTMAX_MAX && UINTMAX_MAX
+/* ok */
+#else
+err or;
+#endif
+#endif
+
+/* 7.18.3. Limits of other integer types */
+
+#include <stddef.h>
+
+verify (TYPE_MINIMUM (ptrdiff_t) == PTRDIFF_MIN);
+verify (TYPE_MAXIMUM (ptrdiff_t) == PTRDIFF_MAX);
+verify_same_types (PTRDIFF_MIN, (ptrdiff_t) 0 + 0);
+verify_same_types (PTRDIFF_MAX, (ptrdiff_t) 0 + 0);
+
+#if PTRDIFF_MIN && PTRDIFF_MAX
+/* ok */
+#else
+err or;
+#endif
+
+#include <signal.h>
+
+verify (TYPE_MINIMUM (sig_atomic_t) == SIG_ATOMIC_MIN);
+verify (TYPE_MAXIMUM (sig_atomic_t) == SIG_ATOMIC_MAX);
+verify_same_types (SIG_ATOMIC_MIN, (sig_atomic_t) 0 + 0);
+verify_same_types (SIG_ATOMIC_MAX, (sig_atomic_t) 0 + 0);
+
+#if SIG_ATOMIC_MIN != 17 && SIG_ATOMIC_MAX
+/* ok */
+#else
+err or;
+#endif
+
+verify (TYPE_MAXIMUM (size_t) == SIZE_MAX);
+verify_same_types (SIZE_MAX, (size_t) 0 + 0);
+
+#if SIZE_MAX
+/* ok */
+#else
+err or;
+#endif
+
+#if HAVE_WCHAR_T
+verify (TYPE_MINIMUM (wchar_t) == WCHAR_MIN);
+verify (TYPE_MAXIMUM (wchar_t) == WCHAR_MAX);
+verify_same_types (WCHAR_MIN, (wchar_t) 0 + 0);
+verify_same_types (WCHAR_MAX, (wchar_t) 0 + 0);
+
+# if WCHAR_MIN != 17 && WCHAR_MAX
+/* ok */
+# else
+err or;
+# endif
+#endif
+
+#if HAVE_WINT_T
+# include <wchar.h>
+
+verify (TYPE_MINIMUM (wint_t) == WINT_MIN);
+verify (TYPE_MAXIMUM (wint_t) == WINT_MAX);
+verify_same_types (WINT_MIN, (wint_t) 0 + 0);
+verify_same_types (WINT_MAX, (wint_t) 0 + 0);
+
+# if WINT_MIN != 17 && WINT_MAX
+/* ok */
+# else
+err or;
+# endif
+#endif
+
+/* 7.18.4. Macros for integer constants */
+
+verify (INT8_C (17) == 17);
+verify_same_types (INT8_C (17), (int_least8_t)0 + 0);
+verify (UINT8_C (17) == 17);
+verify_same_types (UINT8_C (17), (uint_least8_t)0 + 0);
+
+verify (INT16_C (17) == 17);
+verify_same_types (INT16_C (17), (int_least16_t)0 + 0);
+verify (UINT16_C (17) == 17);
+verify_same_types (UINT16_C (17), (uint_least16_t)0 + 0);
+
+verify (INT32_C (17) == 17);
+verify_same_types (INT32_C (17), (int_least32_t)0 + 0);
+verify (UINT32_C (17) == 17);
+verify_same_types (UINT32_C (17), (uint_least32_t)0 + 0);
+
+#ifdef INT64_C
+verify (INT64_C (17) == 17);
+verify_same_types (INT64_C (17), (int_least64_t)0 + 0);
+#endif
+#ifdef UINT64_C
+verify (UINT64_C (17) == 17);
+verify_same_types (UINT64_C (17), (uint_least64_t)0 + 0);
+#endif
+
+verify (INTMAX_C (17) == 17);
+verify_same_types (INTMAX_C (17), (intmax_t)0 + 0);
+verify (UINTMAX_C (17) == 17);
+verify_same_types (UINTMAX_C (17), (uintmax_t)0 + 0);
+
+
+int
+main (void)
+{
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-stdlib.c
@@ -0,0 +1,43 @@
+/* Test of <stdlib.h> substitute.
+   Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2007.  */
+
+#include <config.h>
+
+#include <stdlib.h>
+
+#include "verify.h"
+
+int exitcode;
+
+/* Check that NULL can be passed through varargs as a pointer type,
+   per POSIX 2008.  */
+verify (sizeof NULL == sizeof (void *));
+
+int
+main (void)
+{
+  /* Check that some macros are defined and different integer constants.  */
+  switch (exitcode)
+    {
+    case EXIT_SUCCESS:
+    case EXIT_FAILURE:
+      break;
+    }
+
+  return 0;
+}
--- a/gltests/test-strerror.c
+++ b/gltests/test-strerror.c
@@ -1,5 +1,5 @@
 /* Test of strerror() function.
-   Copyright (C) 2007-2008 Free Software Foundation, Inc.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -19,25 +19,17 @@
 
 #include <config.h>
 
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
 
-#define ASSERT(expr) \
-  do									     \
-    {									     \
-      if (!(expr))							     \
-        {								     \
-          fprintf (stderr, "%s:%d: assertion failed\n", __FILE__, __LINE__); \
-          fflush (stderr);						     \
-          abort ();							     \
-        }								     \
-    }									     \
-  while (0)
+#include "signature.h"
+SIGNATURE_CHECK (strerror, char *, (int));
+
+#include <errno.h>
+
+#include "macros.h"
 
 int
-main (int argc, char **argv)
+main (void)
 {
   char *str;
 
--- a/gltests/test-string.c
+++ b/gltests/test-string.c
@@ -1,5 +1,5 @@
 /* Test of <string.h> substitute.
-   Copyright (C) 2007 Free Software Foundation, Inc.
+   Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -20,8 +20,14 @@
 
 #include <string.h>
 
+#include "verify.h"
+
+/* Check that NULL can be passed through varargs as a pointer type,
+   per POSIX 2008.  */
+verify (sizeof NULL == sizeof (void *));
+
 int
-main ()
+main (void)
 {
   return 0;
 }
--- /dev/null
+++ b/gltests/test-symlink.c
@@ -0,0 +1,47 @@
+/* Tests of symlink.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake <ebb9@byu.net>, 2009.  */
+
+#include <config.h>
+
+#include <unistd.h>
+
+#include "signature.h"
+SIGNATURE_CHECK (symlink, int, (char const *, char const *));
+
+#include <fcntl.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+
+#include "ignore-value.h"
+#include "macros.h"
+
+#define BASE "test-symlink.t"
+
+#include "test-symlink.h"
+
+int
+main (void)
+{
+  /* Remove any leftovers from a previous partial run.  */
+  ignore_value (system ("rm -rf " BASE "*"));
+
+  return test_symlink (symlink, true);
+}
--- /dev/null
+++ b/gltests/test-symlink.h
@@ -0,0 +1,95 @@
+/* Tests of symlink.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake <ebb9@byu.net>, 2009.  */
+
+/* This file is designed to test both symlink(a,b) and
+   symlinkat(a,AT_FDCWD,b).  FUNC is the function to test.  Assumes
+   that BASE and ASSERT are already defined, and that appropriate
+   headers are already included.  If PRINT, warn before skipping
+   symlink tests with status 77.  */
+
+static int
+test_symlink (int (*func) (char const *, char const *), bool print)
+{
+  if (func ("nowhere", BASE "link1"))
+    {
+      if (print)
+        fputs ("skipping test: symlinks not supported on this file system\n",
+               stderr);
+      return 77;
+    }
+
+  /* Some systems allow the creation of 0-length symlinks as a synonym
+     for "."; but most reject it.  */
+  {
+    int status;
+    errno = 0;
+    status = func ("", BASE "link2");
+    if (status == -1)
+      ASSERT (errno == ENOENT || errno == EINVAL);
+    else
+      {
+        ASSERT (status == 0);
+        ASSERT (unlink (BASE "link2") == 0);
+      }
+  }
+
+  /* Sanity checks of failures.  */
+  errno = 0;
+  ASSERT (func ("nowhere", "") == -1);
+  ASSERT (errno == ENOENT);
+  errno = 0;
+  ASSERT (func ("nowhere", ".") == -1);
+  ASSERT (errno == EEXIST || errno == EINVAL);
+  errno = 0;
+  ASSERT (func ("somewhere", BASE "link1") == -1);
+  ASSERT (errno == EEXIST);
+  errno = 0;
+  ASSERT (func ("nowhere", BASE "link2/") == -1);
+  ASSERT (errno == ENOTDIR || errno == ENOENT);
+  ASSERT (mkdir (BASE "dir", 0700) == 0);
+  errno = 0;
+  ASSERT (func ("nowhere", BASE "dir") == -1);
+  ASSERT (errno == EEXIST);
+  errno = 0;
+  ASSERT (func ("nowhere", BASE "dir/") == -1);
+  ASSERT (errno == EEXIST || errno == EINVAL);
+  ASSERT (close (creat (BASE "file", 0600)) == 0);
+  errno = 0;
+  ASSERT (func ("nowhere", BASE "file") == -1);
+  ASSERT (errno == EEXIST);
+  errno = 0;
+  ASSERT (func ("nowhere", BASE "file/") == -1);
+  ASSERT (errno == EEXIST || errno == ENOTDIR || errno == ENOENT);
+
+  /* Trailing slash must always be rejected.  */
+  ASSERT (unlink (BASE "link1") == 0);
+  ASSERT (func (BASE "link2", BASE "link1") == 0);
+  errno = 0;
+  ASSERT (func (BASE "nowhere", BASE "link1/") == -1);
+  ASSERT (errno == EEXIST || errno == ENOTDIR || errno == ENOENT);
+  errno = 0;
+  ASSERT (unlink (BASE "link2") == -1);
+  ASSERT (errno == ENOENT);
+
+  /* Cleanup.  */
+  ASSERT (rmdir (BASE "dir") == 0);
+  ASSERT (unlink (BASE "file") == 0);
+  ASSERT (unlink (BASE "link1") == 0);
+
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-sys_stat.c
@@ -0,0 +1,288 @@
+/* Test of <sys/stat.h> substitute.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2007.  */
+
+#include <config.h>
+
+#include <sys/stat.h>
+
+#include "verify.h"
+
+/* Check the existence of some macros.  */
+int a[] =
+  {
+    S_IFMT,
+    S_IFBLK, S_IFCHR, S_IFDIR, S_IFIFO, S_IFREG,
+#ifdef S_IFLNK /* missing on mingw and djgpp */
+    S_IFLNK,
+#endif
+#ifdef S_IFSOCK /* missing on mingw and djgpp */
+    S_IFSOCK,
+#endif
+    S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR,
+    S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP,
+    S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH,
+    S_ISUID, S_ISGID, S_ISVTX,
+    S_ISBLK (S_IFREG),
+    S_ISCHR (S_IFREG),
+    S_ISDIR (S_IFREG),
+    S_ISFIFO (S_IFREG),
+    S_ISREG (S_IFREG),
+    S_ISLNK (S_IFREG),
+    S_ISSOCK (S_IFREG),
+    S_ISDOOR (S_IFREG),
+    S_ISMPB (S_IFREG),
+    S_ISNAM (S_IFREG),
+    S_ISNWK (S_IFREG),
+    S_ISPORT (S_IFREG),
+    S_ISCTG (S_IFREG),
+    S_ISOFD (S_IFREG),
+    S_ISOFL (S_IFREG),
+    S_ISWHT (S_IFREG)
+  };
+
+/* Sanity checks.  */
+
+verify (S_IRWXU == (S_IRUSR | S_IWUSR | S_IXUSR));
+verify (S_IRWXG == (S_IRGRP | S_IWGRP | S_IXGRP));
+verify (S_IRWXO == (S_IROTH | S_IWOTH | S_IXOTH));
+
+verify (S_ISBLK (S_IFBLK));
+verify (!S_ISBLK (S_IFCHR));
+verify (!S_ISBLK (S_IFDIR));
+verify (!S_ISBLK (S_IFIFO));
+verify (!S_ISBLK (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISBLK (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISBLK (S_IFSOCK));
+#endif
+
+verify (!S_ISCHR (S_IFBLK));
+verify (S_ISCHR (S_IFCHR));
+verify (!S_ISCHR (S_IFDIR));
+verify (!S_ISCHR (S_IFIFO));
+verify (!S_ISCHR (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISCHR (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISCHR (S_IFSOCK));
+#endif
+
+verify (!S_ISDIR (S_IFBLK));
+verify (!S_ISDIR (S_IFCHR));
+verify (S_ISDIR (S_IFDIR));
+verify (!S_ISDIR (S_IFIFO));
+verify (!S_ISDIR (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISDIR (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISDIR (S_IFSOCK));
+#endif
+
+verify (!S_ISFIFO (S_IFBLK));
+verify (!S_ISFIFO (S_IFCHR));
+verify (!S_ISFIFO (S_IFDIR));
+verify (S_ISFIFO (S_IFIFO));
+verify (!S_ISFIFO (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISFIFO (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISFIFO (S_IFSOCK));
+#endif
+
+verify (!S_ISREG (S_IFBLK));
+verify (!S_ISREG (S_IFCHR));
+verify (!S_ISREG (S_IFDIR));
+verify (!S_ISREG (S_IFIFO));
+verify (S_ISREG (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISREG (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISREG (S_IFSOCK));
+#endif
+
+verify (!S_ISLNK (S_IFBLK));
+verify (!S_ISLNK (S_IFCHR));
+verify (!S_ISLNK (S_IFDIR));
+verify (!S_ISLNK (S_IFIFO));
+verify (!S_ISLNK (S_IFREG));
+#ifdef S_IFLNK
+verify (S_ISLNK (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISLNK (S_IFSOCK));
+#endif
+
+verify (!S_ISSOCK (S_IFBLK));
+verify (!S_ISSOCK (S_IFCHR));
+verify (!S_ISSOCK (S_IFDIR));
+verify (!S_ISSOCK (S_IFIFO));
+verify (!S_ISSOCK (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISSOCK (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (S_ISSOCK (S_IFSOCK));
+#endif
+
+verify (!S_ISDOOR (S_IFBLK));
+verify (!S_ISDOOR (S_IFCHR));
+verify (!S_ISDOOR (S_IFDIR));
+verify (!S_ISDOOR (S_IFIFO));
+verify (!S_ISDOOR (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISDOOR (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISDOOR (S_IFSOCK));
+#endif
+
+verify (!S_ISMPB (S_IFBLK));
+verify (!S_ISMPB (S_IFCHR));
+verify (!S_ISMPB (S_IFDIR));
+verify (!S_ISMPB (S_IFIFO));
+verify (!S_ISMPB (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISMPB (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISMPB (S_IFSOCK));
+#endif
+
+verify (!S_ISNAM (S_IFBLK));
+verify (!S_ISNAM (S_IFCHR));
+verify (!S_ISNAM (S_IFDIR));
+verify (!S_ISNAM (S_IFIFO));
+verify (!S_ISNAM (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISNAM (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISNAM (S_IFSOCK));
+#endif
+
+verify (!S_ISNWK (S_IFBLK));
+verify (!S_ISNWK (S_IFCHR));
+verify (!S_ISNWK (S_IFDIR));
+verify (!S_ISNWK (S_IFIFO));
+verify (!S_ISNWK (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISNWK (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISNWK (S_IFSOCK));
+#endif
+
+verify (!S_ISPORT (S_IFBLK));
+verify (!S_ISPORT (S_IFCHR));
+verify (!S_ISPORT (S_IFDIR));
+verify (!S_ISPORT (S_IFIFO));
+verify (!S_ISPORT (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISPORT (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISPORT (S_IFSOCK));
+#endif
+
+verify (!S_ISCTG (S_IFBLK));
+verify (!S_ISCTG (S_IFCHR));
+verify (!S_ISCTG (S_IFDIR));
+verify (!S_ISCTG (S_IFIFO));
+verify (!S_ISCTG (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISCTG (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISCTG (S_IFSOCK));
+#endif
+
+verify (!S_ISOFD (S_IFBLK));
+verify (!S_ISOFD (S_IFCHR));
+verify (!S_ISOFD (S_IFDIR));
+verify (!S_ISOFD (S_IFIFO));
+verify (!S_ISOFD (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISOFD (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISOFD (S_IFSOCK));
+#endif
+
+verify (!S_ISOFL (S_IFBLK));
+verify (!S_ISOFL (S_IFCHR));
+verify (!S_ISOFL (S_IFDIR));
+verify (!S_ISOFL (S_IFIFO));
+verify (!S_ISOFL (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISOFL (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISOFL (S_IFSOCK));
+#endif
+
+verify (!S_ISWHT (S_IFBLK));
+verify (!S_ISWHT (S_IFCHR));
+verify (!S_ISWHT (S_IFDIR));
+verify (!S_ISWHT (S_IFIFO));
+verify (!S_ISWHT (S_IFREG));
+#ifdef S_IFLNK
+verify (!S_ISWHT (S_IFLNK));
+#endif
+#ifdef S_IFSOCK
+verify (!S_ISWHT (S_IFSOCK));
+#endif
+
+/* POSIX 2008 requires traditional encoding of permission constants.  */
+verify (S_IRWXU == 00700);
+verify (S_IRUSR == 00400);
+verify (S_IWUSR == 00200);
+verify (S_IXUSR == 00100);
+verify (S_IRWXG == 00070);
+verify (S_IRGRP == 00040);
+verify (S_IWGRP == 00020);
+verify (S_IXGRP == 00010);
+verify (S_IRWXO == 00007);
+verify (S_IROTH == 00004);
+verify (S_IWOTH == 00002);
+verify (S_IXOTH == 00001);
+verify (S_ISUID == 04000);
+verify (S_ISGID == 02000);
+verify (S_ISVTX == 01000);
+
+#if ((0 <= UTIME_NOW && UTIME_NOW < 1000000000)           \
+     || (0 <= UTIME_OMIT && UTIME_OMIT < 1000000000)      \
+     || UTIME_NOW == UTIME_OMIT)
+invalid UTIME macros
+#endif
+
+/* Check the existence of some types.  */
+nlink_t t1;
+
+struct timespec t2;
+
+int
+main (void)
+{
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-time.c
@@ -0,0 +1,35 @@
+/* Test of <time.h> substitute.
+   Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2007.  */
+
+#include <config.h>
+
+#include <time.h>
+
+#include "verify.h"
+
+struct timespec a;
+
+/* Check that NULL can be passed through varargs as a pointer type,
+   per POSIX 2008.  */
+verify (sizeof NULL == sizeof (void *));
+
+int
+main (void)
+{
+  return 0;
+}
--- a/gltests/test-unistd.c
+++ b/gltests/test-unistd.c
@@ -1,5 +1,5 @@
 /* Test of <unistd.h> substitute.
-   Copyright (C) 2007, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -20,6 +20,12 @@
 
 #include <unistd.h>
 
+#include "verify.h"
+
+/* Check that NULL can be passed through varargs as a pointer type,
+   per POSIX 2008.  */
+verify (sizeof NULL == sizeof (void *));
+
 /* Check that the various SEEK_* macros are defined.  */
 int sk[] = { SEEK_CUR, SEEK_END, SEEK_SET };
 
@@ -44,7 +50,7 @@ intptr_t t8;
 #endif
 
 int
-main ()
+main (void)
 {
   return 0;
 }
--- /dev/null
+++ b/gltests/test-unsetenv.c
@@ -0,0 +1,61 @@
+/* Tests of unsetenv.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake <ebb9@byu.net>, 2009.  */
+
+#include <config.h>
+
+#include <stdlib.h>
+
+#include "signature.h"
+SIGNATURE_CHECK (unsetenv, int, (char const *));
+
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "macros.h"
+
+int
+main (void)
+{
+  char entry[] = "b=2";
+
+  /* Test removal when multiple entries present.  */
+  ASSERT (putenv ((char *) "a=1") == 0);
+  ASSERT (putenv (entry) == 0);
+  entry[0] = 'a'; /* Unspecified what getenv("a") would be at this point.  */
+  ASSERT (unsetenv ("a") == 0); /* Both entries will be removed.  */
+  ASSERT (getenv ("a") == NULL);
+  ASSERT (unsetenv ("a") == 0);
+
+  /* Required to fail with EINVAL.  */
+  errno = 0;
+  ASSERT (unsetenv ("") == -1);
+  ASSERT (errno == EINVAL);
+  errno = 0;
+  ASSERT (unsetenv ("a=b") == -1);
+  ASSERT (errno == EINVAL);
+#if 0
+  /* glibc and gnulib's implementation guarantee this, but POSIX no
+     longer requires it: http://austingroupbugs.net/view.php?id=185  */
+  errno = 0;
+  ASSERT (unsetenv (NULL) == -1);
+  ASSERT (errno == EINVAL);
+#endif
+
+  return 0;
+}
--- a/gltests/test-vc-list-files-cvs.sh
+++ b/gltests/test-vc-list-files-cvs.sh
@@ -1,6 +1,6 @@
 #!/bin/sh
 # Unit tests for vc-list-files
-# Copyright (C) 2008 Free Software Foundation, Inc.
+# Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
 # This file is part of the GNUlib Library.
 #
 # This program is free software: you can redistribute it and/or modify
@@ -16,18 +16,10 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
-tmpdir=vc-cvs-$$
-trap 'st=$?; cd '"`pwd`"' && rm -rf $tmpdir; exit $st' 0
-trap '(exit $?); exit $?' 1 2 13 15
-
-if ( diff --version < /dev/null 2>&1 | grep GNU ) 2>&1 > /dev/null; then
-  compare() { diff -u "$@"; }
-elif ( cmp --version < /dev/null 2>&1 | grep GNU ) 2>&1 > /dev/null; then
-  compare() { cmp -s "$@"; }
-else
-  compare() { cmp "$@"; }
-fi
+: ${srcdir=.}
+. "$srcdir/init.sh"; path_prepend_ .
 
+tmpdir=vc-cvs
 repo=`pwd`/$tmpdir/repo
 
 fail=0
@@ -46,7 +38,7 @@ for i in with-cvsu without; do
     # without cvs, skip the test
     # The double use of 'exit' is needed for the reference to $? inside the trap.
     { ( cvs -Q -d "$repo" init ) > /dev/null 2>&1 \
-      || { echo "Skipping test: cvs not found in PATH"; (exit 77); exit 77; }; } &&
+      || skip_ "cvs not found in PATH"; } &&
     mkdir w && cd w &&
     mkdir d &&
     touch d/a b c &&
@@ -59,4 +51,4 @@ for i in with-cvsu without; do
   test $ok = 0 && fail=1
 done
 
-(exit $fail); exit $fail
+Exit $fail
--- a/gltests/test-vc-list-files-git.sh
+++ b/gltests/test-vc-list-files-git.sh
@@ -1,6 +1,6 @@
 #!/bin/sh
 # Unit tests for vc-list-files
-# Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+# Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
 # This file is part of the GNUlib Library.
 #
 # This program is free software: you can redistribute it and/or modify
@@ -16,28 +16,22 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
-if ( diff --version < /dev/null 2>&1 | grep GNU ) 2>&1 > /dev/null; then
-  compare() { diff -u "$@"; }
-elif ( cmp --version < /dev/null 2>&1 | grep GNU ) 2>&1 > /dev/null; then
-  compare() { cmp -s "$@"; }
-else
-  compare() { cmp "$@"; }
-fi
+: ${srcdir=.}
+. "$srcdir/init.sh"; path_prepend_ .
 
 tmpdir=vc-git-$$
-trap 'st=$?; cd '"`pwd`"' && rm -rf $tmpdir; exit $st' 0
-trap '(exit $?); exit $?' 1 2 13 15
+GIT_DIR= GIT_WORK_TREE=; unset GIT_DIR GIT_WORK_TREE
 
 fail=1
 mkdir $tmpdir && cd $tmpdir &&
   # without git, skip the test
   # The double use of 'exit' is needed for the reference to $? inside the trap.
   { ( git init -q ) > /dev/null 2>&1 \
-    || { echo "Skipping test: git not found in PATH"; (exit 77); exit 77; }; } &&
+    || skip_ "git not found in PATH"; } &&
   mkdir d &&
   touch d/a b c &&
-  git config user.email "you@example.com"
-  git config user.name "Your Name"
+  git config user.email "you@example.com" &&
+  git config user.name "Your Name" &&
   git add . > /dev/null &&
   git commit -q -a -m log &&
   printf '%s\n' b c d/a > expected &&
@@ -45,4 +39,4 @@ mkdir $tmpdir && cd $tmpdir &&
   compare expected actual &&
   fail=0
 
-(exit $fail); exit $fail
+Exit $fail
--- /dev/null
+++ b/gltests/test-verify.c
@@ -0,0 +1,69 @@
+/* Test the "verify" module.
+
+   Copyright (C) 2005, 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible.  */
+
+#include <config.h>
+
+#include "verify.h"
+
+#ifndef EXP_FAIL
+# define EXP_FAIL 0
+#endif
+
+int x;
+enum { a, b, c };
+
+#if EXP_FAIL == 1
+verify (x >= 0);                  /* should give ERROR: non-constant expression */
+#endif
+verify (c == 2);                  /* should be ok */
+#if EXP_FAIL == 2
+verify (1 + 1 == 3);              /* should give ERROR */
+#endif
+verify (1 == 1); verify (1 == 1); /* should be ok */
+
+enum
+{
+  item = verify_true (1 == 1) * 0 + 17 /* should be ok */
+};
+
+static int
+function (int n)
+{
+#if EXP_FAIL == 3
+  verify (n >= 0);                  /* should give ERROR: non-constant expression */
+#endif
+  verify (c == 2);                  /* should be ok */
+#if EXP_FAIL == 4
+  verify (1 + 1 == 3);              /* should give ERROR */
+#endif
+  verify (1 == 1); verify (1 == 1); /* should be ok */
+
+  if (n)
+    return ((void) verify_true (1 == 1), verify_true (1 == 1) + 7); /* should be ok */
+#if EXP_FAIL == 5
+  return (verify_true (1 == 2), 5); /* should give ERROR */
+#endif
+  return 0;
+}
+
+int
+main (void)
+{
+  return !(function (0) == 0 && function (1) == 8);
+}
--- /dev/null
+++ b/gltests/test-verify.sh
@@ -0,0 +1,24 @@
+#!/bin/sh
+. "${srcdir=.}/init.sh"
+
+# We are not interested in triggering bugs in the compilers and tools
+# (such as gcc 4.3.1 on openSUSE 11.0).
+unset MALLOC_PERTURB_
+
+# Rather than figure out how to invoke the compiler with the right
+# include path ourselves, we let make do it:
+(cd "$initial_cwd_" && rm -f test-verify.o \
+    && $MAKE test-verify.o >/dev/null 2>&1) \
+  || skip_ "cannot compile error-free"
+
+# Now, prove that we encounter all expected compilation failures:
+: >out
+: >err
+for i in 1 2 3 4 5; do
+  (cd "$initial_cwd_"
+   rm -f test-verify.o
+   $MAKE CFLAGS=-DEXP_FAIL=$i test-verify.o) >>out 2>>err \
+  && { warn_ "compiler didn't detect verification failure $i"; fail=1; }
+done
+
+Exit $fail
--- /dev/null
+++ b/gltests/test-version-etc.c
@@ -0,0 +1,33 @@
+/* Test suite for version-etc.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+   This file is part of the GNUlib Library.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#include "version-etc.h"
+
+#include "progname.h"
+
+#define AUTHORS "Sergey Poznyakoff", "Eric Blake"
+
+int
+main (int argc _GL_UNUSED, char **argv)
+{
+  set_program_name (argv[0]);
+  version_etc (stdout, "test-version-etc", "dummy", "0", AUTHORS,
+               (const char *) NULL);
+  return 0;
+}
--- /dev/null
+++ b/gltests/test-version-etc.sh
@@ -0,0 +1,43 @@
+#! /bin/sh
+# Test suite for version-etc.
+# Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+# This file is part of the GNUlib Library.
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+TMP=ve-expected.tmp
+LC_ALL=C
+export LC_ALL
+ERR=0
+
+cat > $TMP <<EOT
+test-version-etc (PROJECT) VERSION
+COPYRIGHT Free Software Foundation, Inc.
+License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
+This is free software: you are free to change and redistribute it.
+There is NO WARRANTY, to the extent permitted by law.
+
+Written by Sergey Poznyakoff and Eric Blake.
+EOT
+
+./test-version-etc${EXEEXT} --version |
+ sed '1s/test-version-etc (.*) .*/test-version-etc (PROJECT) VERSION/
+      /^Packaged by/d
+      2,3 s/Copyright (C) [0-9]\{4,4\}/COPYRIGHT/' |
+ tr -d '\015' |
+ diff -c $TMP - || ERR=1
+
+rm $TMP
+
+exit $ERR
--- /dev/null
+++ b/gltests/test-wchar.c
@@ -0,0 +1,37 @@
+/* Test of <wchar.h> substitute.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2007.  */
+
+#include <config.h>
+
+#include <wchar.h>
+
+#include "verify.h"
+
+/* Check that the types wchar_t and wint_t are defined.  */
+wchar_t a = 'c';
+wint_t b = 'x';
+
+/* Check that NULL can be passed through varargs as a pointer type,
+   per POSIX 2008.  */
+verify (sizeof NULL == sizeof (void *));
+
+int
+main (void)
+{
+  return 0;
+}
--- /dev/null
+++ b/gltests/time.in.h
@@ -0,0 +1,229 @@
+/* A more-standard <time.h>.
+
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+/* Don't get in the way of glibc when it includes time.h merely to
+   declare a few standard symbols, rather than to declare all the
+   symbols.  Also, Solaris 8 <time.h> eventually includes itself
+   recursively; if that is happening, just include the system <time.h>
+   without adding our own declarations.  */
+#if (defined __need_time_t || defined __need_clock_t \
+     || defined __need_timespec \
+     || defined _GL_TIME_H)
+
+# @INCLUDE_NEXT@ @NEXT_TIME_H@
+
+#else
+
+# define _GL_TIME_H
+
+# @INCLUDE_NEXT@ @NEXT_TIME_H@
+
+/* NetBSD 5.0 mis-defines NULL.  */
+# include <stddef.h>
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+
+/* Some systems don't define struct timespec (e.g., AIX 4.1, Ultrix 4.3).
+   Or they define it with the wrong member names or define it in <sys/time.h>
+   (e.g., FreeBSD circa 1997).  Stock Mingw does not define it, but the
+   pthreads-win32 library defines it in <pthread.h>.  */
+# if ! @TIME_H_DEFINES_STRUCT_TIMESPEC@
+#  if @SYS_TIME_H_DEFINES_STRUCT_TIMESPEC@
+#   include <sys/time.h>
+#  elif @PTHREAD_H_DEFINES_STRUCT_TIMESPEC@
+#   include <pthread.h>
+/* The pthreads-win32 <pthread.h> also defines a couple of broken macros.  */
+#   undef asctime_r
+#   undef ctime_r
+#   undef gmtime_r
+#   undef localtime_r
+#   undef rand_r
+#   undef strtok_r
+#  else
+
+#   ifdef __cplusplus
+extern "C" {
+#   endif
+
+#   undef timespec
+#   define timespec rpl_timespec
+struct timespec
+{
+  time_t tv_sec;
+  long int tv_nsec;
+};
+
+#   ifdef __cplusplus
+}
+#   endif
+
+#  endif
+# endif
+
+/* Sleep for at least RQTP seconds unless interrupted,  If interrupted,
+   return -1 and store the remaining time into RMTP.  See
+   <http://www.opengroup.org/susv3xsh/nanosleep.html>.  */
+# if @GNULIB_NANOSLEEP@
+#  if @REPLACE_NANOSLEEP@
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define nanosleep rpl_nanosleep
+#   endif
+_GL_FUNCDECL_RPL (nanosleep, int,
+                  (struct timespec const *__rqtp, struct timespec *__rmtp)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (nanosleep, int,
+                  (struct timespec const *__rqtp, struct timespec *__rmtp));
+#  else
+#   if ! @HAVE_NANOSLEEP@
+_GL_FUNCDECL_SYS (nanosleep, int,
+                  (struct timespec const *__rqtp, struct timespec *__rmtp)
+                  _GL_ARG_NONNULL ((1)));
+#   endif
+_GL_CXXALIAS_SYS (nanosleep, int,
+                  (struct timespec const *__rqtp, struct timespec *__rmtp));
+#  endif
+_GL_CXXALIASWARN (nanosleep);
+# endif
+
+/* Return the 'time_t' representation of TP and normalize TP.  */
+# if @GNULIB_MKTIME@
+#  if @REPLACE_MKTIME@
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define mktime rpl_mktime
+#   endif
+_GL_FUNCDECL_RPL (mktime, time_t, (struct tm *__tp) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mktime, time_t, (struct tm *__tp));
+#  else
+_GL_CXXALIAS_SYS (mktime, time_t, (struct tm *__tp));
+#  endif
+_GL_CXXALIASWARN (mktime);
+# endif
+
+/* Convert TIMER to RESULT, assuming local time and UTC respectively.  See
+   <http://www.opengroup.org/susv3xsh/localtime_r.html> and
+   <http://www.opengroup.org/susv3xsh/gmtime_r.html>.  */
+# if @GNULIB_TIME_R@
+#  if @REPLACE_LOCALTIME_R@
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef localtime_r
+#    define localtime_r rpl_localtime_r
+#   endif
+_GL_FUNCDECL_RPL (localtime_r, struct tm *, (time_t const *restrict __timer,
+                                             struct tm *restrict __result)
+                                            _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (localtime_r, struct tm *, (time_t const *restrict __timer,
+                                             struct tm *restrict __result));
+#  else
+#   if ! @HAVE_LOCALTIME_R@
+_GL_FUNCDECL_SYS (localtime_r, struct tm *, (time_t const *restrict __timer,
+                                             struct tm *restrict __result)
+                                            _GL_ARG_NONNULL ((1, 2)));
+#   endif
+_GL_CXXALIAS_SYS (localtime_r, struct tm *, (time_t const *restrict __timer,
+                                             struct tm *restrict __result));
+#  endif
+_GL_CXXALIASWARN (localtime_r);
+#  if @REPLACE_LOCALTIME_R@
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef gmtime_r
+#    define gmtime_r rpl_gmtime_r
+#   endif
+_GL_FUNCDECL_RPL (gmtime_r, struct tm *, (time_t const *restrict __timer,
+                                          struct tm *restrict __result)
+                                         _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (gmtime_r, struct tm *, (time_t const *restrict __timer,
+                                          struct tm *restrict __result));
+#  else
+#   if ! @HAVE_LOCALTIME_R@
+_GL_FUNCDECL_SYS (gmtime_r, struct tm *, (time_t const *restrict __timer,
+                                          struct tm *restrict __result)
+                                         _GL_ARG_NONNULL ((1, 2)));
+#   endif
+_GL_CXXALIAS_SYS (gmtime_r, struct tm *, (time_t const *restrict __timer,
+                                          struct tm *restrict __result));
+#  endif
+_GL_CXXALIASWARN (gmtime_r);
+# endif
+
+/* Parse BUF as a time stamp, assuming FORMAT specifies its layout, and store
+   the resulting broken-down time into TM.  See
+   <http://www.opengroup.org/susv3xsh/strptime.html>.  */
+# if @GNULIB_STRPTIME@
+#  if ! @HAVE_STRPTIME@
+_GL_FUNCDECL_SYS (strptime, char *, (char const *restrict __buf,
+                                     char const *restrict __format,
+                                     struct tm *restrict __tm)
+                                    _GL_ARG_NONNULL ((1, 2, 3)));
+#  endif
+_GL_CXXALIAS_SYS (strptime, char *, (char const *restrict __buf,
+                                     char const *restrict __format,
+                                     struct tm *restrict __tm));
+_GL_CXXALIASWARN (strptime);
+# endif
+
+/* Convert TM to a time_t value, assuming UTC.  */
+# if @GNULIB_TIMEGM@
+#  if @REPLACE_TIMEGM@
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef timegm
+#    define timegm rpl_timegm
+#   endif
+_GL_FUNCDECL_RPL (timegm, time_t, (struct tm *__tm) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (timegm, time_t, (struct tm *__tm));
+#  else
+#   if ! @HAVE_TIMEGM@
+_GL_FUNCDECL_SYS (timegm, time_t, (struct tm *__tm) _GL_ARG_NONNULL ((1)));
+#   endif
+_GL_CXXALIAS_SYS (timegm, time_t, (struct tm *__tm));
+#  endif
+_GL_CXXALIASWARN (timegm);
+# endif
+
+/* Encourage applications to avoid unsafe functions that can overrun
+   buffers when given outlandish struct tm values.  Portable
+   applications should use strftime (or even sprintf) instead.  */
+# if defined GNULIB_POSIXCHECK
+#  undef asctime
+_GL_WARN_ON_USE (asctime, "asctime can overrun buffers in some cases - "
+                 "better use strftime (or even sprintf) instead");
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef asctime_r
+_GL_WARN_ON_USE (asctime, "asctime_r can overrun buffers in some cases - "
+                 "better use strftime (or even sprintf) instead");
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef ctime
+_GL_WARN_ON_USE (asctime, "ctime can overrun buffers in some cases - "
+                 "better use strftime (or even sprintf) instead");
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef ctime_r
+_GL_WARN_ON_USE (asctime, "ctime_r can overrun buffers in some cases - "
+                 "better use strftime (or even sprintf) instead");
+# endif
+
+#endif
--- /dev/null
+++ b/gltests/unsetenv.c
@@ -0,0 +1,120 @@
+/* Copyright (C) 1992, 1995-2002, 2005-2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+/* Don't use __attribute__ __nonnull__ in this compilation unit.  Otherwise gcc
+   optimizes away the name == NULL test below.  */
+#define _GL_ARG_NONNULL(params)
+
+/* Specification.  */
+#include <stdlib.h>
+
+#include <errno.h>
+#if !_LIBC
+# define __set_errno(ev) ((errno) = (ev))
+#endif
+
+#include <string.h>
+#include <unistd.h>
+
+#if !_LIBC
+# define __environ      environ
+#endif
+
+#if _LIBC
+/* This lock protects against simultaneous modifications of `environ'.  */
+# include <bits/libc-lock.h>
+__libc_lock_define_initialized (static, envlock)
+# define LOCK   __libc_lock_lock (envlock)
+# define UNLOCK __libc_lock_unlock (envlock)
+#else
+# define LOCK
+# define UNLOCK
+#endif
+
+/* In the GNU C library we must keep the namespace clean.  */
+#ifdef _LIBC
+# define unsetenv __unsetenv
+#endif
+
+#if _LIBC || !HAVE_UNSETENV
+
+int
+unsetenv (const char *name)
+{
+  size_t len;
+  char **ep;
+
+  if (name == NULL || *name == '\0' || strchr (name, '=') != NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  len = strlen (name);
+
+  LOCK;
+
+  ep = __environ;
+  while (*ep != NULL)
+    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')
+      {
+        /* Found it.  Remove this pointer by moving later ones back.  */
+        char **dp = ep;
+
+        do
+          dp[0] = dp[1];
+        while (*dp++);
+        /* Continue the loop in case NAME appears again.  */
+      }
+    else
+      ++ep;
+
+  UNLOCK;
+
+  return 0;
+}
+
+#ifdef _LIBC
+# undef unsetenv
+weak_alias (__unsetenv, unsetenv)
+#endif
+
+#else /* HAVE_UNSETENV */
+
+# undef unsetenv
+
+/* Call the underlying unsetenv, in case there is hidden bookkeeping
+   that needs updating beyond just modifying environ.  */
+int
+rpl_unsetenv (const char *name)
+{
+  int result = 0;
+  if (!name || !*name || strchr (name, '='))
+    {
+      errno = EINVAL;
+      return -1;
+    }
+  while (getenv (name))
+# if !VOID_UNSETENV
+    result =
+# endif
+      unsetenv (name);
+  return result;
+}
+
+#endif /* HAVE_UNSETENV */
--- /dev/null
+++ b/gltests/verify.h
@@ -0,0 +1,163 @@
+/* Compile-time assert-like macros.
+
+   Copyright (C) 2005-2006, 2009-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Eggert, Bruno Haible, and Jim Meyering.  */
+
+#ifndef VERIFY_H
+# define VERIFY_H 1
+
+/* Each of these macros verifies that its argument R is nonzero.  To
+   be portable, R should be an integer constant expression.  Unlike
+   assert (R), there is no run-time overhead.
+
+   There are two macros, since no single macro can be used in all
+   contexts in C.  verify_true (R) is for scalar contexts, including
+   integer constant expression contexts.  verify (R) is for declaration
+   contexts, e.g., the top level.
+
+   Symbols ending in "__" are private to this header.
+
+   The code below uses several ideas.
+
+   * The first step is ((R) ? 1 : -1).  Given an expression R, of
+     integral or boolean or floating-point type, this yields an
+     expression of integral type, whose value is later verified to be
+     constant and nonnegative.
+
+   * Next this expression W is wrapped in a type
+     struct verify_type__ { unsigned int verify_error_if_negative_size__: W; }.
+     If W is negative, this yields a compile-time error.  No compiler can
+     deal with a bit-field of negative size.
+
+     One might think that an array size check would have the same
+     effect, that is, that the type struct { unsigned int dummy[W]; }
+     would work as well.  However, inside a function, some compilers
+     (such as C++ compilers and GNU C) allow local parameters and
+     variables inside array size expressions.  With these compilers,
+     an array size check would not properly diagnose this misuse of
+     the verify macro:
+
+       void function (int n) { verify (n < 0); }
+
+   * For the verify macro, the struct verify_type__ will need to
+     somehow be embedded into a declaration.  To be portable, this
+     declaration must declare an object, a constant, a function, or a
+     typedef name.  If the declared entity uses the type directly,
+     such as in
+
+       struct dummy {...};
+       typedef struct {...} dummy;
+       extern struct {...} *dummy;
+       extern void dummy (struct {...} *);
+       extern struct {...} *dummy (void);
+
+     two uses of the verify macro would yield colliding declarations
+     if the entity names are not disambiguated.  A workaround is to
+     attach the current line number to the entity name:
+
+       #define _GL_CONCAT0(x, y) x##y
+       #define _GL_CONCAT(x, y) _GL_CONCAT0 (x, y)
+       extern struct {...} * _GL_CONCAT (dummy, __LINE__);
+
+     But this has the problem that two invocations of verify from
+     within the same macro would collide, since the __LINE__ value
+     would be the same for both invocations.  (The GCC __COUNTER__
+     macro solves this problem, but is not portable.)
+
+     A solution is to use the sizeof operator.  It yields a number,
+     getting rid of the identity of the type.  Declarations like
+
+       extern int dummy [sizeof (struct {...})];
+       extern void dummy (int [sizeof (struct {...})]);
+       extern int (*dummy (void)) [sizeof (struct {...})];
+
+     can be repeated.
+
+   * Should the implementation use a named struct or an unnamed struct?
+     Which of the following alternatives can be used?
+
+       extern int dummy [sizeof (struct {...})];
+       extern int dummy [sizeof (struct verify_type__ {...})];
+       extern void dummy (int [sizeof (struct {...})]);
+       extern void dummy (int [sizeof (struct verify_type__ {...})]);
+       extern int (*dummy (void)) [sizeof (struct {...})];
+       extern int (*dummy (void)) [sizeof (struct verify_type__ {...})];
+
+     In the second and sixth case, the struct type is exported to the
+     outer scope; two such declarations therefore collide.  GCC warns
+     about the first, third, and fourth cases.  So the only remaining
+     possibility is the fifth case:
+
+       extern int (*dummy (void)) [sizeof (struct {...})];
+
+   * GCC warns about duplicate declarations of the dummy function if
+     -Wredundant_decls is used.  GCC 4.3 and later have a builtin
+     __COUNTER__ macro that can let us generate unique identifiers for
+     each dummy function, to suppress this warning.
+
+   * This implementation exploits the fact that GCC does not warn about
+     the last declaration mentioned above.  If a future version of GCC
+     introduces a warning for this, the problem could be worked around
+     by using code specialized to GCC, just as __COUNTER__ is already
+     being used if available.
+
+       #if 4 <= __GNUC__
+       # define verify(R) [another version to keep GCC happy]
+       #endif
+
+   * In C++, any struct definition inside sizeof is invalid.
+     Use a template type to work around the problem.  */
+
+/* Concatenate two preprocessor tokens.  */
+# define _GL_CONCAT(x, y) _GL_CONCAT0 (x, y)
+# define _GL_CONCAT0(x, y) x##y
+
+/* _GL_COUNTER is an integer, preferably one that changes each time we
+   use it.  Use __COUNTER__ if it works, falling back on __LINE__
+   otherwise.  __LINE__ isn't perfect, but it's better than a
+   constant.  */
+# if defined __COUNTER__ && __COUNTER__ != __COUNTER__
+#  define _GL_COUNTER __COUNTER__
+# else
+#  define _GL_COUNTER __LINE__
+# endif
+
+/* Generate a symbol with the given prefix, making it unique if
+   possible.  */
+# define _GL_GENSYM(prefix) _GL_CONCAT (prefix, _GL_COUNTER)
+
+/* Verify requirement R at compile-time, as an integer constant expression.
+   Return 1.  */
+
+# ifdef __cplusplus
+template <int w>
+  struct verify_type__ { unsigned int verify_error_if_negative_size__: w; };
+#  define verify_true(R) \
+     (!!sizeof (verify_type__<(R) ? 1 : -1>))
+# else
+#  define verify_true(R) \
+     (!!sizeof \
+      (struct { unsigned int verify_error_if_negative_size__: (R) ? 1 : -1; }))
+# endif
+
+/* Verify requirement R at compile-time, as a declaration without a
+   trailing ';'.  */
+
+# define verify(R) \
+    extern int (* _GL_GENSYM (verify_function) (void)) [verify_true (R)]
+
+#endif
--- /dev/null
+++ b/gltests/version-etc-fsf.c
@@ -0,0 +1,30 @@
+/* Variable with FSF copyright information, for version-etc.
+   Copyright (C) 1999-2006, 2009-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Jim Meyering. */
+
+#include <config.h>
+
+/* Specification.  */
+#include "version-etc.h"
+
+/* Default copyright goes to the FSF. */
+
+const char version_etc_copyright[] =
+  /* Do *not* mark this string for translation.  %s is a copyright
+     symbol suitable for this locale, and %d is the copyright
+     year.  */
+  "Copyright %s %d Free Software Foundation, Inc.";
--- /dev/null
+++ b/gltests/wchar.in.h
@@ -0,0 +1,428 @@
+/* A substitute for ISO C99 <wchar.h>, for platforms that have issues.
+
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Written by Eric Blake.  */
+
+/*
+ * ISO C 99 <wchar.h> for platforms that have issues.
+ * <http://www.opengroup.org/susv3xbd/wchar.h.html>
+ *
+ * For now, this just ensures proper prerequisite inclusion order and
+ * the declaration of wcwidth().
+ */
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+#if defined __need_mbstate_t || defined __need_wint_t || (defined __hpux && ((defined _INTTYPES_INCLUDED && !defined strtoimax) || defined _GL_JUST_INCLUDE_SYSTEM_WCHAR_H)) || defined _GL_ALREADY_INCLUDING_WCHAR_H
+/* Special invocation convention:
+   - Inside glibc and uClibc header files.
+   - On HP-UX 11.00 we have a sequence of nested includes
+     <wchar.h> -> <stdlib.h> -> <stdint.h>, and the latter includes <wchar.h>,
+     once indirectly <stdint.h> -> <sys/types.h> -> <inttypes.h> -> <wchar.h>
+     and once directly.  In both situations 'wint_t' is not yet defined,
+     therefore we cannot provide the function overrides; instead include only
+     the system's <wchar.h>.
+   - On IRIX 6.5, similarly, we have an include <wchar.h> -> <wctype.h>, and
+     the latter includes <wchar.h>.  But here, we have no way to detect whether
+     <wctype.h> is completely included or is still being included.  */
+
+#@INCLUDE_NEXT@ @NEXT_WCHAR_H@
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_WCHAR_H
+
+#define _GL_ALREADY_INCLUDING_WCHAR_H
+
+/* Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
+   <wchar.h>.
+   BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be
+   included before <wchar.h>.
+   But avoid namespace pollution on glibc systems.  */
+#ifndef __GLIBC__
+# include <stddef.h>
+# include <stdio.h>
+# include <time.h>
+#endif
+
+/* Include the original <wchar.h> if it exists.
+   Some builds of uClibc lack it.  */
+/* The include_next requires a split double-inclusion guard.  */
+#if @HAVE_WCHAR_H@
+# @INCLUDE_NEXT@ @NEXT_WCHAR_H@
+#endif
+
+#undef _GL_ALREADY_INCLUDING_WCHAR_H
+
+#ifndef _GL_WCHAR_H
+#define _GL_WCHAR_H
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+
+
+/* Define wint_t and WEOF.  (Also done in wctype.in.h.)  */
+#if !@HAVE_WINT_T@ && !defined wint_t
+# define wint_t int
+# ifndef WEOF
+#  define WEOF -1
+# endif
+#else
+# ifndef WEOF
+#  define WEOF ((wint_t) -1)
+# endif
+#endif
+
+
+/* Override mbstate_t if it is too small.
+   On IRIX 6.5, sizeof (mbstate_t) == 1, which is not sufficient for
+   implementing mbrtowc for encodings like UTF-8.  */
+#if !(@HAVE_MBSINIT@ && @HAVE_MBRTOWC@) || @REPLACE_MBSTATE_T@
+typedef int rpl_mbstate_t;
+# undef mbstate_t
+# define mbstate_t rpl_mbstate_t
+# define GNULIB_defined_mbstate_t 1
+#endif
+
+
+/* Convert a single-byte character to a wide character.  */
+#if @GNULIB_BTOWC@
+# if @REPLACE_BTOWC@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef btowc
+#   define btowc rpl_btowc
+#  endif
+_GL_FUNCDECL_RPL (btowc, wint_t, (int c));
+_GL_CXXALIAS_RPL (btowc, wint_t, (int c));
+# else
+#  if !@HAVE_BTOWC@
+_GL_FUNCDECL_SYS (btowc, wint_t, (int c));
+#  endif
+_GL_CXXALIAS_SYS (btowc, wint_t, (int c));
+# endif
+_GL_CXXALIASWARN (btowc);
+#elif defined GNULIB_POSIXCHECK
+# undef btowc
+# if HAVE_RAW_DECL_BTOWC
+_GL_WARN_ON_USE (btowc, "btowc is unportable - "
+                 "use gnulib module btowc for portability");
+# endif
+#endif
+
+
+/* Convert a wide character to a single-byte character.  */
+#if @GNULIB_WCTOB@
+# if @REPLACE_WCTOB@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wctob
+#   define wctob rpl_wctob
+#  endif
+_GL_FUNCDECL_RPL (wctob, int, (wint_t wc));
+_GL_CXXALIAS_RPL (wctob, int, (wint_t wc));
+# else
+#  if !defined wctob && !@HAVE_DECL_WCTOB@
+/* wctob is provided by gnulib, or wctob exists but is not declared.  */
+_GL_FUNCDECL_SYS (wctob, int, (wint_t wc));
+#  endif
+_GL_CXXALIAS_SYS (wctob, int, (wint_t wc));
+# endif
+_GL_CXXALIASWARN (wctob);
+#elif defined GNULIB_POSIXCHECK
+# undef wctob
+# if HAVE_RAW_DECL_WCTOB
+_GL_WARN_ON_USE (wctob, "wctob is unportable - "
+                 "use gnulib module wctob for portability");
+# endif
+#endif
+
+
+/* Test whether *PS is in the initial state.  */
+#if @GNULIB_MBSINIT@
+# if @REPLACE_MBSINIT@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbsinit
+#   define mbsinit rpl_mbsinit
+#  endif
+_GL_FUNCDECL_RPL (mbsinit, int, (const mbstate_t *ps));
+_GL_CXXALIAS_RPL (mbsinit, int, (const mbstate_t *ps));
+# else
+#  if !@HAVE_MBSINIT@
+_GL_FUNCDECL_SYS (mbsinit, int, (const mbstate_t *ps));
+#  endif
+_GL_CXXALIAS_SYS (mbsinit, int, (const mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (mbsinit);
+#elif defined GNULIB_POSIXCHECK
+# undef mbsinit
+# if HAVE_RAW_DECL_MBSINIT
+_GL_WARN_ON_USE (mbsinit, "mbsinit is unportable - "
+                 "use gnulib module mbsinit for portability");
+# endif
+#endif
+
+
+/* Convert a multibyte character to a wide character.  */
+#if @GNULIB_MBRTOWC@
+# if @REPLACE_MBRTOWC@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbrtowc
+#   define mbrtowc rpl_mbrtowc
+#  endif
+_GL_FUNCDECL_RPL (mbrtowc, size_t,
+                  (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps));
+_GL_CXXALIAS_RPL (mbrtowc, size_t,
+                  (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps));
+# else
+#  if !@HAVE_MBRTOWC@
+_GL_FUNCDECL_SYS (mbrtowc, size_t,
+                  (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps));
+#  endif
+_GL_CXXALIAS_SYS (mbrtowc, size_t,
+                  (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (mbrtowc);
+#elif defined GNULIB_POSIXCHECK
+# undef mbrtowc
+# if HAVE_RAW_DECL_MBRTOWC
+_GL_WARN_ON_USE (mbrtowc, "mbrtowc is unportable - "
+                 "use gnulib module mbrtowc for portability");
+# endif
+#endif
+
+
+/* Recognize a multibyte character.  */
+#if @GNULIB_MBRLEN@
+# if @REPLACE_MBRLEN@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbrlen
+#   define mbrlen rpl_mbrlen
+#  endif
+_GL_FUNCDECL_RPL (mbrlen, size_t, (const char *s, size_t n, mbstate_t *ps));
+_GL_CXXALIAS_RPL (mbrlen, size_t, (const char *s, size_t n, mbstate_t *ps));
+# else
+#  if !@HAVE_MBRLEN@
+_GL_FUNCDECL_SYS (mbrlen, size_t, (const char *s, size_t n, mbstate_t *ps));
+#  endif
+_GL_CXXALIAS_SYS (mbrlen, size_t, (const char *s, size_t n, mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (mbrlen);
+#elif defined GNULIB_POSIXCHECK
+# undef mbrlen
+# if HAVE_RAW_DECL_MBRLEN
+_GL_WARN_ON_USE (mbrlen, "mbrlen is unportable - "
+                 "use gnulib module mbrlen for portability");
+# endif
+#endif
+
+
+/* Convert a string to a wide string.  */
+#if @GNULIB_MBSRTOWCS@
+# if @REPLACE_MBSRTOWCS@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbsrtowcs
+#   define mbsrtowcs rpl_mbsrtowcs
+#  endif
+_GL_FUNCDECL_RPL (mbsrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t len, mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (mbsrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t len,
+                   mbstate_t *ps));
+# else
+#  if !@HAVE_MBSRTOWCS@
+_GL_FUNCDECL_SYS (mbsrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t len, mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (mbsrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t len,
+                   mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (mbsrtowcs);
+#elif defined GNULIB_POSIXCHECK
+# undef mbsrtowcs
+# if HAVE_RAW_DECL_MBSRTOWCS
+_GL_WARN_ON_USE (mbsrtowcs, "mbsrtowcs is unportable - "
+                 "use gnulib module mbsrtowcs for portability");
+# endif
+#endif
+
+
+/* Convert a string to a wide string.  */
+#if @GNULIB_MBSNRTOWCS@
+# if @REPLACE_MBSNRTOWCS@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbsnrtowcs
+#   define mbsnrtowcs rpl_mbsnrtowcs
+#  endif
+_GL_FUNCDECL_RPL (mbsnrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (mbsnrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps));
+# else
+#  if !@HAVE_MBSNRTOWCS@
+_GL_FUNCDECL_SYS (mbsnrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (mbsnrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (mbsnrtowcs);
+#elif defined GNULIB_POSIXCHECK
+# undef mbsnrtowcs
+# if HAVE_RAW_DECL_MBSNRTOWCS
+_GL_WARN_ON_USE (mbsnrtowcs, "mbsnrtowcs is unportable - "
+                 "use gnulib module mbsnrtowcs for portability");
+# endif
+#endif
+
+
+/* Convert a wide character to a multibyte character.  */
+#if @GNULIB_WCRTOMB@
+# if @REPLACE_WCRTOMB@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcrtomb
+#   define wcrtomb rpl_wcrtomb
+#  endif
+_GL_FUNCDECL_RPL (wcrtomb, size_t, (char *s, wchar_t wc, mbstate_t *ps));
+_GL_CXXALIAS_RPL (wcrtomb, size_t, (char *s, wchar_t wc, mbstate_t *ps));
+# else
+#  if !@HAVE_WCRTOMB@
+_GL_FUNCDECL_SYS (wcrtomb, size_t, (char *s, wchar_t wc, mbstate_t *ps));
+#  endif
+_GL_CXXALIAS_SYS (wcrtomb, size_t, (char *s, wchar_t wc, mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (wcrtomb);
+#elif defined GNULIB_POSIXCHECK
+# undef wcrtomb
+# if HAVE_RAW_DECL_WCRTOMB
+_GL_WARN_ON_USE (wcrtomb, "wcrtomb is unportable - "
+                 "use gnulib module wcrtomb for portability");
+# endif
+#endif
+
+
+/* Convert a wide string to a string.  */
+#if @GNULIB_WCSRTOMBS@
+# if @REPLACE_WCSRTOMBS@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcsrtombs
+#   define wcsrtombs rpl_wcsrtombs
+#  endif
+_GL_FUNCDECL_RPL (wcsrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t len, mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (wcsrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t len,
+                   mbstate_t *ps));
+# else
+#  if !@HAVE_WCSRTOMBS@
+_GL_FUNCDECL_SYS (wcsrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t len, mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (wcsrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t len,
+                   mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (wcsrtombs);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsrtombs
+# if HAVE_RAW_DECL_WCSRTOMBS
+_GL_WARN_ON_USE (wcsrtombs, "wcsrtombs is unportable - "
+                 "use gnulib module wcsrtombs for portability");
+# endif
+#endif
+
+
+/* Convert a wide string to a string.  */
+#if @GNULIB_WCSNRTOMBS@
+# if @REPLACE_WCSNRTOMBS@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcsnrtombs
+#   define wcsnrtombs rpl_wcsnrtombs
+#  endif
+_GL_FUNCDECL_RPL (wcsnrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (wcsnrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps));
+# else
+#  if !@HAVE_WCSNRTOMBS@
+_GL_FUNCDECL_SYS (wcsnrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (wcsnrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (wcsnrtombs);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsnrtombs
+# if HAVE_RAW_DECL_WCSNRTOMBS
+_GL_WARN_ON_USE (wcsnrtombs, "wcsnrtombs is unportable - "
+                 "use gnulib module wcsnrtombs for portability");
+# endif
+#endif
+
+
+/* Return the number of screen columns needed for WC.  */
+#if @GNULIB_WCWIDTH@
+# if @REPLACE_WCWIDTH@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcwidth
+#   define wcwidth rpl_wcwidth
+#  endif
+_GL_FUNCDECL_RPL (wcwidth, int, (wchar_t));
+_GL_CXXALIAS_RPL (wcwidth, int, (wchar_t));
+# else
+#  if !@HAVE_DECL_WCWIDTH@
+/* wcwidth exists but is not declared.  */
+_GL_FUNCDECL_SYS (wcwidth, int, (wchar_t));
+#  endif
+_GL_CXXALIAS_SYS (wcwidth, int, (wchar_t));
+# endif
+_GL_CXXALIASWARN (wcwidth);
+#elif defined GNULIB_POSIXCHECK
+# undef wcwidth
+# if HAVE_RAW_DECL_WCWIDTH
+_GL_WARN_ON_USE (wcwidth, "wcwidth is unportable - "
+                 "use gnulib module wcwidth for portability");
+# endif
+#endif
+
+
+#endif /* _GL_WCHAR_H */
+#endif /* _GL_WCHAR_H */
+#endif
--- a/lib/gl/Makefile.am
+++ b/lib/gl/Makefile.am
@@ -1,6 +1,6 @@
 ## DO NOT EDIT! GENERATED AUTOMATICALLY!
 ## Process this file with automake to produce Makefile.in.
-# Copyright (C) 2002-2009 Free Software Foundation, Inc.
+# Copyright (C) 2002-2010 Free Software Foundation, Inc.
 #
 # This file is free software, distributed under the terms of the GNU
 # General Public License.  As a special exception to the GNU General
@@ -9,9 +9,9 @@
 # the same distribution terms as the rest of that program.
 #
 # Generated by gnulib-tool.
-# Reproduce by: gnulib-tool --import --dir=. --local-dir=lib/gl/override --lib=libgnu --source-base=lib/gl --m4-base=lib/gl/m4 --doc-base=doc --tests-base=lib/gltests --aux-dir=build-aux --with-tests --lgpl=2 --libtool --macro-prefix=lgl --no-vc-files gettext-h lib-msvc-compat lib-symbol-versions lib-symbol-visibility stdint striconv strverscmp
+# Reproduce by: gnulib-tool --import --dir=. --local-dir=lib/gl/override --lib=libgnu --source-base=lib/gl --m4-base=lib/gl/m4 --doc-base=doc --tests-base=lib/gltests --aux-dir=build-aux --with-tests --lgpl --libtool --macro-prefix=lgl --no-vc-files gettext-h lib-msvc-compat lib-symbol-versions lib-symbol-visibility stdint striconv strverscmp unistr/u8-check
 
-AUTOMAKE_OPTIONS = 1.5 gnits
+AUTOMAKE_OPTIONS = 1.5 gnits subdir-objects
 
 SUBDIRS =
 noinst_HEADERS =
@@ -38,6 +38,54 @@ libgnu_la_DEPENDENCIES = $(lgl_LTLIBOBJS
 EXTRA_libgnu_la_SOURCES =
 libgnu_la_LDFLAGS = $(AM_LDFLAGS)
 
+## begin gnulib module arg-nonnull
+
+# The BUILT_SOURCES created by this Makefile snippet are not used via #include
+# statements but through direct file reference. Therefore this snippet must be
+# present in all Makefile.am that need it. This is ensured by the applicability
+# 'all' defined above.
+
+BUILT_SOURCES += arg-nonnull.h
+# The arg-nonnull.h that gets inserted into generated .h files is the same as
+# build-aux/arg-nonnull.h, except that it has the copyright header cut off.
+arg-nonnull.h: $(top_srcdir)/build-aux/arg-nonnull.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	sed -n -e '/GL_ARG_NONNULL/,$$p' \
+	  < $(top_srcdir)/build-aux/arg-nonnull.h \
+	  > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += arg-nonnull.h arg-nonnull.h-t
+
+ARG_NONNULL_H=arg-nonnull.h
+
+EXTRA_DIST += $(top_srcdir)/build-aux/arg-nonnull.h
+
+## end   gnulib module arg-nonnull
+
+## begin gnulib module c++defs
+
+# The BUILT_SOURCES created by this Makefile snippet are not used via #include
+# statements but through direct file reference. Therefore this snippet must be
+# present in all Makefile.am that need it. This is ensured by the applicability
+# 'all' defined above.
+
+BUILT_SOURCES += c++defs.h
+# The c++defs.h that gets inserted into generated .h files is the same as
+# build-aux/c++defs.h, except that it has the copyright header cut off.
+c++defs.h: $(top_srcdir)/build-aux/c++defs.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	sed -n -e '/_GL_CXXDEFS/,$$p' \
+	  < $(top_srcdir)/build-aux/c++defs.h \
+	  > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += c++defs.h c++defs.h-t
+
+CXXDEFS_H=c++defs.h
+
+EXTRA_DIST += $(top_srcdir)/build-aux/c++defs.h
+
+## end   gnulib module c++defs
+
 ## begin gnulib module c-ctype
 
 libgnu_la_SOURCES += c-ctype.h c-ctype.c
@@ -69,14 +117,14 @@ EXTRA_DIST += $(top_srcdir)/build-aux/co
 
 ## end   gnulib module havelib
 
-## begin gnulib module iconv_open
+## begin gnulib module iconv-h
 
 BUILT_SOURCES += $(ICONV_H)
 
 # We need the following in order to create <iconv.h> when the system
 # doesn't have one that works with the given compiler.
-iconv.h: iconv.in.h
-	rm -f $@-t $@
+iconv.h: iconv.in.h $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
+	$(AM_V_GEN)rm -f $@-t $@ && \
 	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
 	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
 	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
@@ -85,11 +133,20 @@ iconv.h: iconv.in.h
 	      -e 's|@''REPLACE_ICONV''@|$(REPLACE_ICONV)|g' \
 	      -e 's|@''REPLACE_ICONV_OPEN''@|$(REPLACE_ICONV_OPEN)|g' \
 	      -e 's|@''REPLACE_ICONV_UTF''@|$(REPLACE_ICONV_UTF)|g' \
+	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
+	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
+	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
 	      < $(srcdir)/iconv.in.h; \
-	} > $@-t
+	} > $@-t && \
 	mv $@-t $@
 MOSTLYCLEANFILES += iconv.h iconv.h-t
 
+EXTRA_DIST += iconv.in.h
+
+## end   gnulib module iconv-h
+
+## begin gnulib module iconv_open
+
 iconv_open-aix.h: iconv_open-aix.gperf
 	$(GPERF) -m 10 $(srcdir)/iconv_open-aix.gperf > $(srcdir)/iconv_open-aix.h-t
 	mv $(srcdir)/iconv_open-aix.h-t $(srcdir)/iconv_open-aix.h
@@ -102,12 +159,15 @@ iconv_open-irix.h: iconv_open-irix.gperf
 iconv_open-osf.h: iconv_open-osf.gperf
 	$(GPERF) -m 10 $(srcdir)/iconv_open-osf.gperf > $(srcdir)/iconv_open-osf.h-t
 	mv $(srcdir)/iconv_open-osf.h-t $(srcdir)/iconv_open-osf.h
-BUILT_SOURCES        += iconv_open-aix.h iconv_open-hpux.h iconv_open-irix.h iconv_open-osf.h
-MOSTLYCLEANFILES     += iconv_open-aix.h-t iconv_open-hpux.h-t iconv_open-irix.h-t iconv_open-osf.h-t
-MAINTAINERCLEANFILES += iconv_open-aix.h iconv_open-hpux.h iconv_open-irix.h iconv_open-osf.h
-EXTRA_DIST           += iconv_open-aix.h iconv_open-hpux.h iconv_open-irix.h iconv_open-osf.h
+iconv_open-solaris.h: iconv_open-solaris.gperf
+	$(GPERF) -m 10 $(srcdir)/iconv_open-solaris.gperf > $(srcdir)/iconv_open-solaris.h-t
+	mv $(srcdir)/iconv_open-solaris.h-t $(srcdir)/iconv_open-solaris.h
+BUILT_SOURCES        += iconv_open-aix.h iconv_open-hpux.h iconv_open-irix.h iconv_open-osf.h iconv_open-solaris.h
+MOSTLYCLEANFILES     += iconv_open-aix.h-t iconv_open-hpux.h-t iconv_open-irix.h-t iconv_open-osf.h-t iconv_open-solaris.h-t
+MAINTAINERCLEANFILES += iconv_open-aix.h iconv_open-hpux.h iconv_open-irix.h iconv_open-osf.h iconv_open-solaris.h
+EXTRA_DIST           += iconv_open-aix.h iconv_open-hpux.h iconv_open-irix.h iconv_open-osf.h iconv_open-solaris.h
 
-EXTRA_DIST += iconv.in.h iconv_open-aix.gperf iconv_open-hpux.gperf iconv_open-irix.gperf iconv_open-osf.gperf iconv_open.c
+EXTRA_DIST += iconv_open-aix.gperf iconv_open-hpux.gperf iconv_open-irix.gperf iconv_open-osf.gperf iconv_open-solaris.gperf iconv_open.c
 
 EXTRA_libgnu_la_SOURCES += iconv_open.c
 
@@ -123,14 +183,6 @@ AM_CFLAGS += $(CFLAG_VISIBILITY)
 
 ## end   gnulib module lib-symbol-visibility
 
-## begin gnulib module link-warning
-
-LINK_WARNING_H=$(top_srcdir)/build-aux/link-warning.h
-
-EXTRA_DIST += $(top_srcdir)/build-aux/link-warning.h
-
-## end   gnulib module link-warning
-
 ## begin gnulib module stdbool
 
 BUILT_SOURCES += $(STDBOOL_H)
@@ -138,10 +190,10 @@ BUILT_SOURCES += $(STDBOOL_H)
 # We need the following in order to create <stdbool.h> when the system
 # doesn't have one that works.
 stdbool.h: stdbool.in.h
-	rm -f $@-t $@
+	$(AM_V_GEN)rm -f $@-t $@ && \
 	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
 	  sed -e 's/@''HAVE__BOOL''@/$(HAVE__BOOL)/g' < $(srcdir)/stdbool.in.h; \
-	} > $@-t
+	} > $@-t && \
 	mv $@-t $@
 MOSTLYCLEANFILES += stdbool.h stdbool.h-t
 
@@ -149,6 +201,29 @@ EXTRA_DIST += stdbool.in.h
 
 ## end   gnulib module stdbool
 
+## begin gnulib module stddef
+
+BUILT_SOURCES += $(STDDEF_H)
+
+# We need the following in order to create <stddef.h> when the system
+# doesn't have one that works with the given compiler.
+stddef.h: stddef.in.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
+	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
+	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
+	      -e 's|@''NEXT_STDDEF_H''@|$(NEXT_STDDEF_H)|g' \
+	      -e 's|@''HAVE_WCHAR_T''@|$(HAVE_WCHAR_T)|g' \
+	      -e 's|@''REPLACE_NULL''@|$(REPLACE_NULL)|g' \
+	      < $(srcdir)/stddef.in.h; \
+	} > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += stddef.h stddef.h-t
+
+EXTRA_DIST += stddef.in.h
+
+## end   gnulib module stddef
+
 ## begin gnulib module stdint
 
 BUILT_SOURCES += $(STDINT_H)
@@ -156,7 +231,7 @@ BUILT_SOURCES += $(STDINT_H)
 # We need the following in order to create <stdint.h> when the system
 # doesn't have one that works with the given compiler.
 stdint.h: stdint.in.h
-	rm -f $@-t $@
+	$(AM_V_GEN)rm -f $@-t $@ && \
 	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
 	  sed -e 's/@''HAVE_STDINT_H''@/$(HAVE_STDINT_H)/g' \
 	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
@@ -183,7 +258,7 @@ stdint.h: stdint.in.h
 	      -e 's/@''HAVE_SIGNED_WINT_T''@/$(HAVE_SIGNED_WINT_T)/g' \
 	      -e 's/@''WINT_T_SUFFIX''@/$(WINT_T_SUFFIX)/g' \
 	      < $(srcdir)/stdint.in.h; \
-	} > $@-t
+	} > $@-t && \
 	mv $@-t $@
 MOSTLYCLEANFILES += stdint.h stdint.h-t
 
@@ -206,8 +281,8 @@ BUILT_SOURCES += string.h
 
 # We need the following in order to create <string.h> when the system
 # doesn't have one that works with the given compiler.
-string.h: string.in.h
-	rm -f $@-t $@
+string.h: string.in.h $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
+	$(AM_V_GEN)rm -f $@-t $@ && \
 	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
 	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
 	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
@@ -226,6 +301,7 @@ string.h: string.in.h
 	      -e 's|@''GNULIB_MBSSPN''@|$(GNULIB_MBSSPN)|g' \
 	      -e 's|@''GNULIB_MBSSEP''@|$(GNULIB_MBSSEP)|g' \
 	      -e 's|@''GNULIB_MBSTOK_R''@|$(GNULIB_MBSTOK_R)|g' \
+	      -e 's|@''GNULIB_MEMCHR''@|$(GNULIB_MEMCHR)|g' \
 	      -e 's|@''GNULIB_MEMMEM''@|$(GNULIB_MEMMEM)|g' \
 	      -e 's|@''GNULIB_MEMPCPY''@|$(GNULIB_MEMPCPY)|g' \
 	      -e 's|@''GNULIB_MEMRCHR''@|$(GNULIB_MEMRCHR)|g' \
@@ -234,6 +310,7 @@ string.h: string.in.h
 	      -e 's|@''GNULIB_STPNCPY''@|$(GNULIB_STPNCPY)|g' \
 	      -e 's|@''GNULIB_STRCHRNUL''@|$(GNULIB_STRCHRNUL)|g' \
 	      -e 's|@''GNULIB_STRDUP''@|$(GNULIB_STRDUP)|g' \
+	      -e 's|@''GNULIB_STRNCAT''@|$(GNULIB_STRNCAT)|g' \
 	      -e 's|@''GNULIB_STRNDUP''@|$(GNULIB_STRNDUP)|g' \
 	      -e 's|@''GNULIB_STRNLEN''@|$(GNULIB_STRNLEN)|g' \
 	      -e 's|@''GNULIB_STRPBRK''@|$(GNULIB_STRPBRK)|g' \
@@ -244,6 +321,9 @@ string.h: string.in.h
 	      -e 's|@''GNULIB_STRERROR''@|$(GNULIB_STRERROR)|g' \
 	      -e 's|@''GNULIB_STRSIGNAL''@|$(GNULIB_STRSIGNAL)|g' \
 	      -e 's|@''GNULIB_STRVERSCMP''@|$(GNULIB_STRVERSCMP)|g' \
+	      < $(srcdir)/string.in.h | \
+	  sed -e 's|@''HAVE_MBSLEN''@|$(HAVE_MBSLEN)|g' \
+	      -e 's|@''HAVE_MEMCHR''@|$(HAVE_MEMCHR)|g' \
 	      -e 's|@''HAVE_DECL_MEMMEM''@|$(HAVE_DECL_MEMMEM)|g' \
 	      -e 's|@''HAVE_MEMPCPY''@|$(HAVE_MEMPCPY)|g' \
 	      -e 's|@''HAVE_DECL_MEMRCHR''@|$(HAVE_DECL_MEMRCHR)|g' \
@@ -252,25 +332,32 @@ string.h: string.in.h
 	      -e 's|@''HAVE_STPNCPY''@|$(HAVE_STPNCPY)|g' \
 	      -e 's|@''HAVE_STRCHRNUL''@|$(HAVE_STRCHRNUL)|g' \
 	      -e 's|@''HAVE_DECL_STRDUP''@|$(HAVE_DECL_STRDUP)|g' \
-	      -e 's|@''HAVE_STRNDUP''@|$(HAVE_STRNDUP)|g' \
 	      -e 's|@''HAVE_DECL_STRNDUP''@|$(HAVE_DECL_STRNDUP)|g' \
 	      -e 's|@''HAVE_DECL_STRNLEN''@|$(HAVE_DECL_STRNLEN)|g' \
 	      -e 's|@''HAVE_STRPBRK''@|$(HAVE_STRPBRK)|g' \
 	      -e 's|@''HAVE_STRSEP''@|$(HAVE_STRSEP)|g' \
 	      -e 's|@''HAVE_STRCASESTR''@|$(HAVE_STRCASESTR)|g' \
 	      -e 's|@''HAVE_DECL_STRTOK_R''@|$(HAVE_DECL_STRTOK_R)|g' \
-	      -e 's|@''HAVE_DECL_STRERROR''@|$(HAVE_DECL_STRERROR)|g' \
 	      -e 's|@''HAVE_DECL_STRSIGNAL''@|$(HAVE_DECL_STRSIGNAL)|g' \
 	      -e 's|@''HAVE_STRVERSCMP''@|$(HAVE_STRVERSCMP)|g' \
+	      -e 's|@''REPLACE_STPNCPY''@|$(REPLACE_STPNCPY)|g' \
+	      -e 's|@''REPLACE_MEMCHR''@|$(REPLACE_MEMCHR)|g' \
 	      -e 's|@''REPLACE_MEMMEM''@|$(REPLACE_MEMMEM)|g' \
 	      -e 's|@''REPLACE_STRCASESTR''@|$(REPLACE_STRCASESTR)|g' \
 	      -e 's|@''REPLACE_STRDUP''@|$(REPLACE_STRDUP)|g' \
 	      -e 's|@''REPLACE_STRSTR''@|$(REPLACE_STRSTR)|g' \
 	      -e 's|@''REPLACE_STRERROR''@|$(REPLACE_STRERROR)|g' \
+	      -e 's|@''REPLACE_STRNCAT''@|$(REPLACE_STRNCAT)|g' \
+	      -e 's|@''REPLACE_STRNDUP''@|$(REPLACE_STRNDUP)|g' \
+	      -e 's|@''REPLACE_STRNLEN''@|$(REPLACE_STRNLEN)|g' \
 	      -e 's|@''REPLACE_STRSIGNAL''@|$(REPLACE_STRSIGNAL)|g' \
-	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
+	      -e 's|@''REPLACE_STRTOK_R''@|$(REPLACE_STRTOK_R)|g' \
+	      -e 's|@''UNDEFINE_STRTOK_R''@|$(UNDEFINE_STRTOK_R)|g' \
+	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
+	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
+	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)'; \
 	      < $(srcdir)/string.in.h; \
-	} > $@-t
+	} > $@-t && \
 	mv $@-t $@
 MOSTLYCLEANFILES += string.h string.h-t
 
@@ -287,14 +374,98 @@ EXTRA_libgnu_la_SOURCES += strverscmp.c
 
 ## end   gnulib module strverscmp
 
+## begin gnulib module unistr/base
+
+BUILT_SOURCES += $(LIBUNISTRING_UNISTR_H)
+
+unistr.h: unistr.in.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  cat $(srcdir)/unistr.in.h; \
+	} > $@-t && \
+	mv -f $@-t $@
+MOSTLYCLEANFILES += unistr.h unistr.h-t
+
+EXTRA_DIST += unistr.in.h
+
+## end   gnulib module unistr/base
+
+## begin gnulib module unistr/u8-check
+
+if LIBUNISTRING_COMPILE_UNISTR_U8_CHECK
+libgnu_la_SOURCES += unistr/u8-check.c
+endif
+
+## end   gnulib module unistr/u8-check
+
+## begin gnulib module unitypes
+
+BUILT_SOURCES += $(LIBUNISTRING_UNITYPES_H)
+
+unitypes.h: unitypes.in.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  cat $(srcdir)/unitypes.in.h; \
+	} > $@-t && \
+	mv -f $@-t $@
+MOSTLYCLEANFILES += unitypes.h unitypes.h-t
+
+EXTRA_DIST += unitypes.in.h
+
+## end   gnulib module unitypes
+
+## begin gnulib module unused-parameter
+
+# The BUILT_SOURCES created by this Makefile snippet are not used via #include
+# statements but through direct file reference. Therefore this snippet must be
+# present in all Makefile.am that need it. This is ensured by the applicability
+# 'all' defined above.
+
+BUILT_SOURCES += unused-parameter.h
+# The unused-parameter.h that gets inserted into generated .h files is the same
+# as build-aux/unused-parameter.h, except that it has the copyright header cut
+# off.
+unused-parameter.h: $(top_srcdir)/build-aux/unused-parameter.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	sed -n -e '/GL_UNUSED_PARAMETER/,$$p' \
+	  < $(top_srcdir)/build-aux/unused-parameter.h \
+	  > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += unused-parameter.h unused-parameter.h-t
+
+UNUSED_PARAMETER_H=unused-parameter.h
+
+EXTRA_DIST += $(top_srcdir)/build-aux/unused-parameter.h
+
+## end   gnulib module unused-parameter
+
+## begin gnulib module warn-on-use
+
+BUILT_SOURCES += warn-on-use.h
+# The warn-on-use.h that gets inserted into generated .h files is the same as
+# build-aux/warn-on-use.h, except that it has the copyright header cut off.
+warn-on-use.h: $(top_srcdir)/build-aux/warn-on-use.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	sed -n -e '/^.ifndef/,$$p' \
+	  < $(top_srcdir)/build-aux/warn-on-use.h \
+	  > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += warn-on-use.h warn-on-use.h-t
+
+WARN_ON_USE_H=warn-on-use.h
+
+EXTRA_DIST += $(top_srcdir)/build-aux/warn-on-use.h
+
+## end   gnulib module warn-on-use
+
 ## begin gnulib module wchar
 
-BUILT_SOURCES += $(WCHAR_H)
+BUILT_SOURCES += wchar.h
 
 # We need the following in order to create <wchar.h> when the system
 # version does not work standalone.
-wchar.h: wchar.in.h
-	rm -f $@-t $@
+wchar.h: wchar.in.h $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
+	$(AM_V_GEN)rm -f $@-t $@ && \
 	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
 	  sed -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
 	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
@@ -335,9 +506,11 @@ wchar.h: wchar.in.h
 	      -e 's|@''REPLACE_WCSRTOMBS''@|$(REPLACE_WCSRTOMBS)|g' \
 	      -e 's|@''REPLACE_WCSNRTOMBS''@|$(REPLACE_WCSNRTOMBS)|g' \
 	      -e 's|@''REPLACE_WCWIDTH''@|$(REPLACE_WCWIDTH)|g' \
-	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
+	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
+	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
+	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
 	    < $(srcdir)/wchar.in.h; \
-	} > $@-t
+	} > $@-t && \
 	mv $@-t $@
 MOSTLYCLEANFILES += wchar.h wchar.h-t
 
--- a/lib/gl/c-ctype.c
+++ b/lib/gl/c-ctype.c
@@ -1,10 +1,10 @@
 /* Character handling in C locale.
 
-   Copyright 2000-2003, 2006 Free Software Foundation, Inc.
+   Copyright 2000-2003, 2006, 2009-2010 Free Software Foundation, Inc.
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
--- a/lib/gl/c-ctype.h
+++ b/lib/gl/c-ctype.h
@@ -5,11 +5,11 @@
    <ctype.h> functions' behaviour depends on the current locale set via
    setlocale.
 
-   Copyright (C) 2000-2003, 2006, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2000-2003, 2006, 2008-2010 Free Software Foundation, Inc.
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
--- a/lib/gl/c-strcase.h
+++ b/lib/gl/c-strcase.h
@@ -1,9 +1,10 @@
 /* Case-insensitive string comparison functions in C locale.
-   Copyright (C) 1995-1996, 2001, 2003, 2005 Free Software Foundation, Inc.
+   Copyright (C) 1995-1996, 2001, 2003, 2005, 2009-2010 Free Software
+   Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    This program is distributed in the hope that it will be useful,
--- a/lib/gl/c-strcasecmp.c
+++ b/lib/gl/c-strcasecmp.c
@@ -1,9 +1,9 @@
 /* c-strcasecmp.c -- case insensitive string comparator in C locale
-   Copyright (C) 1998-1999, 2005-2006 Free Software Foundation, Inc.
+   Copyright (C) 1998-1999, 2005-2006, 2009-2010 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -40,7 +40,7 @@ c_strcasecmp (const char *s1, const char
       c2 = c_tolower (*p2);
 
       if (c1 == '\0')
-	break;
+        break;
 
       ++p1;
       ++p2;
--- a/lib/gl/c-strncasecmp.c
+++ b/lib/gl/c-strncasecmp.c
@@ -1,9 +1,9 @@
 /* c-strncasecmp.c -- case insensitive string comparator in C locale
-   Copyright (C) 1998-1999, 2005-2006 Free Software Foundation, Inc.
+   Copyright (C) 1998-1999, 2005-2006, 2009-2010 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -40,7 +40,7 @@ c_strncasecmp (const char *s1, const cha
       c2 = c_tolower (*p2);
 
       if (--n == 0 || c1 == '\0')
-	break;
+        break;
 
       ++p1;
       ++p2;
--- a/lib/gl/gettext.h
+++ b/lib/gl/gettext.h
@@ -1,9 +1,10 @@
 /* Convenience header for conditional use of GNU <libintl.h>.
-   Copyright (C) 1995-1998, 2000-2002, 2004-2006, 2009 Free Software Foundation, Inc.
+   Copyright (C) 1995-1998, 2000-2002, 2004-2006, 2009-2010 Free Software
+   Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -80,7 +81,7 @@
     ((void) (Domainname), ngettext (Msgid1, Msgid2, N))
 # undef dcngettext
 # define dcngettext(Domainname, Msgid1, Msgid2, N, Category) \
-    ((void) (Category), dngettext(Domainname, Msgid1, Msgid2, N))
+    ((void) (Category), dngettext (Domainname, Msgid1, Msgid2, N))
 # undef textdomain
 # define textdomain(Domainname) ((const char *) (Domainname))
 # undef bindtextdomain
@@ -140,8 +141,8 @@ inline
 #endif
 static const char *
 pgettext_aux (const char *domain,
-	      const char *msg_ctxt_id, const char *msgid,
-	      int category)
+              const char *msg_ctxt_id, const char *msgid,
+              int category)
 {
   const char *translation = dcgettext (domain, msg_ctxt_id, category);
   if (translation == msg_ctxt_id)
@@ -159,9 +160,9 @@ inline
 #endif
 static const char *
 npgettext_aux (const char *domain,
-	       const char *msg_ctxt_id, const char *msgid,
-	       const char *msgid_plural, unsigned long int n,
-	       int category)
+               const char *msg_ctxt_id, const char *msgid,
+               const char *msgid_plural, unsigned long int n,
+               int category)
 {
   const char *translation =
     dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);
@@ -171,4 +172,109 @@ npgettext_aux (const char *domain,
     return translation;
 }
 
+/* The same thing extended for non-constant arguments.  Here MSGCTXT and MSGID
+   can be arbitrary expressions.  But for string literals these macros are
+   less efficient than those above.  */
+
+#include <string.h>
+
+#define _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS \
+  (((__GNUC__ >= 3 || __GNUG__ >= 2) && !__STRICT_ANSI__) \
+   /* || __STDC_VERSION__ >= 199901L */ )
+
+#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
+#include <stdlib.h>
+#endif
+
+#define pgettext_expr(Msgctxt, Msgid) \
+  dcpgettext_expr (NULL, Msgctxt, Msgid, LC_MESSAGES)
+#define dpgettext_expr(Domainname, Msgctxt, Msgid) \
+  dcpgettext_expr (Domainname, Msgctxt, Msgid, LC_MESSAGES)
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static const char *
+dcpgettext_expr (const char *domain,
+                 const char *msgctxt, const char *msgid,
+                 int category)
+{
+  size_t msgctxt_len = strlen (msgctxt) + 1;
+  size_t msgid_len = strlen (msgid) + 1;
+  const char *translation;
+#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
+  char msg_ctxt_id[msgctxt_len + msgid_len];
+#else
+  char buf[1024];
+  char *msg_ctxt_id =
+    (msgctxt_len + msgid_len <= sizeof (buf)
+     ? buf
+     : (char *) malloc (msgctxt_len + msgid_len));
+  if (msg_ctxt_id != NULL)
+#endif
+    {
+      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);
+      msg_ctxt_id[msgctxt_len - 1] = '\004';
+      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);
+      translation = dcgettext (domain, msg_ctxt_id, category);
+#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
+      if (msg_ctxt_id != buf)
+        free (msg_ctxt_id);
+#endif
+      if (translation != msg_ctxt_id)
+        return translation;
+    }
+  return msgid;
+}
+
+#define npgettext_expr(Msgctxt, Msgid, MsgidPlural, N) \
+  dcnpgettext_expr (NULL, Msgctxt, Msgid, MsgidPlural, N, LC_MESSAGES)
+#define dnpgettext_expr(Domainname, Msgctxt, Msgid, MsgidPlural, N) \
+  dcnpgettext_expr (Domainname, Msgctxt, Msgid, MsgidPlural, N, LC_MESSAGES)
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static const char *
+dcnpgettext_expr (const char *domain,
+                  const char *msgctxt, const char *msgid,
+                  const char *msgid_plural, unsigned long int n,
+                  int category)
+{
+  size_t msgctxt_len = strlen (msgctxt) + 1;
+  size_t msgid_len = strlen (msgid) + 1;
+  const char *translation;
+#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
+  char msg_ctxt_id[msgctxt_len + msgid_len];
+#else
+  char buf[1024];
+  char *msg_ctxt_id =
+    (msgctxt_len + msgid_len <= sizeof (buf)
+     ? buf
+     : (char *) malloc (msgctxt_len + msgid_len));
+  if (msg_ctxt_id != NULL)
+#endif
+    {
+      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);
+      msg_ctxt_id[msgctxt_len - 1] = '\004';
+      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);
+      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);
+#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
+      if (msg_ctxt_id != buf)
+        free (msg_ctxt_id);
+#endif
+      if (!(translation == msg_ctxt_id || translation == msgid_plural))
+        return translation;
+    }
+  return (n == 1 ? msgid : msgid_plural);
+}
+
 #endif /* _LIBGETTEXT_H */
--- a/lib/gl/iconv.in.h
+++ b/lib/gl/iconv.in.h
@@ -1,10 +1,10 @@
 /* A GNU-like <iconv.h>.
 
-   Copyright (C) 2007-2008 Free Software Foundation, Inc.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -28,17 +28,29 @@
 #ifndef _GL_ICONV_H
 #define _GL_ICONV_H
 
-#ifdef __cplusplus
-extern "C" {
-#endif
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
 
 
 #if @REPLACE_ICONV_OPEN@
 /* An iconv_open wrapper that supports the IANA standardized encoding names
    ("ISO-8859-1" etc.) as far as possible.  */
-# define iconv_open rpl_iconv_open
-extern iconv_t iconv_open (const char *tocode, const char *fromcode);
+# if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#  define iconv_open rpl_iconv_open
+# endif
+_GL_FUNCDECL_RPL (iconv_open, iconv_t,
+                  (const char *tocode, const char *fromcode)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (iconv_open, iconv_t,
+                  (const char *tocode, const char *fromcode));
+#else
+_GL_CXXALIAS_SYS (iconv_open, iconv_t,
+                  (const char *tocode, const char *fromcode));
 #endif
+_GL_CXXALIASWARN (iconv_open);
 
 #if @REPLACE_ICONV_UTF@
 /* Special constants for supporting UTF-{16,32}{BE,LE} encodings.
@@ -54,18 +66,36 @@ extern iconv_t iconv_open (const char *t
 #endif
 
 #if @REPLACE_ICONV@
-# define iconv rpl_iconv
-extern size_t iconv (iconv_t cd,
-		     @ICONV_CONST@ char **inbuf, size_t *inbytesleft,
-		     char **outbuf, size_t *outbytesleft);
-# define iconv_close rpl_iconv_close
-extern int iconv_close (iconv_t cd);
+# if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#  define iconv rpl_iconv
+# endif
+_GL_FUNCDECL_RPL (iconv, size_t,
+                  (iconv_t cd,
+                   @ICONV_CONST@ char **inbuf, size_t *inbytesleft,
+                   char **outbuf, size_t *outbytesleft));
+_GL_CXXALIAS_RPL (iconv, size_t,
+                  (iconv_t cd,
+                   @ICONV_CONST@ char **inbuf, size_t *inbytesleft,
+                   char **outbuf, size_t *outbytesleft));
+#else
+_GL_CXXALIAS_SYS (iconv, size_t,
+                  (iconv_t cd,
+                   @ICONV_CONST@ char **inbuf, size_t *inbytesleft,
+                   char **outbuf, size_t *outbytesleft));
 #endif
+_GL_CXXALIASWARN (iconv);
 
-
-#ifdef __cplusplus
-}
+#if @REPLACE_ICONV@
+# if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#  define iconv_close rpl_iconv_close
+# endif
+_GL_FUNCDECL_RPL (iconv_close, int, (iconv_t cd));
+_GL_CXXALIAS_RPL (iconv_close, int, (iconv_t cd));
+#else
+_GL_CXXALIAS_SYS (iconv_close, int, (iconv_t cd));
 #endif
+_GL_CXXALIASWARN (iconv_close);
+
 
 #endif /* _GL_ICONV_H */
 #endif /* _GL_ICONV_H */
--- /dev/null
+++ b/lib/gl/iconv_open-solaris.gperf
@@ -0,0 +1,30 @@
+struct mapping { int standard_name; const char vendor_name[10 + 1]; };
+%struct-type
+%language=ANSI-C
+%define slot-name standard_name
+%define hash-function-name mapping_hash
+%define lookup-function-name mapping_lookup
+%readonly-tables
+%global-table
+%define word-array-name mappings
+%pic
+%%
+# On Solaris 10, look in the "iconv -l" output. Some aliases are advertised but
+# not actually supported by the iconv() function and by the 'iconv' program.
+# For example:
+#   $ echo abc | iconv -f 646 -t ISO-8859-1
+#   Not supported 646 to ISO-8859-1
+#   $ echo abc | iconv -f 646 -t ISO8859-1
+$   abc
+ASCII, "646"
+ISO-8859-1, "ISO8859-1"
+ISO-8859-2, "ISO8859-2"
+ISO-8859-3, "ISO8859-3"
+ISO-8859-4, "ISO8859-4"
+ISO-8859-5, "ISO8859-5"
+ISO-8859-6, "ISO8859-6"
+ISO-8859-7, "ISO8859-7"
+ISO-8859-8, "ISO8859-8"
+ISO-8859-9, "ISO8859-9"
+ISO-8859-15, "ISO8859-15"
+CP1251, "ansi-1251"
--- a/lib/gl/iconv_open.c
+++ b/lib/gl/iconv_open.c
@@ -1,9 +1,9 @@
 /* Character set conversion.
-   Copyright (C) 2007 Free Software Foundation, Inc.
+   Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -36,6 +36,7 @@
 #define ICONV_FLAVOR_HPUX "iconv_open-hpux.h"
 #define ICONV_FLAVOR_IRIX "iconv_open-irix.h"
 #define ICONV_FLAVOR_OSF "iconv_open-osf.h"
+#define ICONV_FLAVOR_SOLARIS "iconv_open-solaris.h"
 
 #ifdef ICONV_FLAVOR
 # include ICONV_FLAVOR
@@ -66,33 +67,33 @@ rpl_iconv_open (const char *tocode, cons
       && fromcode[3] == '-')
     {
       if (c_toupper (tocode[0]) == 'U'
-	  && c_toupper (tocode[1]) == 'T'
-	  && c_toupper (tocode[2]) == 'F'
-	  && tocode[3] == '-')
-	{
-	  if (strcmp (fromcode + 4, "8") == 0)
-	    {
-	      if (c_strcasecmp (tocode + 4, "16BE") == 0)
-		return _ICONV_UTF8_UTF16BE;
-	      if (c_strcasecmp (tocode + 4, "16LE") == 0)
-		return _ICONV_UTF8_UTF16LE;
-	      if (c_strcasecmp (tocode + 4, "32BE") == 0)
-		return _ICONV_UTF8_UTF32BE;
-	      if (c_strcasecmp (tocode + 4, "32LE") == 0)
-		return _ICONV_UTF8_UTF32LE;
-	    }
-	  else if (strcmp (tocode + 4, "8") == 0)
-	    {
-	      if (c_strcasecmp (fromcode + 4, "16BE") == 0)
-		return _ICONV_UTF16BE_UTF8;
-	      if (c_strcasecmp (fromcode + 4, "16LE") == 0)
-		return _ICONV_UTF16LE_UTF8;
-	      if (c_strcasecmp (fromcode + 4, "32BE") == 0)
-		return _ICONV_UTF32BE_UTF8;
-	      if (c_strcasecmp (fromcode + 4, "32LE") == 0)
-		return _ICONV_UTF32LE_UTF8;
-	    }
-	}
+          && c_toupper (tocode[1]) == 'T'
+          && c_toupper (tocode[2]) == 'F'
+          && tocode[3] == '-')
+        {
+          if (strcmp (fromcode + 4, "8") == 0)
+            {
+              if (c_strcasecmp (tocode + 4, "16BE") == 0)
+                return _ICONV_UTF8_UTF16BE;
+              if (c_strcasecmp (tocode + 4, "16LE") == 0)
+                return _ICONV_UTF8_UTF16LE;
+              if (c_strcasecmp (tocode + 4, "32BE") == 0)
+                return _ICONV_UTF8_UTF32BE;
+              if (c_strcasecmp (tocode + 4, "32LE") == 0)
+                return _ICONV_UTF8_UTF32LE;
+            }
+          else if (strcmp (tocode + 4, "8") == 0)
+            {
+              if (c_strcasecmp (fromcode + 4, "16BE") == 0)
+                return _ICONV_UTF16BE_UTF8;
+              if (c_strcasecmp (fromcode + 4, "16LE") == 0)
+                return _ICONV_UTF16LE_UTF8;
+              if (c_strcasecmp (fromcode + 4, "32BE") == 0)
+                return _ICONV_UTF32BE_UTF8;
+              if (c_strcasecmp (fromcode + 4, "32LE") == 0)
+                return _ICONV_UTF32LE_UTF8;
+            }
+        }
     }
 #endif
 
@@ -115,20 +116,20 @@ rpl_iconv_open (const char *tocode, cons
 
   /* Convert the encodings to upper case, because
        1. in the arguments of iconv_open() on AIX, HP-UX, and OSF/1 the case
-	  matters,
+          matters,
        2. it makes searching in the table faster.  */
   {
     const char *p = fromcode;
     char *q = fromcode_upper;
     while ((*q = c_toupper (*p)) != '\0')
       {
-	p++;
-	q++;
-	if (q == &fromcode_upper[SIZEOF (fromcode_upper)])
-	  {
-	    errno = EINVAL;
-	    return (iconv_t)(-1);
-	  }
+        p++;
+        q++;
+        if (q == &fromcode_upper[SIZEOF (fromcode_upper)])
+          {
+            errno = EINVAL;
+            return (iconv_t)(-1);
+          }
       }
     fromcode_upper_end = q;
   }
@@ -138,13 +139,13 @@ rpl_iconv_open (const char *tocode, cons
     char *q = tocode_upper;
     while ((*q = c_toupper (*p)) != '\0')
       {
-	p++;
-	q++;
-	if (q == &tocode_upper[SIZEOF (tocode_upper)])
-	  {
-	    errno = EINVAL;
-	    return (iconv_t)(-1);
-	  }
+        p++;
+        q++;
+        if (q == &tocode_upper[SIZEOF (tocode_upper)])
+          {
+            errno = EINVAL;
+            return (iconv_t)(-1);
+          }
       }
     tocode_upper_end = q;
   }
--- /dev/null
+++ b/lib/gl/m4/00gnulib.m4
@@ -0,0 +1,30 @@
+# 00gnulib.m4 serial 2
+dnl Copyright (C) 2009-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl This file must be named something that sorts before all other
+dnl gnulib-provided .m4 files.  It is needed until such time as we can
+dnl assume Autoconf 2.64, with its improved AC_DEFUN_ONCE semantics.
+
+# AC_DEFUN_ONCE([NAME], VALUE)
+# ----------------------------
+# Define NAME to expand to VALUE on the first use (whether by direct
+# expansion, or by AC_REQUIRE), and to nothing on all subsequent uses.
+# Avoid bugs in AC_REQUIRE in Autoconf 2.63 and earlier.  This
+# definition is slower than the version in Autoconf 2.64, because it
+# can only use interfaces that existed since 2.59; but it achieves the
+# same effect.  Quoting is necessary to avoid confusing Automake.
+m4_version_prereq([2.63.263], [],
+[m4_define([AC][_DEFUN_ONCE],
+  [AC][_DEFUN([$1],
+    [AC_REQUIRE([_gl_DEFUN_ONCE([$1])],
+      [m4_indir([_gl_DEFUN_ONCE([$1])])])])]dnl
+[AC][_DEFUN([_gl_DEFUN_ONCE([$1])], [$2])])])
+
+# gl_00GNULIB
+# -----------
+# Witness macro that this file has been included.  Needed to force
+# Automake to include this file prior to all other gnulib .m4 files.
+AC_DEFUN([gl_00GNULIB])
--- /dev/null
+++ b/lib/gl/m4/codeset.m4
@@ -0,0 +1,21 @@
+# codeset.m4 serial 4 (gettext-0.18)
+dnl Copyright (C) 2000-2002, 2006, 2008-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([AM_LANGINFO_CODESET],
+[
+  AC_CACHE_CHECK([for nl_langinfo and CODESET], [am_cv_langinfo_codeset],
+    [AC_TRY_LINK([#include <langinfo.h>],
+      [char* cs = nl_langinfo(CODESET); return !cs;],
+      [am_cv_langinfo_codeset=yes],
+      [am_cv_langinfo_codeset=no])
+    ])
+  if test $am_cv_langinfo_codeset = yes; then
+    AC_DEFINE([HAVE_LANGINFO_CODESET], [1],
+      [Define if you have <langinfo.h> and nl_langinfo(CODESET).])
+  fi
+])
--- /dev/null
+++ b/lib/gl/m4/extensions.m4
@@ -0,0 +1,118 @@
+# serial 9  -*- Autoconf -*-
+# Enable extensions on systems that normally disable them.
+
+# Copyright (C) 2003, 2006-2010 Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This definition of AC_USE_SYSTEM_EXTENSIONS is stolen from CVS
+# Autoconf.  Perhaps we can remove this once we can assume Autoconf
+# 2.62 or later everywhere, but since CVS Autoconf mutates rapidly
+# enough in this area it's likely we'll need to redefine
+# AC_USE_SYSTEM_EXTENSIONS for quite some time.
+
+# If autoconf reports a warning
+#     warning: AC_COMPILE_IFELSE was called before AC_USE_SYSTEM_EXTENSIONS
+# or  warning: AC_RUN_IFELSE was called before AC_USE_SYSTEM_EXTENSIONS
+# the fix is
+#   1) to ensure that AC_USE_SYSTEM_EXTENSIONS is never directly invoked
+#      but always AC_REQUIREd,
+#   2) to ensure that for each occurrence of
+#        AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])
+#      or
+#        AC_REQUIRE([gl_USE_SYSTEM_EXTENSIONS])
+#      the corresponding gnulib module description has 'extensions' among
+#      its dependencies. This will ensure that the gl_USE_SYSTEM_EXTENSIONS
+#      invocation occurs in gl_EARLY, not in gl_INIT.
+
+# AC_USE_SYSTEM_EXTENSIONS
+# ------------------------
+# Enable extensions on systems that normally disable them,
+# typically due to standards-conformance issues.
+# Remember that #undef in AH_VERBATIM gets replaced with #define by
+# AC_DEFINE.  The goal here is to define all known feature-enabling
+# macros, then, if reports of conflicts are made, disable macros that
+# cause problems on some platforms (such as __EXTENSIONS__).
+AC_DEFUN_ONCE([AC_USE_SYSTEM_EXTENSIONS],
+[AC_BEFORE([$0], [AC_COMPILE_IFELSE])dnl
+AC_BEFORE([$0], [AC_RUN_IFELSE])dnl
+
+  AC_REQUIRE([AC_CANONICAL_HOST])
+
+  AC_CHECK_HEADER([minix/config.h], [MINIX=yes], [MINIX=])
+  if test "$MINIX" = yes; then
+    AC_DEFINE([_POSIX_SOURCE], [1],
+      [Define to 1 if you need to in order for `stat' and other
+       things to work.])
+    AC_DEFINE([_POSIX_1_SOURCE], [2],
+      [Define to 2 if the system does not provide POSIX.1 features
+       except with this defined.])
+    AC_DEFINE([_MINIX], [1],
+      [Define to 1 if on MINIX.])
+  fi
+
+  dnl HP-UX 11.11 defines mbstate_t only if _XOPEN_SOURCE is defined to 500,
+  dnl regardless of whether the flags -Ae or _D_HPUX_SOURCE=1 are already
+  dnl provided.
+  case "$host_os" in
+    hpux*)
+      AC_DEFINE([_XOPEN_SOURCE], [500],
+        [Define to 500 only on HP-UX.])
+      ;;
+  esac
+
+  AH_VERBATIM([__EXTENSIONS__],
+[/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# undef _ALL_SOURCE
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# undef _GNU_SOURCE
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# undef _POSIX_PTHREAD_SEMANTICS
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# undef _TANDEM_SOURCE
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# undef __EXTENSIONS__
+#endif
+])
+  AC_CACHE_CHECK([whether it is safe to define __EXTENSIONS__],
+    [ac_cv_safe_to_define___extensions__],
+    [AC_COMPILE_IFELSE(
+       [AC_LANG_PROGRAM([[
+#         define __EXTENSIONS__ 1
+          ]AC_INCLUDES_DEFAULT])],
+       [ac_cv_safe_to_define___extensions__=yes],
+       [ac_cv_safe_to_define___extensions__=no])])
+  test $ac_cv_safe_to_define___extensions__ = yes &&
+    AC_DEFINE([__EXTENSIONS__])
+  AC_DEFINE([_ALL_SOURCE])
+  AC_DEFINE([_GNU_SOURCE])
+  AC_DEFINE([_POSIX_PTHREAD_SEMANTICS])
+  AC_DEFINE([_TANDEM_SOURCE])
+])# AC_USE_SYSTEM_EXTENSIONS
+
+# gl_USE_SYSTEM_EXTENSIONS
+# ------------------------
+# Enable extensions on systems that normally disable them,
+# typically due to standards-conformance issues.
+AC_DEFUN_ONCE([gl_USE_SYSTEM_EXTENSIONS],
+[
+  dnl Require this macro before AC_USE_SYSTEM_EXTENSIONS.
+  dnl gnulib does not need it. But if it gets required by third-party macros
+  dnl after AC_USE_SYSTEM_EXTENSIONS is required, autoconf 2.62..2.63 emit a
+  dnl warning: "AC_COMPILE_IFELSE was called before AC_USE_SYSTEM_EXTENSIONS".
+  dnl Note: We can do this only for one of the macros AC_AIX, AC_GNU_SOURCE,
+  dnl AC_MINIX. If people still use AC_AIX or AC_MINIX, they are out of luck.
+  AC_REQUIRE([AC_GNU_SOURCE])
+
+  AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])
+])
--- a/lib/gl/m4/gnulib-cache.m4
+++ b/lib/gl/m4/gnulib-cache.m4
@@ -1,4 +1,4 @@
-# Copyright (C) 2002-2009 Free Software Foundation, Inc.
+# Copyright (C) 2002-2010 Free Software Foundation, Inc.
 #
 # This file is free software, distributed under the terms of the GNU
 # General Public License.  As a special exception to the GNU General
@@ -15,7 +15,7 @@
 
 
 # Specification in the form of a command-line invocation:
-#   gnulib-tool --import --dir=. --local-dir=lib/gl/override --lib=libgnu --source-base=lib/gl --m4-base=lib/gl/m4 --doc-base=doc --tests-base=lib/gltests --aux-dir=build-aux --with-tests --lgpl=2 --libtool --macro-prefix=lgl --no-vc-files gettext-h lib-msvc-compat lib-symbol-versions lib-symbol-visibility stdint striconv strverscmp
+#   gnulib-tool --import --dir=. --local-dir=lib/gl/override --lib=libgnu --source-base=lib/gl --m4-base=lib/gl/m4 --doc-base=doc --tests-base=lib/gltests --aux-dir=build-aux --with-tests --lgpl --libtool --macro-prefix=lgl --no-vc-files gettext-h lib-msvc-compat lib-symbol-versions lib-symbol-visibility stdint striconv strverscmp unistr/u8-check
 
 # Specification in the form of a few gnulib-tool.m4 macro invocations:
 gl_LOCAL_DIR([lib/gl/override])
@@ -27,6 +27,7 @@ gl_MODULES([
   stdint
   striconv
   strverscmp
+  unistr/u8-check
 ])
 gl_AVOID([])
 gl_SOURCE_BASE([lib/gl])
@@ -36,7 +37,7 @@ gl_DOC_BASE([doc])
 gl_TESTS_BASE([lib/gltests])
 gl_WITH_TESTS
 gl_LIB([libgnu])
-gl_LGPL([2])
+gl_LGPL
 gl_MAKEFILE_NAME([])
 gl_LIBTOOL
 gl_MACRO_PREFIX([lgl])
--- /dev/null
+++ b/lib/gl/m4/gnulib-common.m4
@@ -0,0 +1,201 @@
+# gnulib-common.m4 serial 20
+dnl Copyright (C) 2007-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# gl_COMMON
+# is expanded unconditionally through gnulib-tool magic.
+AC_DEFUN([gl_COMMON], [
+  dnl Use AC_REQUIRE here, so that the code is expanded once only.
+  AC_REQUIRE([gl_00GNULIB])
+  AC_REQUIRE([gl_COMMON_BODY])
+])
+AC_DEFUN([gl_COMMON_BODY], [
+  AH_VERBATIM([isoc99_inline],
+[/* Work around a bug in Apple GCC 4.0.1 build 5465: In C99 mode, it supports
+   the ISO C 99 semantics of 'extern inline' (unlike the GNU C semantics of
+   earlier versions), but does not display it by setting __GNUC_STDC_INLINE__.
+   __APPLE__ && __MACH__ test for MacOS X.
+   __APPLE_CC__ tests for the Apple compiler and its version.
+   __STDC_VERSION__ tests for the C99 mode.  */
+#if defined __APPLE__ && defined __MACH__ && __APPLE_CC__ >= 5465 && !defined __cplusplus && __STDC_VERSION__ >= 199901L && !defined __GNUC_STDC_INLINE__
+# define __GNUC_STDC_INLINE__ 1
+#endif])
+  AH_VERBATIM([unused_parameter],
+[/* Define as a marker that can be attached to declarations that might not
+    be used.  This helps to reduce warnings, such as from
+    GCC -Wunused-parameter.  */
+#if __GNUC__ >= 3 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)
+# define _GL_UNUSED __attribute__ ((__unused__))
+#else
+# define _GL_UNUSED
+#endif
+/* The name _UNUSED_PARAMETER_ is an earlier spelling, although the name
+   is a misnomer outside of parameter lists.  */
+#define _UNUSED_PARAMETER_ _GL_UNUSED
+])
+  dnl Preparation for running test programs:
+  dnl Tell glibc to write diagnostics from -D_FORTIFY_SOURCE=2 to stderr, not
+  dnl to /dev/tty, so they can be redirected to log files.  Such diagnostics
+  dnl arise e.g., in the macros gl_PRINTF_DIRECTIVE_N, gl_SNPRINTF_DIRECTIVE_N.
+  LIBC_FATAL_STDERR_=1
+  export LIBC_FATAL_STDERR_
+])
+
+# gl_MODULE_INDICATOR_CONDITION
+# expands to a C preprocessor expression that evaluates to 1 or 0, depending
+# whether a gnulib module that has been requested shall be considered present
+# or not.
+AC_DEFUN([gl_MODULE_INDICATOR_CONDITION], [1])
+
+# gl_MODULE_INDICATOR_SET_VARIABLE([modulename])
+# sets the shell variable that indicates the presence of the given module to
+# a C preprocessor expression that will evaluate to 1.
+AC_DEFUN([gl_MODULE_INDICATOR_SET_VARIABLE],
+[
+  GNULIB_[]m4_translit([[$1]],
+    [abcdefghijklmnopqrstuvwxyz./-],
+    [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=gl_MODULE_INDICATOR_CONDITION
+])
+
+# gl_MODULE_INDICATOR([modulename])
+# defines a C macro indicating the presence of the given module
+# in a location where it can be used.
+#                                             |  Value  |   Value   |
+#                                             | in lib/ | in tests/ |
+# --------------------------------------------+---------+-----------+
+# Module present among main modules:          |    1    |     1     |
+# --------------------------------------------+---------+-----------+
+# Module present among tests-related modules: |    0    |     1     |
+# --------------------------------------------+---------+-----------+
+# Module not present at all:                  |    0    |     0     |
+# --------------------------------------------+---------+-----------+
+AC_DEFUN([gl_MODULE_INDICATOR],
+[
+  AC_DEFINE_UNQUOTED([GNULIB_]m4_translit([[$1]],
+      [abcdefghijklmnopqrstuvwxyz./-],
+      [ABCDEFGHIJKLMNOPQRSTUVWXYZ___]),
+    [gl_MODULE_INDICATOR_CONDITION],
+    [Define to a C preprocessor expression that evaluates to 1 or 0,
+     depending whether the gnulib module $1 shall be considered present.])
+])
+
+# gl_MODULE_INDICATOR_FOR_TESTS([modulename])
+# defines a C macro indicating the presence of the given module
+# in lib or tests. This is useful to determine whether the module
+# should be tested.
+#                                             |  Value  |   Value   |
+#                                             | in lib/ | in tests/ |
+# --------------------------------------------+---------+-----------+
+# Module present among main modules:          |    1    |     1     |
+# --------------------------------------------+---------+-----------+
+# Module present among tests-related modules: |    1    |     1     |
+# --------------------------------------------+---------+-----------+
+# Module not present at all:                  |    0    |     0     |
+# --------------------------------------------+---------+-----------+
+AC_DEFUN([gl_MODULE_INDICATOR_FOR_TESTS],
+[
+  AC_DEFINE([GNULIB_TEST_]m4_translit([[$1]],
+      [abcdefghijklmnopqrstuvwxyz./-],
+      [ABCDEFGHIJKLMNOPQRSTUVWXYZ___]), [1],
+    [Define to 1 when the gnulib module $1 should be tested.])
+])
+
+# m4_foreach_w
+# is a backport of autoconf-2.59c's m4_foreach_w.
+# Remove this macro when we can assume autoconf >= 2.60.
+m4_ifndef([m4_foreach_w],
+  [m4_define([m4_foreach_w],
+    [m4_foreach([$1], m4_split(m4_normalize([$2]), [ ]), [$3])])])
+
+# AS_VAR_IF(VAR, VALUE, [IF-MATCH], [IF-NOT-MATCH])
+# ----------------------------------------------------
+# Backport of autoconf-2.63b's macro.
+# Remove this macro when we can assume autoconf >= 2.64.
+m4_ifndef([AS_VAR_IF],
+[m4_define([AS_VAR_IF],
+[AS_IF([test x"AS_VAR_GET([$1])" = x""$2], [$3], [$4])])])
+
+# AC_PROG_MKDIR_P
+# is a backport of autoconf-2.60's AC_PROG_MKDIR_P, with a fix
+# for interoperability with automake-1.9.6 from autoconf-2.62.
+# Remove this macro when we can assume autoconf >= 2.62 or
+# autoconf >= 2.60 && automake >= 1.10.
+m4_ifdef([AC_PROG_MKDIR_P], [
+  dnl For automake-1.9.6 && autoconf < 2.62: Ensure MKDIR_P is AC_SUBSTed.
+  m4_define([AC_PROG_MKDIR_P],
+    m4_defn([AC_PROG_MKDIR_P])[
+    AC_SUBST([MKDIR_P])])], [
+  dnl For autoconf < 2.60: Backport of AC_PROG_MKDIR_P.
+  AC_DEFUN_ONCE([AC_PROG_MKDIR_P],
+    [AC_REQUIRE([AM_PROG_MKDIR_P])dnl defined by automake
+     MKDIR_P='$(mkdir_p)'
+     AC_SUBST([MKDIR_P])])])
+
+# AC_C_RESTRICT
+# This definition overrides the AC_C_RESTRICT macro from autoconf 2.60..2.61,
+# so that mixed use of GNU C and GNU C++ and mixed use of Sun C and Sun C++
+# works.
+# This definition can be removed once autoconf >= 2.62 can be assumed.
+m4_if(m4_version_compare(m4_defn([m4_PACKAGE_VERSION]),[2.62]),[-1],[
+AC_DEFUN([AC_C_RESTRICT],
+[AC_CACHE_CHECK([for C/C++ restrict keyword], [ac_cv_c_restrict],
+  [ac_cv_c_restrict=no
+   # The order here caters to the fact that C++ does not require restrict.
+   for ac_kw in __restrict __restrict__ _Restrict restrict; do
+     AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+      [[typedef int * int_ptr;
+        int foo (int_ptr $ac_kw ip) {
+        return ip[0];
+       }]],
+      [[int s[1];
+        int * $ac_kw t = s;
+        t[0] = 0;
+        return foo(t)]])],
+      [ac_cv_c_restrict=$ac_kw])
+     test "$ac_cv_c_restrict" != no && break
+   done
+  ])
+ AH_VERBATIM([restrict],
+[/* Define to the equivalent of the C99 'restrict' keyword, or to
+   nothing if this is not supported.  Do not define if restrict is
+   supported directly.  */
+#undef restrict
+/* Work around a bug in Sun C++: it does not support _Restrict, even
+   though the corresponding Sun C compiler does, which causes
+   "#define restrict _Restrict" in the previous line.  Perhaps some future
+   version of Sun C++ will work with _Restrict; if so, it'll probably
+   define __RESTRICT, just as Sun C does.  */
+#if defined __SUNPRO_CC && !defined __RESTRICT
+# define _Restrict
+#endif])
+ case $ac_cv_c_restrict in
+   restrict) ;;
+   no) AC_DEFINE([restrict], []) ;;
+   *)  AC_DEFINE_UNQUOTED([restrict], [$ac_cv_c_restrict]) ;;
+ esac
+])
+])
+
+# gl_BIGENDIAN
+# is like AC_C_BIGENDIAN, except that it can be AC_REQUIREd.
+# Note that AC_REQUIRE([AC_C_BIGENDIAN]) does not work reliably because some
+# macros invoke AC_C_BIGENDIAN with arguments.
+AC_DEFUN([gl_BIGENDIAN],
+[
+  AC_C_BIGENDIAN
+])
+
+# gl_CACHE_VAL_SILENT(cache-id, command-to-set-it)
+# is like AC_CACHE_VAL(cache-id, command-to-set-it), except that it does not
+# output a spurious "(cached)" mark in the midst of other configure output.
+# This macro should be used instead of AC_CACHE_VAL when it is not surrounded
+# by an AC_MSG_CHECKING/AC_MSG_RESULT pair.
+AC_DEFUN([gl_CACHE_VAL_SILENT],
+[
+  saved_as_echo_n="$as_echo_n"
+  as_echo_n=':'
+  AC_CACHE_VAL([$1], [$2])
+  as_echo_n="$saved_as_echo_n"
+])
--- a/lib/gl/m4/gnulib-comp.m4
+++ b/lib/gl/m4/gnulib-comp.m4
@@ -1,5 +1,5 @@
 # DO NOT EDIT! GENERATED AUTOMATICALLY!
-# Copyright (C) 2002-2009 Free Software Foundation, Inc.
+# Copyright (C) 2002-2010 Free Software Foundation, Inc.
 #
 # This file is free software, distributed under the terms of the GNU
 # General Public License.  As a special exception to the GNU General
@@ -25,7 +25,52 @@ AC_DEFUN([lgl_EARLY],
   m4_pattern_allow([^gl_LIBOBJS$])dnl a variable
   m4_pattern_allow([^gl_LTLIBOBJS$])dnl a variable
   AC_REQUIRE([AC_PROG_RANLIB])
+  AC_REQUIRE([AM_PROG_CC_C_O])
+  # Code from module arg-nonnull:
+  # Code from module c++defs:
+  # Code from module c-ctype:
+  # Code from module c-ctype-tests:
+  # Code from module c-strcase:
+  # Code from module c-strcase-tests:
+  # Code from module extensions:
   AC_REQUIRE([gl_USE_SYSTEM_EXTENSIONS])
+  # Code from module gettext-h:
+  # Code from module gperf:
+  # Code from module havelib:
+  # Code from module iconv:
+  # Code from module iconv-h:
+  # Code from module iconv-h-tests:
+  # Code from module iconv-tests:
+  # Code from module iconv_open:
+  # Code from module include_next:
+  # Code from module inline:
+  # Code from module intprops:
+  # Code from module lib-msvc-compat:
+  # Code from module lib-symbol-versions:
+  # Code from module lib-symbol-visibility:
+  # Code from module multiarch:
+  # Code from module stdbool:
+  # Code from module stdbool-tests:
+  # Code from module stddef:
+  # Code from module stddef-tests:
+  # Code from module stdint:
+  # Code from module stdint-tests:
+  # Code from module striconv:
+  # Code from module striconv-tests:
+  # Code from module string:
+  # Code from module string-tests:
+  # Code from module strverscmp:
+  # Code from module strverscmp-tests:
+  # Code from module unistr/base:
+  # Code from module unistr/u8-check:
+  # Code from module unistr/u8-check-tests:
+  # Code from module unitypes:
+  # Code from module unused-parameter:
+  # Code from module verify:
+  # Code from module verify-tests:
+  # Code from module warn-on-use:
+  # Code from module wchar:
+  # Code from module wchar-tests:
 ])
 
 # This macro should be invoked from ./configure.ac, in the section
@@ -34,6 +79,7 @@ AC_DEFUN([lgl_INIT],
 [
   AM_CONDITIONAL([GL_COND_LIBTOOL], [true])
   gl_cond_libtool=true
+  gl_m4_base='lib/gl/m4'
   m4_pushdef([AC_LIBOBJ], m4_defn([lgl_LIBOBJ]))
   m4_pushdef([AC_REPLACE_FUNCS], m4_defn([lgl_REPLACE_FUNCS]))
   m4_pushdef([AC_LIBSOURCES], m4_defn([lgl_LIBSOURCES]))
@@ -41,25 +87,60 @@ AC_DEFUN([lgl_INIT],
   m4_pushdef([lgl_LIBSOURCES_DIR], [])
   gl_COMMON
   gl_source_base='lib/gl'
+  # Code from module arg-nonnull:
+  # Code from module c++defs:
+  # Code from module c-ctype:
+  # Code from module c-strcase:
+  # Code from module extensions:
+  # Code from module gettext-h:
   AC_SUBST([LIBINTL])
   AC_SUBST([LTLIBINTL])
+  # Code from module gperf:
+  # Code from module havelib:
+  # Code from module iconv:
   AM_ICONV
+  # Code from module iconv-h:
   gl_ICONV_H
+  # Code from module iconv_open:
   gl_FUNC_ICONV_OPEN
+  # Code from module include_next:
+  # Code from module inline:
+  gl_INLINE
+  # Code from module lib-msvc-compat:
   gl_LD_OUTPUT_DEF
+  # Code from module lib-symbol-versions:
   gl_LD_VERSION_SCRIPT
+  # Code from module lib-symbol-visibility:
   gl_VISIBILITY
+  # Code from module multiarch:
   gl_MULTIARCH
+  # Code from module stdbool:
   AM_STDBOOL_H
+  # Code from module stddef:
+  gl_STDDEF_H
+  # Code from module stdint:
   gl_STDINT_H
+  # Code from module striconv:
   if test $gl_cond_libtool = false; then
     gl_ltlibdeps="$gl_ltlibdeps $LTLIBICONV"
     gl_libdeps="$gl_libdeps $LIBICONV"
   fi
+  # Code from module string:
   gl_HEADER_STRING_H
+  # Code from module strverscmp:
   gl_FUNC_STRVERSCMP
   gl_STRING_MODULE_INDICATOR([strverscmp])
+  # Code from module unistr/base:
+  gl_LIBUNISTRING_LIBHEADER([0.9.2], [unistr.h])
+  # Code from module unistr/u8-check:
+  gl_LIBUNISTRING_MODULE([0.9], [unistr/u8-check])
+  # Code from module unitypes:
+  gl_LIBUNISTRING_LIBHEADER([0.9], [unitypes.h])
+  # Code from module unused-parameter:
+  # Code from module warn-on-use:
+  # Code from module wchar:
   gl_WCHAR_H
+  # End of code from modules
   m4_ifval(lgl_LIBSOURCES_LIST, [
     m4_syscmd([test ! -d ]m4_defn([lgl_LIBSOURCES_DIR])[ ||
       for gl_file in ]lgl_LIBSOURCES_LIST[ ; do
@@ -82,7 +163,7 @@ AC_DEFUN([lgl_INIT],
     if test -n "$lgl_LIBOBJS"; then
       # Remove the extension.
       sed_drop_objext='s/\.o$//;s/\.obj$//'
-      for i in `for i in $lgl_LIBOBJS; do echo "$i"; done | sed "$sed_drop_objext" | sort | uniq`; do
+      for i in `for i in $lgl_LIBOBJS; do echo "$i"; done | sed -e "$sed_drop_objext" | sort | uniq`; do
         lgl_libobjs="$lgl_libobjs $i.$ac_objext"
         lgl_ltlibobjs="$lgl_ltlibobjs $i.lo"
       done
@@ -99,10 +180,17 @@ AC_DEFUN([lgl_INIT],
   m4_pushdef([lgltests_LIBSOURCES_DIR], [])
   gl_COMMON
   gl_source_base='lib/gltests'
+changequote(,)dnl
+  lgltests_WITNESS=IN_`echo "${PACKAGE-$PACKAGE_TARNAME}" | LC_ALL=C tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ | LC_ALL=C sed -e 's/[^A-Z0-9_]/_/g'`_GNULIB_TESTS
+changequote([, ])dnl
+  AC_SUBST([lgltests_WITNESS])
+  gl_module_indicator_condition=$lgltests_WITNESS
+  m4_pushdef([gl_MODULE_INDICATOR_CONDITION], [$gl_module_indicator_condition])
   gt_LOCALE_FR
   gt_LOCALE_TR_UTF8
   gt_TYPE_WCHAR_T
   gt_TYPE_WINT_T
+  m4_popdef([gl_MODULE_INDICATOR_CONDITION])
   m4_ifval(lgltests_LIBSOURCES_LIST, [
     m4_syscmd([test ! -d ]m4_defn([lgltests_LIBSOURCES_DIR])[ ||
       for gl_file in ]lgltests_LIBSOURCES_LIST[ ; do
@@ -125,7 +213,7 @@ AC_DEFUN([lgl_INIT],
     if test -n "$lgltests_LIBOBJS"; then
       # Remove the extension.
       sed_drop_objext='s/\.o$//;s/\.obj$//'
-      for i in `for i in $lgltests_LIBOBJS; do echo "$i"; done | sed "$sed_drop_objext" | sort | uniq`; do
+      for i in `for i in $lgltests_LIBOBJS; do echo "$i"; done | sed -e "$sed_drop_objext" | sort | uniq`; do
         lgltests_libobjs="$lgltests_libobjs $i.$ac_objext"
         lgltests_ltlibobjs="$lgltests_ltlibobjs $i.lo"
       done
@@ -194,8 +282,11 @@ AC_DEFUN([lgltests_LIBSOURCES], [
 # This macro records the list of files which have been installed by
 # gnulib-tool and may be removed by future gnulib-tool invocations.
 AC_DEFUN([lgl_FILE_LIST], [
+  build-aux/arg-nonnull.h
+  build-aux/c++defs.h
   build-aux/config.rpath
-  build-aux/link-warning.h
+  build-aux/unused-parameter.h
+  build-aux/warn-on-use.h
   lib/c-ctype.c
   lib/c-ctype.h
   lib/c-strcase.h
@@ -207,13 +298,18 @@ AC_DEFUN([lgl_FILE_LIST], [
   lib/iconv_open-hpux.gperf
   lib/iconv_open-irix.gperf
   lib/iconv_open-osf.gperf
+  lib/iconv_open-solaris.gperf
   lib/iconv_open.c
   lib/stdbool.in.h
+  lib/stddef.in.h
   lib/stdint.in.h
   lib/striconv.c
   lib/striconv.h
   lib/string.in.h
   lib/strverscmp.c
+  lib/unistr.in.h
+  lib/unistr/u8-check.c
+  lib/unitypes.in.h
   lib/wchar.in.h
   m4/00gnulib.m4
   m4/codeset.m4
@@ -223,34 +319,46 @@ AC_DEFUN([lgl_FILE_LIST], [
   m4/iconv_h.m4
   m4/iconv_open.m4
   m4/include_next.m4
+  m4/inline.m4
   m4/ld-output-def.m4
   m4/ld-version-script.m4
   m4/lib-ld.m4
   m4/lib-link.m4
   m4/lib-prefix.m4
+  m4/libunistring-base.m4
   m4/locale-fr.m4
   m4/locale-tr.m4
   m4/longlong.m4
   m4/multiarch.m4
   m4/stdbool.m4
+  m4/stddef_h.m4
   m4/stdint.m4
   m4/string_h.m4
   m4/strverscmp.m4
   m4/visibility.m4
-  m4/wchar.m4
+  m4/warn-on-use.m4
+  m4/wchar_h.m4
   m4/wchar_t.m4
   m4/wint_t.m4
+  tests/init.sh
+  tests/macros.h
+  tests/signature.h
   tests/test-c-ctype.c
   tests/test-c-strcase.sh
   tests/test-c-strcasecmp.c
   tests/test-c-strncasecmp.c
+  tests/test-iconv-h.c
   tests/test-iconv.c
   tests/test-stdbool.c
+  tests/test-stddef.c
   tests/test-stdint.c
   tests/test-striconv.c
   tests/test-string.c
   tests/test-strverscmp.c
+  tests/test-verify.c
+  tests/test-verify.sh
   tests/test-wchar.c
+  tests/unistr/test-u8-check.c
   tests=lib/dummy.c
   tests=lib/intprops.h
   tests=lib/verify.h
--- /dev/null
+++ b/lib/gl/m4/gnulib-tool.m4
@@ -0,0 +1,57 @@
+# gnulib-tool.m4 serial 2
+dnl Copyright (C) 2004-2005, 2009-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl The following macros need not be invoked explicitly.
+dnl Invoking them does nothing except to declare default arguments
+dnl for "gnulib-tool --import".
+
+dnl Usage: gl_LOCAL_DIR([DIR])
+AC_DEFUN([gl_LOCAL_DIR], [])
+
+dnl Usage: gl_MODULES([module1 module2 ...])
+AC_DEFUN([gl_MODULES], [])
+
+dnl Usage: gl_AVOID([module1 module2 ...])
+AC_DEFUN([gl_AVOID], [])
+
+dnl Usage: gl_SOURCE_BASE([DIR])
+AC_DEFUN([gl_SOURCE_BASE], [])
+
+dnl Usage: gl_M4_BASE([DIR])
+AC_DEFUN([gl_M4_BASE], [])
+
+dnl Usage: gl_PO_BASE([DIR])
+AC_DEFUN([gl_PO_BASE], [])
+
+dnl Usage: gl_DOC_BASE([DIR])
+AC_DEFUN([gl_DOC_BASE], [])
+
+dnl Usage: gl_TESTS_BASE([DIR])
+AC_DEFUN([gl_TESTS_BASE], [])
+
+dnl Usage: gl_WITH_TESTS
+AC_DEFUN([gl_WITH_TESTS], [])
+
+dnl Usage: gl_LIB([LIBNAME])
+AC_DEFUN([gl_LIB], [])
+
+dnl Usage: gl_LGPL or gl_LGPL([VERSION])
+AC_DEFUN([gl_LGPL], [])
+
+dnl Usage: gl_MAKEFILE_NAME([FILENAME])
+AC_DEFUN([gl_MAKEFILE_NAME], [])
+
+dnl Usage: gl_LIBTOOL
+AC_DEFUN([gl_LIBTOOL], [])
+
+dnl Usage: gl_MACRO_PREFIX([PREFIX])
+AC_DEFUN([gl_MACRO_PREFIX], [])
+
+dnl Usage: gl_PO_DOMAIN([DOMAIN])
+AC_DEFUN([gl_PO_DOMAIN], [])
+
+dnl Usage: gl_VC_FILES([BOOLEAN])
+AC_DEFUN([gl_VC_FILES], [])
--- /dev/null
+++ b/lib/gl/m4/iconv.m4
@@ -0,0 +1,214 @@
+# iconv.m4 serial 11 (gettext-0.18.1)
+dnl Copyright (C) 2000-2002, 2007-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([AM_ICONV_LINKFLAGS_BODY],
+[
+  dnl Prerequisites of AC_LIB_LINKFLAGS_BODY.
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+
+  dnl Search for libiconv and define LIBICONV, LTLIBICONV and INCICONV
+  dnl accordingly.
+  AC_LIB_LINKFLAGS_BODY([iconv])
+])
+
+AC_DEFUN([AM_ICONV_LINK],
+[
+  dnl Some systems have iconv in libc, some have it in libiconv (OSF/1 and
+  dnl those with the standalone portable GNU libiconv installed).
+  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles
+
+  dnl Search for libiconv and define LIBICONV, LTLIBICONV and INCICONV
+  dnl accordingly.
+  AC_REQUIRE([AM_ICONV_LINKFLAGS_BODY])
+
+  dnl Add $INCICONV to CPPFLAGS before performing the following checks,
+  dnl because if the user has installed libiconv and not disabled its use
+  dnl via --without-libiconv-prefix, he wants to use it. The first
+  dnl AC_TRY_LINK will then fail, the second AC_TRY_LINK will succeed.
+  am_save_CPPFLAGS="$CPPFLAGS"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INCICONV])
+
+  AC_CACHE_CHECK([for iconv], [am_cv_func_iconv], [
+    am_cv_func_iconv="no, consider installing GNU libiconv"
+    am_cv_lib_iconv=no
+    AC_TRY_LINK([#include <stdlib.h>
+#include <iconv.h>],
+      [iconv_t cd = iconv_open("","");
+       iconv(cd,NULL,NULL,NULL,NULL);
+       iconv_close(cd);],
+      [am_cv_func_iconv=yes])
+    if test "$am_cv_func_iconv" != yes; then
+      am_save_LIBS="$LIBS"
+      LIBS="$LIBS $LIBICONV"
+      AC_TRY_LINK([#include <stdlib.h>
+#include <iconv.h>],
+        [iconv_t cd = iconv_open("","");
+         iconv(cd,NULL,NULL,NULL,NULL);
+         iconv_close(cd);],
+        [am_cv_lib_iconv=yes]
+        [am_cv_func_iconv=yes])
+      LIBS="$am_save_LIBS"
+    fi
+  ])
+  if test "$am_cv_func_iconv" = yes; then
+    AC_CACHE_CHECK([for working iconv], [am_cv_func_iconv_works], [
+      dnl This tests against bugs in AIX 5.1, HP-UX 11.11, Solaris 10.
+      am_save_LIBS="$LIBS"
+      if test $am_cv_lib_iconv = yes; then
+        LIBS="$LIBS $LIBICONV"
+      fi
+      AC_TRY_RUN([
+#include <iconv.h>
+#include <string.h>
+int main ()
+{
+  /* Test against AIX 5.1 bug: Failures are not distinguishable from successful
+     returns.  */
+  {
+    iconv_t cd_utf8_to_88591 = iconv_open ("ISO8859-1", "UTF-8");
+    if (cd_utf8_to_88591 != (iconv_t)(-1))
+      {
+        static const char input[] = "\342\202\254"; /* EURO SIGN */
+        char buf[10];
+        const char *inptr = input;
+        size_t inbytesleft = strlen (input);
+        char *outptr = buf;
+        size_t outbytesleft = sizeof (buf);
+        size_t res = iconv (cd_utf8_to_88591,
+                            (char **) &inptr, &inbytesleft,
+                            &outptr, &outbytesleft);
+        if (res == 0)
+          return 1;
+      }
+  }
+  /* Test against Solaris 10 bug: Failures are not distinguishable from
+     successful returns.  */
+  {
+    iconv_t cd_ascii_to_88591 = iconv_open ("ISO8859-1", "646");
+    if (cd_ascii_to_88591 != (iconv_t)(-1))
+      {
+        static const char input[] = "\263";
+        char buf[10];
+        const char *inptr = input;
+        size_t inbytesleft = strlen (input);
+        char *outptr = buf;
+        size_t outbytesleft = sizeof (buf);
+        size_t res = iconv (cd_ascii_to_88591,
+                            (char **) &inptr, &inbytesleft,
+                            &outptr, &outbytesleft);
+        if (res == 0)
+          return 1;
+      }
+  }
+#if 0 /* This bug could be worked around by the caller.  */
+  /* Test against HP-UX 11.11 bug: Positive return value instead of 0.  */
+  {
+    iconv_t cd_88591_to_utf8 = iconv_open ("utf8", "iso88591");
+    if (cd_88591_to_utf8 != (iconv_t)(-1))
+      {
+        static const char input[] = "\304rger mit b\366sen B\374bchen ohne Augenma\337";
+        char buf[50];
+        const char *inptr = input;
+        size_t inbytesleft = strlen (input);
+        char *outptr = buf;
+        size_t outbytesleft = sizeof (buf);
+        size_t res = iconv (cd_88591_to_utf8,
+                            (char **) &inptr, &inbytesleft,
+                            &outptr, &outbytesleft);
+        if ((int)res > 0)
+          return 1;
+      }
+  }
+#endif
+  /* Test against HP-UX 11.11 bug: No converter from EUC-JP to UTF-8 is
+     provided.  */
+  if (/* Try standardized names.  */
+      iconv_open ("UTF-8", "EUC-JP") == (iconv_t)(-1)
+      /* Try IRIX, OSF/1 names.  */
+      && iconv_open ("UTF-8", "eucJP") == (iconv_t)(-1)
+      /* Try AIX names.  */
+      && iconv_open ("UTF-8", "IBM-eucJP") == (iconv_t)(-1)
+      /* Try HP-UX names.  */
+      && iconv_open ("utf8", "eucJP") == (iconv_t)(-1))
+    return 1;
+  return 0;
+}], [am_cv_func_iconv_works=yes], [am_cv_func_iconv_works=no],
+        [case "$host_os" in
+           aix* | hpux*) am_cv_func_iconv_works="guessing no" ;;
+           *)            am_cv_func_iconv_works="guessing yes" ;;
+         esac])
+      LIBS="$am_save_LIBS"
+    ])
+    case "$am_cv_func_iconv_works" in
+      *no) am_func_iconv=no am_cv_lib_iconv=no ;;
+      *)   am_func_iconv=yes ;;
+    esac
+  else
+    am_func_iconv=no am_cv_lib_iconv=no
+  fi
+  if test "$am_func_iconv" = yes; then
+    AC_DEFINE([HAVE_ICONV], [1],
+      [Define if you have the iconv() function and it works.])
+  fi
+  if test "$am_cv_lib_iconv" = yes; then
+    AC_MSG_CHECKING([how to link with libiconv])
+    AC_MSG_RESULT([$LIBICONV])
+  else
+    dnl If $LIBICONV didn't lead to a usable library, we don't need $INCICONV
+    dnl either.
+    CPPFLAGS="$am_save_CPPFLAGS"
+    LIBICONV=
+    LTLIBICONV=
+  fi
+  AC_SUBST([LIBICONV])
+  AC_SUBST([LTLIBICONV])
+])
+
+dnl Define AM_ICONV using AC_DEFUN_ONCE for Autoconf >= 2.64, in order to
+dnl avoid warnings like
+dnl "warning: AC_REQUIRE: `AM_ICONV' was expanded before it was required".
+dnl This is tricky because of the way 'aclocal' is implemented:
+dnl - It requires defining an auxiliary macro whose name ends in AC_DEFUN.
+dnl   Otherwise aclocal's initial scan pass would miss the macro definition.
+dnl - It requires a line break inside the AC_DEFUN_ONCE and AC_DEFUN expansions.
+dnl   Otherwise aclocal would emit many "Use of uninitialized value $1"
+dnl   warnings.
+m4_define([gl_iconv_AC_DEFUN],
+  m4_version_prereq([2.64],
+    [[AC_DEFUN_ONCE(
+        [$1], [$2])]],
+    [[AC_DEFUN(
+        [$1], [$2])]]))
+gl_iconv_AC_DEFUN([AM_ICONV],
+[
+  AM_ICONV_LINK
+  if test "$am_cv_func_iconv" = yes; then
+    AC_MSG_CHECKING([for iconv declaration])
+    AC_CACHE_VAL([am_cv_proto_iconv], [
+      AC_TRY_COMPILE([
+#include <stdlib.h>
+#include <iconv.h>
+extern
+#ifdef __cplusplus
+"C"
+#endif
+#if defined(__STDC__) || defined(__cplusplus)
+size_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);
+#else
+size_t iconv();
+#endif
+], [], [am_cv_proto_iconv_arg1=""], [am_cv_proto_iconv_arg1="const"])
+      am_cv_proto_iconv="extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);"])
+    am_cv_proto_iconv=`echo "[$]am_cv_proto_iconv" | tr -s ' ' | sed -e 's/( /(/'`
+    AC_MSG_RESULT([
+         $am_cv_proto_iconv])
+    AC_DEFINE_UNQUOTED([ICONV_CONST], [$am_cv_proto_iconv_arg1],
+      [Define as const if the declaration of iconv() needs const.])
+  fi
+])
--- a/lib/gl/m4/iconv_h.m4
+++ b/lib/gl/m4/iconv_h.m4
@@ -1,5 +1,5 @@
-# iconv_h.m4 serial 4
-dnl Copyright (C) 2007-2008 Free Software Foundation, Inc.
+# iconv_h.m4 serial 6
+dnl Copyright (C) 2007-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
@@ -7,6 +7,9 @@ dnl with or without modifications, as lo
 AC_DEFUN([gl_ICONV_H],
 [
   AC_REQUIRE([gl_ICONV_H_DEFAULTS])
+
+  dnl Execute this unconditionally, because ICONV_H may be set by other
+  dnl modules, after this code is executed.
   gl_CHECK_NEXT_HEADERS([iconv.h])
 ])
 
@@ -21,7 +24,7 @@ AC_DEFUN([gl_ICONV_MODULE_INDICATOR],
 [
   dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
   AC_REQUIRE([gl_ICONV_H_DEFAULTS])
-  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
+  gl_MODULE_INDICATOR_SET_VARIABLE([$1])
 ])
 
 AC_DEFUN([gl_ICONV_H_DEFAULTS],
--- a/lib/gl/m4/iconv_open.m4
+++ b/lib/gl/m4/iconv_open.m4
@@ -1,5 +1,5 @@
-# iconv_open.m4 serial 5
-dnl Copyright (C) 2007-2009 Free Software Foundation, Inc.
+# iconv_open.m4 serial 7
+dnl Copyright (C) 2007-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
@@ -10,6 +10,8 @@ AC_DEFUN([gl_FUNC_ICONV_OPEN],
   AC_REQUIRE([AC_CANONICAL_HOST])
   AC_REQUIRE([gl_ICONV_H_DEFAULTS])
   if test "$am_cv_func_iconv" = yes; then
+    dnl Provide the <iconv.h> override, for the sake of the C++ aliases.
+    gl_REPLACE_ICONV_H
     dnl Test whether iconv_open accepts standardized encoding names.
     dnl We know that GNU libiconv and GNU libc do.
     AC_EGREP_CPP([gnu_iconv], [
@@ -21,10 +23,11 @@ AC_DEFUN([gl_FUNC_ICONV_OPEN],
     if test $gl_func_iconv_gnu = no; then
       iconv_flavor=
       case "$host_os" in
-        aix*)  iconv_flavor=ICONV_FLAVOR_AIX ;;
-        irix*) iconv_flavor=ICONV_FLAVOR_IRIX ;;
-        hpux*) iconv_flavor=ICONV_FLAVOR_HPUX ;;
-        osf*)  iconv_flavor=ICONV_FLAVOR_OSF ;;
+        aix*)     iconv_flavor=ICONV_FLAVOR_AIX ;;
+        irix*)    iconv_flavor=ICONV_FLAVOR_IRIX ;;
+        hpux*)    iconv_flavor=ICONV_FLAVOR_HPUX ;;
+        osf*)     iconv_flavor=ICONV_FLAVOR_OSF ;;
+        solaris*) iconv_flavor=ICONV_FLAVOR_SOLARIS ;;
       esac
       if test -n "$iconv_flavor"; then
         AC_DEFINE_UNQUOTED([ICONV_FLAVOR], [$iconv_flavor],
@@ -89,8 +92,8 @@ int main ()
     outptr = buf;
     outbytesleft = sizeof (buf);
     res = iconv (cd,
-		 (ICONV_CONST char **) &inptr, &inbytesleft,
-		 &outptr, &outbytesleft);
+                 (ICONV_CONST char **) &inptr, &inbytesleft,
+                 &outptr, &outbytesleft);
     ASSERT (res == 0 && inbytesleft == 0);
     ASSERT (outptr == buf + (sizeof (expected) - 1));
     ASSERT (memcmp (buf, expected, sizeof (expected) - 1) == 0);
@@ -116,8 +119,8 @@ int main ()
     outptr = buf;
     outbytesleft = sizeof (buf);
     res = iconv (cd,
-		 (ICONV_CONST char **) &inptr, &inbytesleft,
-		 &outptr, &outbytesleft);
+                 (ICONV_CONST char **) &inptr, &inbytesleft,
+                 &outptr, &outbytesleft);
     ASSERT (res == 0 && inbytesleft == 0);
     ASSERT (outptr == buf + (sizeof (expected) - 1));
     ASSERT (memcmp (buf, expected, sizeof (expected) - 1) == 0);
@@ -143,8 +146,8 @@ int main ()
     outptr = buf;
     outbytesleft = sizeof (buf);
     res = iconv (cd,
-		 (ICONV_CONST char **) &inptr, &inbytesleft,
-		 &outptr, &outbytesleft);
+                 (ICONV_CONST char **) &inptr, &inbytesleft,
+                 &outptr, &outbytesleft);
     ASSERT (res == 0 && inbytesleft == 0);
     ASSERT (outptr == buf + (sizeof (expected) - 1));
     ASSERT (memcmp (buf, expected, sizeof (expected) - 1) == 0);
@@ -170,8 +173,8 @@ int main ()
     outptr = buf;
     outbytesleft = sizeof (buf);
     res = iconv (cd,
-		 (ICONV_CONST char **) &inptr, &inbytesleft,
-		 &outptr, &outbytesleft);
+                 (ICONV_CONST char **) &inptr, &inbytesleft,
+                 &outptr, &outbytesleft);
     ASSERT (res == 0 && inbytesleft == 0);
     ASSERT (outptr == buf + (sizeof (expected) - 1));
     ASSERT (memcmp (buf, expected, sizeof (expected) - 1) == 0);
@@ -198,8 +201,8 @@ int main ()
     outptr = buf;
     outbytesleft = sizeof (buf);
     res = iconv (cd,
-		 (ICONV_CONST char **) &inptr, &inbytesleft,
-		 &outptr, &outbytesleft);
+                 (ICONV_CONST char **) &inptr, &inbytesleft,
+                 &outptr, &outbytesleft);
     ASSERT (res == 0 && inbytesleft == 0);
     ASSERT (outptr == buf + (sizeof (expected) - 1));
     ASSERT (memcmp (buf, expected, sizeof (expected) - 1) == 0);
--- /dev/null
+++ b/lib/gl/m4/include_next.m4
@@ -0,0 +1,187 @@
+# include_next.m4 serial 14
+dnl Copyright (C) 2006-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Paul Eggert and Derek Price.
+
+dnl Sets INCLUDE_NEXT and PRAGMA_SYSTEM_HEADER.
+dnl
+dnl INCLUDE_NEXT expands to 'include_next' if the compiler supports it, or to
+dnl 'include' otherwise.
+dnl
+dnl INCLUDE_NEXT_AS_FIRST_DIRECTIVE expands to 'include_next' if the compiler
+dnl supports it in the special case that it is the first include directive in
+dnl the given file, or to 'include' otherwise.
+dnl
+dnl PRAGMA_SYSTEM_HEADER can be used in files that contain #include_next,
+dnl so as to avoid GCC warnings when the gcc option -pedantic is used.
+dnl '#pragma GCC system_header' has the same effect as if the file was found
+dnl through the include search path specified with '-isystem' options (as
+dnl opposed to the search path specified with '-I' options). Namely, gcc
+dnl does not warn about some things, and on some systems (Solaris and Interix)
+dnl __STDC__ evaluates to 0 instead of to 1. The latter is an undesired side
+dnl effect; we are therefore careful to use 'defined __STDC__' or '1' instead
+dnl of plain '__STDC__'.
+
+AC_DEFUN([gl_INCLUDE_NEXT],
+[
+  AC_LANG_PREPROC_REQUIRE()
+  AC_CACHE_CHECK([whether the preprocessor supports include_next],
+    [gl_cv_have_include_next],
+    [rm -rf conftestd1a conftestd1b conftestd2
+     mkdir conftestd1a conftestd1b conftestd2
+     dnl IBM C 9.0, 10.1 (original versions, prior to the 2009-01 updates) on
+     dnl AIX 6.1 support include_next when used as first preprocessor directive
+     dnl in a file, but not when preceded by another include directive. Check
+     dnl for this bug by including <stdio.h>.
+     dnl Additionally, with this same compiler, include_next is a no-op when
+     dnl used in a header file that was included by specifying its absolute
+     dnl file name. Despite these two bugs, include_next is used in the
+     dnl compiler's <math.h>. By virtue of the second bug, we need to use
+     dnl include_next as well in this case.
+     cat <<EOF > conftestd1a/conftest.h
+#define DEFINED_IN_CONFTESTD1
+#include_next <conftest.h>
+#ifdef DEFINED_IN_CONFTESTD2
+int foo;
+#else
+#error "include_next doesn't work"
+#endif
+EOF
+     cat <<EOF > conftestd1b/conftest.h
+#define DEFINED_IN_CONFTESTD1
+#include <stdio.h>
+#include_next <conftest.h>
+#ifdef DEFINED_IN_CONFTESTD2
+int foo;
+#else
+#error "include_next doesn't work"
+#endif
+EOF
+     cat <<EOF > conftestd2/conftest.h
+#ifndef DEFINED_IN_CONFTESTD1
+#error "include_next test doesn't work"
+#endif
+#define DEFINED_IN_CONFTESTD2
+EOF
+     gl_save_CPPFLAGS="$CPPFLAGS"
+     CPPFLAGS="$gl_save_CPPFLAGS -Iconftestd1b -Iconftestd2"
+     AC_COMPILE_IFELSE([#include <conftest.h>],
+       [gl_cv_have_include_next=yes],
+       [CPPFLAGS="$gl_save_CPPFLAGS -Iconftestd1a -Iconftestd2"
+        AC_COMPILE_IFELSE([#include <conftest.h>],
+          [gl_cv_have_include_next=buggy],
+          [gl_cv_have_include_next=no])
+       ])
+     CPPFLAGS="$gl_save_CPPFLAGS"
+     rm -rf conftestd1a conftestd1b conftestd2
+    ])
+  PRAGMA_SYSTEM_HEADER=
+  if test $gl_cv_have_include_next = yes; then
+    INCLUDE_NEXT=include_next
+    INCLUDE_NEXT_AS_FIRST_DIRECTIVE=include_next
+    if test -n "$GCC"; then
+      PRAGMA_SYSTEM_HEADER='#pragma GCC system_header'
+    fi
+  else
+    if test $gl_cv_have_include_next = buggy; then
+      INCLUDE_NEXT=include
+      INCLUDE_NEXT_AS_FIRST_DIRECTIVE=include_next
+    else
+      INCLUDE_NEXT=include
+      INCLUDE_NEXT_AS_FIRST_DIRECTIVE=include
+    fi
+  fi
+  AC_SUBST([INCLUDE_NEXT])
+  AC_SUBST([INCLUDE_NEXT_AS_FIRST_DIRECTIVE])
+  AC_SUBST([PRAGMA_SYSTEM_HEADER])
+])
+
+# gl_CHECK_NEXT_HEADERS(HEADER1 HEADER2 ...)
+# ------------------------------------------
+# For each arg foo.h, if #include_next works, define NEXT_FOO_H to be
+# '<foo.h>'; otherwise define it to be
+# '"///usr/include/foo.h"', or whatever other absolute file name is suitable.
+# Also, if #include_next works as first preprocessing directive in a file,
+# define NEXT_AS_FIRST_DIRECTIVE_FOO_H to be '<foo.h>'; otherwise define it to
+# be
+# '"///usr/include/foo.h"', or whatever other absolute file name is suitable.
+# That way, a header file with the following line:
+#       #@INCLUDE_NEXT@ @NEXT_FOO_H@
+# or
+#       #@INCLUDE_NEXT_AS_FIRST_DIRECTIVE@ @NEXT_AS_FIRST_DIRECTIVE_FOO_H@
+# behaves (after sed substitution) as if it contained
+#       #include_next <foo.h>
+# even if the compiler does not support include_next.
+# The three "///" are to pacify Sun C 5.8, which otherwise would say
+# "warning: #include of /usr/include/... may be non-portable".
+# Use `""', not `<>', so that the /// cannot be confused with a C99 comment.
+# Note: This macro assumes that the header file is not empty after
+# preprocessing, i.e. it does not only define preprocessor macros but also
+# provides some type/enum definitions or function/variable declarations.
+AC_DEFUN([gl_CHECK_NEXT_HEADERS],
+[
+  AC_REQUIRE([gl_INCLUDE_NEXT])
+  AC_REQUIRE([AC_CANONICAL_HOST])
+  AC_CHECK_HEADERS_ONCE([$1])
+
+  m4_foreach_w([gl_HEADER_NAME], [$1],
+    [AS_VAR_PUSHDEF([gl_next_header],
+                    [gl_cv_next_]m4_defn([gl_HEADER_NAME]))
+     if test $gl_cv_have_include_next = yes; then
+       AS_VAR_SET([gl_next_header], ['<'gl_HEADER_NAME'>'])
+     else
+       AC_CACHE_CHECK(
+         [absolute name of <]m4_defn([gl_HEADER_NAME])[>],
+         m4_defn([gl_next_header]),
+         [AS_VAR_PUSHDEF([gl_header_exists],
+                         [ac_cv_header_]m4_defn([gl_HEADER_NAME]))
+          if test AS_VAR_GET(gl_header_exists) = yes; then
+            AC_LANG_CONFTEST(
+              [AC_LANG_SOURCE(
+                 [[#include <]]m4_dquote(m4_defn([gl_HEADER_NAME]))[[>]]
+               )])
+            dnl AIX "xlc -E" and "cc -E" omit #line directives for header files
+            dnl that contain only a #include of other header files and no
+            dnl non-comment tokens of their own. This leads to a failure to
+            dnl detect the absolute name of <dirent.h>, <signal.h>, <poll.h>
+            dnl and others. The workaround is to force preservation of comments
+            dnl through option -C. This ensures all necessary #line directives
+            dnl are present. GCC supports option -C as well.
+            case "$host_os" in
+              aix*) gl_absname_cpp="$ac_cpp -C" ;;
+              *)    gl_absname_cpp="$ac_cpp" ;;
+            esac
+            dnl eval is necessary to expand gl_absname_cpp.
+            dnl Ultrix and Pyramid sh refuse to redirect output of eval,
+            dnl so use subshell.
+            AS_VAR_SET([gl_next_header],
+              ['"'`(eval "$gl_absname_cpp conftest.$ac_ext") 2>&AS_MESSAGE_LOG_FD |
+               sed -n '\#/]m4_defn([gl_HEADER_NAME])[#{
+                 s#.*"\(.*/]m4_defn([gl_HEADER_NAME])[\)".*#\1#
+                 s#^/[^/]#//&#
+                 p
+                 q
+               }'`'"'])
+          else
+            AS_VAR_SET([gl_next_header], ['<'gl_HEADER_NAME'>'])
+          fi
+          AS_VAR_POPDEF([gl_header_exists])])
+     fi
+     AC_SUBST(
+       AS_TR_CPP([NEXT_]m4_defn([gl_HEADER_NAME])),
+       [AS_VAR_GET([gl_next_header])])
+     if test $gl_cv_have_include_next = yes || test $gl_cv_have_include_next = buggy; then
+       # INCLUDE_NEXT_AS_FIRST_DIRECTIVE='include_next'
+       gl_next_as_first_directive='<'gl_HEADER_NAME'>'
+     else
+       # INCLUDE_NEXT_AS_FIRST_DIRECTIVE='include'
+       gl_next_as_first_directive=AS_VAR_GET([gl_next_header])
+     fi
+     AC_SUBST(
+       AS_TR_CPP([NEXT_AS_FIRST_DIRECTIVE_]m4_defn([gl_HEADER_NAME])),
+       [$gl_next_as_first_directive])
+     AS_VAR_POPDEF([gl_next_header])])
+])
--- /dev/null
+++ b/lib/gl/m4/inline.m4
@@ -0,0 +1,40 @@
+# inline.m4 serial 4
+dnl Copyright (C) 2006, 2009, 2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Test for the 'inline' keyword or equivalent.
+dnl Define 'inline' to a supported equivalent, or to nothing if not supported,
+dnl like AC_C_INLINE does.  Also, define HAVE_INLINE if 'inline' or an
+dnl equivalent is effectively supported, i.e. if the compiler is likely to
+dnl drop unused 'static inline' functions.
+AC_DEFUN([gl_INLINE],
+[
+  AC_REQUIRE([AC_C_INLINE])
+  AC_CACHE_CHECK([whether the compiler generally respects inline],
+    [gl_cv_c_inline_effective],
+    [if test $ac_cv_c_inline = no; then
+       gl_cv_c_inline_effective=no
+     else
+       dnl GCC defines __NO_INLINE__ if not optimizing or if -fno-inline is
+       dnl specified.
+       dnl Use AC_COMPILE_IFELSE here, not AC_EGREP_CPP, because the result
+       dnl depends on optimization flags, which can be in CFLAGS.
+       dnl (AC_EGREP_CPP looks only at the CPPFLAGS.)
+       AC_COMPILE_IFELSE(
+         [AC_LANG_PROGRAM([[]],
+           [[#ifdef __NO_INLINE__
+               #error "inline is not effective"
+             #endif]])],
+         [gl_cv_c_inline_effective=yes],
+         [gl_cv_c_inline_effective=no])
+     fi
+    ])
+  if test $gl_cv_c_inline_effective = yes; then
+    AC_DEFINE([HAVE_INLINE], [1],
+      [Define to 1 if the compiler supports one of the keywords
+       'inline', '__inline__', '__inline' and effectively inlines
+       functions marked as such.])
+  fi
+])
--- a/lib/gl/m4/ld-output-def.m4
+++ b/lib/gl/m4/ld-output-def.m4
@@ -1,5 +1,5 @@
 # ld-output-def.m4 serial 2
-dnl Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+dnl Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
--- a/lib/gl/m4/ld-version-script.m4
+++ b/lib/gl/m4/ld-version-script.m4
@@ -1,5 +1,5 @@
 # ld-version-script.m4 serial 1
-dnl Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+dnl Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
@@ -27,7 +27,7 @@ AC_DEFUN([gl_LD_VERSION_SCRIPT],
     LDFLAGS="$LDFLAGS -Wl,--version-script=conftest.map"
     cat > conftest.map <<EOF
 VERS_1 {
-	global: sym;
+        global: sym;
 };
 
 VERS_2 {
--- /dev/null
+++ b/lib/gl/m4/lib-ld.m4
@@ -0,0 +1,110 @@
+# lib-ld.m4 serial 4 (gettext-0.18)
+dnl Copyright (C) 1996-2003, 2009-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Subroutines of libtool.m4,
+dnl with replacements s/AC_/AC_LIB/ and s/lt_cv/acl_cv/ to avoid collision
+dnl with libtool.m4.
+
+dnl From libtool-1.4. Sets the variable with_gnu_ld to yes or no.
+AC_DEFUN([AC_LIB_PROG_LD_GNU],
+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], [acl_cv_prog_gnu_ld],
+[# I'd rather use --version here, but apparently some GNU ld's only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  acl_cv_prog_gnu_ld=yes ;;
+*)
+  acl_cv_prog_gnu_ld=no ;;
+esac])
+with_gnu_ld=$acl_cv_prog_gnu_ld
+])
+
+dnl From libtool-1.4. Sets the variable LD.
+AC_DEFUN([AC_LIB_PROG_LD],
+[AC_ARG_WITH([gnu-ld],
+[  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]],
+test "$withval" = no || with_gnu_ld=yes, with_gnu_ld=no)
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+# Prepare PATH_SEPARATOR.
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  AC_MSG_CHECKING([for ld used by GCC])
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [[\\/]* | [A-Za-z]:[\\/]*)]
+      [re_direlt='/[^/][^/]*/\.\./']
+      # Canonicalize the path of ld
+      ac_prog=`echo $ac_prog| sed 's%\\\\%/%g'`
+      while echo $ac_prog | grep "$re_direlt" > /dev/null 2>&1; do
+        ac_prog=`echo $ac_prog| sed "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  AC_MSG_CHECKING([for GNU ld])
+else
+  AC_MSG_CHECKING([for non-GNU ld])
+fi
+AC_CACHE_VAL([acl_cv_path_LD],
+[if test -z "$LD"; then
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}${PATH_SEPARATOR-:}"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      acl_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some GNU ld's only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$acl_cv_path_LD" -v 2>&1 < /dev/null` in
+      *GNU* | *'with BFD'*)
+        test "$with_gnu_ld" != no && break ;;
+      *)
+        test "$with_gnu_ld" != yes && break ;;
+      esac
+    fi
+  done
+  IFS="$ac_save_ifs"
+else
+  acl_cv_path_LD="$LD" # Let the user override the test with a path.
+fi])
+LD="$acl_cv_path_LD"
+if test -n "$LD"; then
+  AC_MSG_RESULT([$LD])
+else
+  AC_MSG_RESULT([no])
+fi
+test -z "$LD" && AC_MSG_ERROR([no acceptable ld found in \$PATH])
+AC_LIB_PROG_LD_GNU
+])
--- /dev/null
+++ b/lib/gl/m4/lib-link.m4
@@ -0,0 +1,774 @@
+# lib-link.m4 serial 23 (gettext-0.18.2)
+dnl Copyright (C) 2001-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+AC_PREREQ([2.54])
+
+dnl AC_LIB_LINKFLAGS(name [, dependencies]) searches for libname and
+dnl the libraries corresponding to explicit and implicit dependencies.
+dnl Sets and AC_SUBSTs the LIB${NAME} and LTLIB${NAME} variables and
+dnl augments the CPPFLAGS variable.
+dnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname
+dnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.
+AC_DEFUN([AC_LIB_LINKFLAGS],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+  pushdef([Name],[m4_translit([$1],[./+-], [____])])
+  pushdef([NAME],[m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./+-],
+                                   [ABCDEFGHIJKLMNOPQRSTUVWXYZ____])])
+  AC_CACHE_CHECK([how to link with lib[]$1], [ac_cv_lib[]Name[]_libs], [
+    AC_LIB_LINKFLAGS_BODY([$1], [$2])
+    ac_cv_lib[]Name[]_libs="$LIB[]NAME"
+    ac_cv_lib[]Name[]_ltlibs="$LTLIB[]NAME"
+    ac_cv_lib[]Name[]_cppflags="$INC[]NAME"
+    ac_cv_lib[]Name[]_prefix="$LIB[]NAME[]_PREFIX"
+  ])
+  LIB[]NAME="$ac_cv_lib[]Name[]_libs"
+  LTLIB[]NAME="$ac_cv_lib[]Name[]_ltlibs"
+  INC[]NAME="$ac_cv_lib[]Name[]_cppflags"
+  LIB[]NAME[]_PREFIX="$ac_cv_lib[]Name[]_prefix"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)
+  AC_SUBST([LIB]NAME)
+  AC_SUBST([LTLIB]NAME)
+  AC_SUBST([LIB]NAME[_PREFIX])
+  dnl Also set HAVE_LIB[]NAME so that AC_LIB_HAVE_LINKFLAGS can reuse the
+  dnl results of this search when this library appears as a dependency.
+  HAVE_LIB[]NAME=yes
+  popdef([NAME])
+  popdef([Name])
+])
+
+dnl AC_LIB_HAVE_LINKFLAGS(name, dependencies, includes, testcode, [missing-message])
+dnl searches for libname and the libraries corresponding to explicit and
+dnl implicit dependencies, together with the specified include files and
+dnl the ability to compile and link the specified testcode. The missing-message
+dnl defaults to 'no' and may contain additional hints for the user.
+dnl If found, it sets and AC_SUBSTs HAVE_LIB${NAME}=yes and the LIB${NAME}
+dnl and LTLIB${NAME} variables and augments the CPPFLAGS variable, and
+dnl #defines HAVE_LIB${NAME} to 1. Otherwise, it sets and AC_SUBSTs
+dnl HAVE_LIB${NAME}=no and LIB${NAME} and LTLIB${NAME} to empty.
+dnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname
+dnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.
+AC_DEFUN([AC_LIB_HAVE_LINKFLAGS],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+  pushdef([Name],[m4_translit([$1],[./+-], [____])])
+  pushdef([NAME],[m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./+-],
+                                   [ABCDEFGHIJKLMNOPQRSTUVWXYZ____])])
+
+  dnl Search for lib[]Name and define LIB[]NAME, LTLIB[]NAME and INC[]NAME
+  dnl accordingly.
+  AC_LIB_LINKFLAGS_BODY([$1], [$2])
+
+  dnl Add $INC[]NAME to CPPFLAGS before performing the following checks,
+  dnl because if the user has installed lib[]Name and not disabled its use
+  dnl via --without-lib[]Name-prefix, he wants to use it.
+  ac_save_CPPFLAGS="$CPPFLAGS"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)
+
+  AC_CACHE_CHECK([for lib[]$1], [ac_cv_lib[]Name], [
+    ac_save_LIBS="$LIBS"
+    dnl If $LIB[]NAME contains some -l options, add it to the end of LIBS,
+    dnl because these -l options might require -L options that are present in
+    dnl LIBS. -l options benefit only from the -L options listed before it.
+    dnl Otherwise, add it to the front of LIBS, because it may be a static
+    dnl library that depends on another static library that is present in LIBS.
+    dnl Static libraries benefit only from the static libraries listed after
+    dnl it.
+    case " $LIB[]NAME" in
+      *" -l"*) LIBS="$LIBS $LIB[]NAME" ;;
+      *)       LIBS="$LIB[]NAME $LIBS" ;;
+    esac
+    AC_TRY_LINK([$3], [$4],
+      [ac_cv_lib[]Name=yes],
+      [ac_cv_lib[]Name='m4_if([$5], [], [no], [[$5]])'])
+    LIBS="$ac_save_LIBS"
+  ])
+  if test "$ac_cv_lib[]Name" = yes; then
+    HAVE_LIB[]NAME=yes
+    AC_DEFINE([HAVE_LIB]NAME, 1, [Define if you have the lib][$1 library.])
+    AC_MSG_CHECKING([how to link with lib[]$1])
+    AC_MSG_RESULT([$LIB[]NAME])
+  else
+    HAVE_LIB[]NAME=no
+    dnl If $LIB[]NAME didn't lead to a usable library, we don't need
+    dnl $INC[]NAME either.
+    CPPFLAGS="$ac_save_CPPFLAGS"
+    LIB[]NAME=
+    LTLIB[]NAME=
+    LIB[]NAME[]_PREFIX=
+  fi
+  AC_SUBST([HAVE_LIB]NAME)
+  AC_SUBST([LIB]NAME)
+  AC_SUBST([LTLIB]NAME)
+  AC_SUBST([LIB]NAME[_PREFIX])
+  popdef([NAME])
+  popdef([Name])
+])
+
+dnl Determine the platform dependent parameters needed to use rpath:
+dnl   acl_libext,
+dnl   acl_shlibext,
+dnl   acl_hardcode_libdir_flag_spec,
+dnl   acl_hardcode_libdir_separator,
+dnl   acl_hardcode_direct,
+dnl   acl_hardcode_minus_L.
+AC_DEFUN([AC_LIB_RPATH],
+[
+  dnl Tell automake >= 1.10 to complain if config.rpath is missing.
+  m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([config.rpath])])
+  AC_REQUIRE([AC_PROG_CC])                dnl we use $CC, $GCC, $LDFLAGS
+  AC_REQUIRE([AC_LIB_PROG_LD])            dnl we use $LD, $with_gnu_ld
+  AC_REQUIRE([AC_CANONICAL_HOST])         dnl we use $host
+  AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT]) dnl we use $ac_aux_dir
+  AC_CACHE_CHECK([for shared library run path origin], [acl_cv_rpath], [
+    CC="$CC" GCC="$GCC" LDFLAGS="$LDFLAGS" LD="$LD" with_gnu_ld="$with_gnu_ld" \
+    ${CONFIG_SHELL-/bin/sh} "$ac_aux_dir/config.rpath" "$host" > conftest.sh
+    . ./conftest.sh
+    rm -f ./conftest.sh
+    acl_cv_rpath=done
+  ])
+  wl="$acl_cv_wl"
+  acl_libext="$acl_cv_libext"
+  acl_shlibext="$acl_cv_shlibext"
+  acl_libname_spec="$acl_cv_libname_spec"
+  acl_library_names_spec="$acl_cv_library_names_spec"
+  acl_hardcode_libdir_flag_spec="$acl_cv_hardcode_libdir_flag_spec"
+  acl_hardcode_libdir_separator="$acl_cv_hardcode_libdir_separator"
+  acl_hardcode_direct="$acl_cv_hardcode_direct"
+  acl_hardcode_minus_L="$acl_cv_hardcode_minus_L"
+  dnl Determine whether the user wants rpath handling at all.
+  AC_ARG_ENABLE([rpath],
+    [  --disable-rpath         do not hardcode runtime library paths],
+    :, enable_rpath=yes)
+])
+
+dnl AC_LIB_FROMPACKAGE(name, package)
+dnl declares that libname comes from the given package. The configure file
+dnl will then not have a --with-libname-prefix option but a
+dnl --with-package-prefix option. Several libraries can come from the same
+dnl package. This declaration must occur before an AC_LIB_LINKFLAGS or similar
+dnl macro call that searches for libname.
+AC_DEFUN([AC_LIB_FROMPACKAGE],
+[
+  pushdef([NAME],[m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./+-],
+                                   [ABCDEFGHIJKLMNOPQRSTUVWXYZ____])])
+  define([acl_frompackage_]NAME, [$2])
+  popdef([NAME])
+  pushdef([PACK],[$2])
+  pushdef([PACKUP],[m4_translit(PACK,[abcdefghijklmnopqrstuvwxyz./+-],
+                                     [ABCDEFGHIJKLMNOPQRSTUVWXYZ____])])
+  define([acl_libsinpackage_]PACKUP,
+    m4_ifdef([acl_libsinpackage_]PACKUP, [acl_libsinpackage_]PACKUP[[, ]],)[lib$1])
+  popdef([PACKUP])
+  popdef([PACK])
+])
+
+dnl AC_LIB_LINKFLAGS_BODY(name [, dependencies]) searches for libname and
+dnl the libraries corresponding to explicit and implicit dependencies.
+dnl Sets the LIB${NAME}, LTLIB${NAME} and INC${NAME} variables.
+dnl Also, sets the LIB${NAME}_PREFIX variable to nonempty if libname was found
+dnl in ${LIB${NAME}_PREFIX}/$acl_libdirstem.
+AC_DEFUN([AC_LIB_LINKFLAGS_BODY],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])
+  pushdef([NAME],[m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./+-],
+                                   [ABCDEFGHIJKLMNOPQRSTUVWXYZ____])])
+  pushdef([PACK],[m4_ifdef([acl_frompackage_]NAME, [acl_frompackage_]NAME, lib[$1])])
+  pushdef([PACKUP],[m4_translit(PACK,[abcdefghijklmnopqrstuvwxyz./+-],
+                                     [ABCDEFGHIJKLMNOPQRSTUVWXYZ____])])
+  pushdef([PACKLIBS],[m4_ifdef([acl_frompackage_]NAME, [acl_libsinpackage_]PACKUP, lib[$1])])
+  dnl Autoconf >= 2.61 supports dots in --with options.
+  pushdef([P_A_C_K],[m4_if(m4_version_compare(m4_defn([m4_PACKAGE_VERSION]),[2.61]),[-1],[m4_translit(PACK,[.],[_])],PACK)])
+  dnl By default, look in $includedir and $libdir.
+  use_additional=yes
+  AC_LIB_WITH_FINAL_PREFIX([
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+  ])
+  AC_ARG_WITH(P_A_C_K[-prefix],
+[[  --with-]]P_A_C_K[[-prefix[=DIR]  search for ]PACKLIBS[ in DIR/include and DIR/lib
+  --without-]]P_A_C_K[[-prefix     don't search for ]PACKLIBS[ in includedir and libdir]],
+[
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+        AC_LIB_WITH_FINAL_PREFIX([
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+        ])
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/$acl_libdirstem"
+        if test "$acl_libdirstem2" != "$acl_libdirstem" \
+           && ! test -d "$withval/$acl_libdirstem"; then
+          additional_libdir="$withval/$acl_libdirstem2"
+        fi
+      fi
+    fi
+])
+  dnl Search the library and its dependencies in $additional_libdir and
+  dnl $LDFLAGS. Using breadth-first-seach.
+  LIB[]NAME=
+  LTLIB[]NAME=
+  INC[]NAME=
+  LIB[]NAME[]_PREFIX=
+  dnl HAVE_LIB${NAME} is an indicator that LIB${NAME}, LTLIB${NAME} have been
+  dnl computed. So it has to be reset here.
+  HAVE_LIB[]NAME=
+  rpathdirs=
+  ltrpathdirs=
+  names_already_handled=
+  names_next_round='$1 $2'
+  while test -n "$names_next_round"; do
+    names_this_round="$names_next_round"
+    names_next_round=
+    for name in $names_this_round; do
+      already_handled=
+      for n in $names_already_handled; do
+        if test "$n" = "$name"; then
+          already_handled=yes
+          break
+        fi
+      done
+      if test -z "$already_handled"; then
+        names_already_handled="$names_already_handled $name"
+        dnl See if it was already located by an earlier AC_LIB_LINKFLAGS
+        dnl or AC_LIB_HAVE_LINKFLAGS call.
+        uppername=`echo "$name" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./+-|ABCDEFGHIJKLMNOPQRSTUVWXYZ____|'`
+        eval value=\"\$HAVE_LIB$uppername\"
+        if test -n "$value"; then
+          if test "$value" = yes; then
+            eval value=\"\$LIB$uppername\"
+            test -z "$value" || LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$value"
+            eval value=\"\$LTLIB$uppername\"
+            test -z "$value" || LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }$value"
+          else
+            dnl An earlier call to AC_LIB_HAVE_LINKFLAGS has determined
+            dnl that this library doesn't exist. So just drop it.
+            :
+          fi
+        else
+          dnl Search the library lib$name in $additional_libdir and $LDFLAGS
+          dnl and the already constructed $LIBNAME/$LTLIBNAME.
+          found_dir=
+          found_la=
+          found_so=
+          found_a=
+          eval libname=\"$acl_libname_spec\"    # typically: libname=lib$name
+          if test -n "$acl_shlibext"; then
+            shrext=".$acl_shlibext"             # typically: shrext=.so
+          else
+            shrext=
+          fi
+          if test $use_additional = yes; then
+            dir="$additional_libdir"
+            dnl The same code as in the loop below:
+            dnl First look for a shared library.
+            if test -n "$acl_shlibext"; then
+              if test -f "$dir/$libname$shrext"; then
+                found_dir="$dir"
+                found_so="$dir/$libname$shrext"
+              else
+                if test "$acl_library_names_spec" = '$libname$shrext$versuffix'; then
+                  ver=`(cd "$dir" && \
+                        for f in "$libname$shrext".*; do echo "$f"; done \
+                        | sed -e "s,^$libname$shrext\\\\.,," \
+                        | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \
+                        | sed 1q ) 2>/dev/null`
+                  if test -n "$ver" && test -f "$dir/$libname$shrext.$ver"; then
+                    found_dir="$dir"
+                    found_so="$dir/$libname$shrext.$ver"
+                  fi
+                else
+                  eval library_names=\"$acl_library_names_spec\"
+                  for f in $library_names; do
+                    if test -f "$dir/$f"; then
+                      found_dir="$dir"
+                      found_so="$dir/$f"
+                      break
+                    fi
+                  done
+                fi
+              fi
+            fi
+            dnl Then look for a static library.
+            if test "X$found_dir" = "X"; then
+              if test -f "$dir/$libname.$acl_libext"; then
+                found_dir="$dir"
+                found_a="$dir/$libname.$acl_libext"
+              fi
+            fi
+            if test "X$found_dir" != "X"; then
+              if test -f "$dir/$libname.la"; then
+                found_la="$dir/$libname.la"
+              fi
+            fi
+          fi
+          if test "X$found_dir" = "X"; then
+            for x in $LDFLAGS $LTLIB[]NAME; do
+              AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+              case "$x" in
+                -L*)
+                  dir=`echo "X$x" | sed -e 's/^X-L//'`
+                  dnl First look for a shared library.
+                  if test -n "$acl_shlibext"; then
+                    if test -f "$dir/$libname$shrext"; then
+                      found_dir="$dir"
+                      found_so="$dir/$libname$shrext"
+                    else
+                      if test "$acl_library_names_spec" = '$libname$shrext$versuffix'; then
+                        ver=`(cd "$dir" && \
+                              for f in "$libname$shrext".*; do echo "$f"; done \
+                              | sed -e "s,^$libname$shrext\\\\.,," \
+                              | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \
+                              | sed 1q ) 2>/dev/null`
+                        if test -n "$ver" && test -f "$dir/$libname$shrext.$ver"; then
+                          found_dir="$dir"
+                          found_so="$dir/$libname$shrext.$ver"
+                        fi
+                      else
+                        eval library_names=\"$acl_library_names_spec\"
+                        for f in $library_names; do
+                          if test -f "$dir/$f"; then
+                            found_dir="$dir"
+                            found_so="$dir/$f"
+                            break
+                          fi
+                        done
+                      fi
+                    fi
+                  fi
+                  dnl Then look for a static library.
+                  if test "X$found_dir" = "X"; then
+                    if test -f "$dir/$libname.$acl_libext"; then
+                      found_dir="$dir"
+                      found_a="$dir/$libname.$acl_libext"
+                    fi
+                  fi
+                  if test "X$found_dir" != "X"; then
+                    if test -f "$dir/$libname.la"; then
+                      found_la="$dir/$libname.la"
+                    fi
+                  fi
+                  ;;
+              esac
+              if test "X$found_dir" != "X"; then
+                break
+              fi
+            done
+          fi
+          if test "X$found_dir" != "X"; then
+            dnl Found the library.
+            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$found_dir -l$name"
+            if test "X$found_so" != "X"; then
+              dnl Linking with a shared library. We attempt to hardcode its
+              dnl directory into the executable's runpath, unless it's the
+              dnl standard /usr/lib.
+              if test "$enable_rpath" = no \
+                 || test "X$found_dir" = "X/usr/$acl_libdirstem" \
+                 || test "X$found_dir" = "X/usr/$acl_libdirstem2"; then
+                dnl No hardcoding is needed.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+              else
+                dnl Use an explicit option to hardcode DIR into the resulting
+                dnl binary.
+                dnl Potentially add DIR to ltrpathdirs.
+                dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.
+                haveit=
+                for x in $ltrpathdirs; do
+                  if test "X$x" = "X$found_dir"; then
+                    haveit=yes
+                    break
+                  fi
+                done
+                if test -z "$haveit"; then
+                  ltrpathdirs="$ltrpathdirs $found_dir"
+                fi
+                dnl The hardcoding into $LIBNAME is system dependent.
+                if test "$acl_hardcode_direct" = yes; then
+                  dnl Using DIR/libNAME.so during linking hardcodes DIR into the
+                  dnl resulting binary.
+                  LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                else
+                  if test -n "$acl_hardcode_libdir_flag_spec" && test "$acl_hardcode_minus_L" = no; then
+                    dnl Use an explicit option to hardcode DIR into the resulting
+                    dnl binary.
+                    LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                    dnl Potentially add DIR to rpathdirs.
+                    dnl The rpathdirs will be appended to $LIBNAME at the end.
+                    haveit=
+                    for x in $rpathdirs; do
+                      if test "X$x" = "X$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      rpathdirs="$rpathdirs $found_dir"
+                    fi
+                  else
+                    dnl Rely on "-L$found_dir".
+                    dnl But don't add it if it's already contained in the LDFLAGS
+                    dnl or the already constructed $LIBNAME
+                    haveit=
+                    for x in $LDFLAGS $LIB[]NAME; do
+                      AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                      if test "X$x" = "X-L$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir"
+                    fi
+                    if test "$acl_hardcode_minus_L" != no; then
+                      dnl FIXME: Not sure whether we should use
+                      dnl "-L$found_dir -l$name" or "-L$found_dir $found_so"
+                      dnl here.
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                    else
+                      dnl We cannot use $acl_hardcode_runpath_var and LD_RUN_PATH
+                      dnl here, because this doesn't fit in flags passed to the
+                      dnl compiler. So give up. No hardcoding. This affects only
+                      dnl very old systems.
+                      dnl FIXME: Not sure whether we should use
+                      dnl "-L$found_dir -l$name" or "-L$found_dir $found_so"
+                      dnl here.
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-l$name"
+                    fi
+                  fi
+                fi
+              fi
+            else
+              if test "X$found_a" != "X"; then
+                dnl Linking with a static library.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_a"
+              else
+                dnl We shouldn't come here, but anyway it's good to have a
+                dnl fallback.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir -l$name"
+              fi
+            fi
+            dnl Assume the include files are nearby.
+            additional_includedir=
+            case "$found_dir" in
+              */$acl_libdirstem | */$acl_libdirstem/)
+                basedir=`echo "X$found_dir" | sed -e 's,^X,,' -e "s,/$acl_libdirstem/"'*$,,'`
+                if test "$name" = '$1'; then
+                  LIB[]NAME[]_PREFIX="$basedir"
+                fi
+                additional_includedir="$basedir/include"
+                ;;
+              */$acl_libdirstem2 | */$acl_libdirstem2/)
+                basedir=`echo "X$found_dir" | sed -e 's,^X,,' -e "s,/$acl_libdirstem2/"'*$,,'`
+                if test "$name" = '$1'; then
+                  LIB[]NAME[]_PREFIX="$basedir"
+                fi
+                additional_includedir="$basedir/include"
+                ;;
+            esac
+            if test "X$additional_includedir" != "X"; then
+              dnl Potentially add $additional_includedir to $INCNAME.
+              dnl But don't add it
+              dnl   1. if it's the standard /usr/include,
+              dnl   2. if it's /usr/local/include and we are using GCC on Linux,
+              dnl   3. if it's already present in $CPPFLAGS or the already
+              dnl      constructed $INCNAME,
+              dnl   4. if it doesn't exist as a directory.
+              if test "X$additional_includedir" != "X/usr/include"; then
+                haveit=
+                if test "X$additional_includedir" = "X/usr/local/include"; then
+                  if test -n "$GCC"; then
+                    case $host_os in
+                      linux* | gnu* | k*bsd*-gnu) haveit=yes;;
+                    esac
+                  fi
+                fi
+                if test -z "$haveit"; then
+                  for x in $CPPFLAGS $INC[]NAME; do
+                    AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                    if test "X$x" = "X-I$additional_includedir"; then
+                      haveit=yes
+                      break
+                    fi
+                  done
+                  if test -z "$haveit"; then
+                    if test -d "$additional_includedir"; then
+                      dnl Really add $additional_includedir to $INCNAME.
+                      INC[]NAME="${INC[]NAME}${INC[]NAME:+ }-I$additional_includedir"
+                    fi
+                  fi
+                fi
+              fi
+            fi
+            dnl Look for dependencies.
+            if test -n "$found_la"; then
+              dnl Read the .la file. It defines the variables
+              dnl dlname, library_names, old_library, dependency_libs, current,
+              dnl age, revision, installed, dlopen, dlpreopen, libdir.
+              save_libdir="$libdir"
+              case "$found_la" in
+                */* | *\\*) . "$found_la" ;;
+                *) . "./$found_la" ;;
+              esac
+              libdir="$save_libdir"
+              dnl We use only dependency_libs.
+              for dep in $dependency_libs; do
+                case "$dep" in
+                  -L*)
+                    additional_libdir=`echo "X$dep" | sed -e 's/^X-L//'`
+                    dnl Potentially add $additional_libdir to $LIBNAME and $LTLIBNAME.
+                    dnl But don't add it
+                    dnl   1. if it's the standard /usr/lib,
+                    dnl   2. if it's /usr/local/lib and we are using GCC on Linux,
+                    dnl   3. if it's already present in $LDFLAGS or the already
+                    dnl      constructed $LIBNAME,
+                    dnl   4. if it doesn't exist as a directory.
+                    if test "X$additional_libdir" != "X/usr/$acl_libdirstem" \
+                       && test "X$additional_libdir" != "X/usr/$acl_libdirstem2"; then
+                      haveit=
+                      if test "X$additional_libdir" = "X/usr/local/$acl_libdirstem" \
+                         || test "X$additional_libdir" = "X/usr/local/$acl_libdirstem2"; then
+                        if test -n "$GCC"; then
+                          case $host_os in
+                            linux* | gnu* | k*bsd*-gnu) haveit=yes;;
+                          esac
+                        fi
+                      fi
+                      if test -z "$haveit"; then
+                        haveit=
+                        for x in $LDFLAGS $LIB[]NAME; do
+                          AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                            dnl Really add $additional_libdir to $LIBNAME.
+                            LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$additional_libdir"
+                          fi
+                        fi
+                        haveit=
+                        for x in $LDFLAGS $LTLIB[]NAME; do
+                          AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                            dnl Really add $additional_libdir to $LTLIBNAME.
+                            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$additional_libdir"
+                          fi
+                        fi
+                      fi
+                    fi
+                    ;;
+                  -R*)
+                    dir=`echo "X$dep" | sed -e 's/^X-R//'`
+                    if test "$enable_rpath" != no; then
+                      dnl Potentially add DIR to rpathdirs.
+                      dnl The rpathdirs will be appended to $LIBNAME at the end.
+                      haveit=
+                      for x in $rpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        rpathdirs="$rpathdirs $dir"
+                      fi
+                      dnl Potentially add DIR to ltrpathdirs.
+                      dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.
+                      haveit=
+                      for x in $ltrpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        ltrpathdirs="$ltrpathdirs $dir"
+                      fi
+                    fi
+                    ;;
+                  -l*)
+                    dnl Handle this in the next round.
+                    names_next_round="$names_next_round "`echo "X$dep" | sed -e 's/^X-l//'`
+                    ;;
+                  *.la)
+                    dnl Handle this in the next round. Throw away the .la's
+                    dnl directory; it is already contained in a preceding -L
+                    dnl option.
+                    names_next_round="$names_next_round "`echo "X$dep" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\.la$,,'`
+                    ;;
+                  *)
+                    dnl Most likely an immediate library name.
+                    LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$dep"
+                    LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }$dep"
+                    ;;
+                esac
+              done
+            fi
+          else
+            dnl Didn't find the library; assume it is in the system directories
+            dnl known to the linker and runtime loader. (All the system
+            dnl directories known to the linker should also be known to the
+            dnl runtime loader, otherwise the system is severely misconfigured.)
+            LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-l$name"
+            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-l$name"
+          fi
+        fi
+      fi
+    done
+  done
+  if test "X$rpathdirs" != "X"; then
+    if test -n "$acl_hardcode_libdir_separator"; then
+      dnl Weird platform: only the last -rpath option counts, the user must
+      dnl pass all path elements in one option. We can arrange that for a
+      dnl single library, but not when more than one $LIBNAMEs are used.
+      alldirs=
+      for found_dir in $rpathdirs; do
+        alldirs="${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$found_dir"
+      done
+      dnl Note: acl_hardcode_libdir_flag_spec uses $libdir and $wl.
+      acl_save_libdir="$libdir"
+      libdir="$alldirs"
+      eval flag=\"$acl_hardcode_libdir_flag_spec\"
+      libdir="$acl_save_libdir"
+      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$flag"
+    else
+      dnl The -rpath options are cumulative.
+      for found_dir in $rpathdirs; do
+        acl_save_libdir="$libdir"
+        libdir="$found_dir"
+        eval flag=\"$acl_hardcode_libdir_flag_spec\"
+        libdir="$acl_save_libdir"
+        LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$flag"
+      done
+    fi
+  fi
+  if test "X$ltrpathdirs" != "X"; then
+    dnl When using libtool, the option that works for both libraries and
+    dnl executables is -R. The -R options are cumulative.
+    for found_dir in $ltrpathdirs; do
+      LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-R$found_dir"
+    done
+  fi
+  popdef([P_A_C_K])
+  popdef([PACKLIBS])
+  popdef([PACKUP])
+  popdef([PACK])
+  popdef([NAME])
+])
+
+dnl AC_LIB_APPENDTOVAR(VAR, CONTENTS) appends the elements of CONTENTS to VAR,
+dnl unless already present in VAR.
+dnl Works only for CPPFLAGS, not for LIB* variables because that sometimes
+dnl contains two or three consecutive elements that belong together.
+AC_DEFUN([AC_LIB_APPENDTOVAR],
+[
+  for element in [$2]; do
+    haveit=
+    for x in $[$1]; do
+      AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+      if test "X$x" = "X$element"; then
+        haveit=yes
+        break
+      fi
+    done
+    if test -z "$haveit"; then
+      [$1]="${[$1]}${[$1]:+ }$element"
+    fi
+  done
+])
+
+dnl For those cases where a variable contains several -L and -l options
+dnl referring to unknown libraries and directories, this macro determines the
+dnl necessary additional linker options for the runtime path.
+dnl AC_LIB_LINKFLAGS_FROM_LIBS([LDADDVAR], [LIBSVALUE], [USE-LIBTOOL])
+dnl sets LDADDVAR to linker options needed together with LIBSVALUE.
+dnl If USE-LIBTOOL evaluates to non-empty, linking with libtool is assumed,
+dnl otherwise linking without libtool is assumed.
+AC_DEFUN([AC_LIB_LINKFLAGS_FROM_LIBS],
+[
+  AC_REQUIRE([AC_LIB_RPATH])
+  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])
+  $1=
+  if test "$enable_rpath" != no; then
+    if test -n "$acl_hardcode_libdir_flag_spec" && test "$acl_hardcode_minus_L" = no; then
+      dnl Use an explicit option to hardcode directories into the resulting
+      dnl binary.
+      rpathdirs=
+      next=
+      for opt in $2; do
+        if test -n "$next"; then
+          dir="$next"
+          dnl No need to hardcode the standard /usr/lib.
+          if test "X$dir" != "X/usr/$acl_libdirstem" \
+             && test "X$dir" != "X/usr/$acl_libdirstem2"; then
+            rpathdirs="$rpathdirs $dir"
+          fi
+          next=
+        else
+          case $opt in
+            -L) next=yes ;;
+            -L*) dir=`echo "X$opt" | sed -e 's,^X-L,,'`
+                 dnl No need to hardcode the standard /usr/lib.
+                 if test "X$dir" != "X/usr/$acl_libdirstem" \
+                    && test "X$dir" != "X/usr/$acl_libdirstem2"; then
+                   rpathdirs="$rpathdirs $dir"
+                 fi
+                 next= ;;
+            *) next= ;;
+          esac
+        fi
+      done
+      if test "X$rpathdirs" != "X"; then
+        if test -n ""$3""; then
+          dnl libtool is used for linking. Use -R options.
+          for dir in $rpathdirs; do
+            $1="${$1}${$1:+ }-R$dir"
+          done
+        else
+          dnl The linker is used for linking directly.
+          if test -n "$acl_hardcode_libdir_separator"; then
+            dnl Weird platform: only the last -rpath option counts, the user
+            dnl must pass all path elements in one option.
+            alldirs=
+            for dir in $rpathdirs; do
+              alldirs="${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$dir"
+            done
+            acl_save_libdir="$libdir"
+            libdir="$alldirs"
+            eval flag=\"$acl_hardcode_libdir_flag_spec\"
+            libdir="$acl_save_libdir"
+            $1="$flag"
+          else
+            dnl The -rpath options are cumulative.
+            for dir in $rpathdirs; do
+              acl_save_libdir="$libdir"
+              libdir="$dir"
+              eval flag=\"$acl_hardcode_libdir_flag_spec\"
+              libdir="$acl_save_libdir"
+              $1="${$1}${$1:+ }$flag"
+            done
+          fi
+        fi
+      fi
+    fi
+  fi
+  AC_SUBST([$1])
+])
--- /dev/null
+++ b/lib/gl/m4/lib-prefix.m4
@@ -0,0 +1,224 @@
+# lib-prefix.m4 serial 7 (gettext-0.18)
+dnl Copyright (C) 2001-2005, 2008-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+dnl AC_LIB_ARG_WITH is synonymous to AC_ARG_WITH in autoconf-2.13, and
+dnl similar to AC_ARG_WITH in autoconf 2.52...2.57 except that is doesn't
+dnl require excessive bracketing.
+ifdef([AC_HELP_STRING],
+[AC_DEFUN([AC_LIB_ARG_WITH], [AC_ARG_WITH([$1],[[$2]],[$3],[$4])])],
+[AC_DEFUN([AC_][LIB_ARG_WITH], [AC_ARG_WITH([$1],[$2],[$3],[$4])])])
+
+dnl AC_LIB_PREFIX adds to the CPPFLAGS and LDFLAGS the flags that are needed
+dnl to access previously installed libraries. The basic assumption is that
+dnl a user will want packages to use other packages he previously installed
+dnl with the same --prefix option.
+dnl This macro is not needed if only AC_LIB_LINKFLAGS is used to locate
+dnl libraries, but is otherwise very convenient.
+AC_DEFUN([AC_LIB_PREFIX],
+[
+  AC_BEFORE([$0], [AC_LIB_LINKFLAGS])
+  AC_REQUIRE([AC_PROG_CC])
+  AC_REQUIRE([AC_CANONICAL_HOST])
+  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  dnl By default, look in $includedir and $libdir.
+  use_additional=yes
+  AC_LIB_WITH_FINAL_PREFIX([
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+  ])
+  AC_LIB_ARG_WITH([lib-prefix],
+[  --with-lib-prefix[=DIR] search for libraries in DIR/include and DIR/lib
+  --without-lib-prefix    don't search for libraries in includedir and libdir],
+[
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+        AC_LIB_WITH_FINAL_PREFIX([
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+        ])
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/$acl_libdirstem"
+      fi
+    fi
+])
+  if test $use_additional = yes; then
+    dnl Potentially add $additional_includedir to $CPPFLAGS.
+    dnl But don't add it
+    dnl   1. if it's the standard /usr/include,
+    dnl   2. if it's already present in $CPPFLAGS,
+    dnl   3. if it's /usr/local/include and we are using GCC on Linux,
+    dnl   4. if it doesn't exist as a directory.
+    if test "X$additional_includedir" != "X/usr/include"; then
+      haveit=
+      for x in $CPPFLAGS; do
+        AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+        if test "X$x" = "X-I$additional_includedir"; then
+          haveit=yes
+          break
+        fi
+      done
+      if test -z "$haveit"; then
+        if test "X$additional_includedir" = "X/usr/local/include"; then
+          if test -n "$GCC"; then
+            case $host_os in
+              linux* | gnu* | k*bsd*-gnu) haveit=yes;;
+            esac
+          fi
+        fi
+        if test -z "$haveit"; then
+          if test -d "$additional_includedir"; then
+            dnl Really add $additional_includedir to $CPPFLAGS.
+            CPPFLAGS="${CPPFLAGS}${CPPFLAGS:+ }-I$additional_includedir"
+          fi
+        fi
+      fi
+    fi
+    dnl Potentially add $additional_libdir to $LDFLAGS.
+    dnl But don't add it
+    dnl   1. if it's the standard /usr/lib,
+    dnl   2. if it's already present in $LDFLAGS,
+    dnl   3. if it's /usr/local/lib and we are using GCC on Linux,
+    dnl   4. if it doesn't exist as a directory.
+    if test "X$additional_libdir" != "X/usr/$acl_libdirstem"; then
+      haveit=
+      for x in $LDFLAGS; do
+        AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+        if test "X$x" = "X-L$additional_libdir"; then
+          haveit=yes
+          break
+        fi
+      done
+      if test -z "$haveit"; then
+        if test "X$additional_libdir" = "X/usr/local/$acl_libdirstem"; then
+          if test -n "$GCC"; then
+            case $host_os in
+              linux*) haveit=yes;;
+            esac
+          fi
+        fi
+        if test -z "$haveit"; then
+          if test -d "$additional_libdir"; then
+            dnl Really add $additional_libdir to $LDFLAGS.
+            LDFLAGS="${LDFLAGS}${LDFLAGS:+ }-L$additional_libdir"
+          fi
+        fi
+      fi
+    fi
+  fi
+])
+
+dnl AC_LIB_PREPARE_PREFIX creates variables acl_final_prefix,
+dnl acl_final_exec_prefix, containing the values to which $prefix and
+dnl $exec_prefix will expand at the end of the configure script.
+AC_DEFUN([AC_LIB_PREPARE_PREFIX],
+[
+  dnl Unfortunately, prefix and exec_prefix get only finally determined
+  dnl at the end of configure.
+  if test "X$prefix" = "XNONE"; then
+    acl_final_prefix="$ac_default_prefix"
+  else
+    acl_final_prefix="$prefix"
+  fi
+  if test "X$exec_prefix" = "XNONE"; then
+    acl_final_exec_prefix='${prefix}'
+  else
+    acl_final_exec_prefix="$exec_prefix"
+  fi
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  eval acl_final_exec_prefix=\"$acl_final_exec_prefix\"
+  prefix="$acl_save_prefix"
+])
+
+dnl AC_LIB_WITH_FINAL_PREFIX([statement]) evaluates statement, with the
+dnl variables prefix and exec_prefix bound to the values they will have
+dnl at the end of the configure script.
+AC_DEFUN([AC_LIB_WITH_FINAL_PREFIX],
+[
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  $1
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+])
+
+dnl AC_LIB_PREPARE_MULTILIB creates
+dnl - a variable acl_libdirstem, containing the basename of the libdir, either
+dnl   "lib" or "lib64" or "lib/64",
+dnl - a variable acl_libdirstem2, as a secondary possible value for
+dnl   acl_libdirstem, either the same as acl_libdirstem or "lib/sparcv9" or
+dnl   "lib/amd64".
+AC_DEFUN([AC_LIB_PREPARE_MULTILIB],
+[
+  dnl There is no formal standard regarding lib and lib64.
+  dnl On glibc systems, the current practice is that on a system supporting
+  dnl 32-bit and 64-bit instruction sets or ABIs, 64-bit libraries go under
+  dnl $prefix/lib64 and 32-bit libraries go under $prefix/lib. We determine
+  dnl the compiler's default mode by looking at the compiler's library search
+  dnl path. If at least one of its elements ends in /lib64 or points to a
+  dnl directory whose absolute pathname ends in /lib64, we assume a 64-bit ABI.
+  dnl Otherwise we use the default, namely "lib".
+  dnl On Solaris systems, the current practice is that on a system supporting
+  dnl 32-bit and 64-bit instruction sets or ABIs, 64-bit libraries go under
+  dnl $prefix/lib/64 (which is a symlink to either $prefix/lib/sparcv9 or
+  dnl $prefix/lib/amd64) and 32-bit libraries go under $prefix/lib.
+  AC_REQUIRE([AC_CANONICAL_HOST])
+  acl_libdirstem=lib
+  acl_libdirstem2=
+  case "$host_os" in
+    solaris*)
+      dnl See Solaris 10 Software Developer Collection > Solaris 64-bit Developer's Guide > The Development Environment
+      dnl <http://docs.sun.com/app/docs/doc/816-5138/dev-env?l=en&a=view>.
+      dnl "Portable Makefiles should refer to any library directories using the 64 symbolic link."
+      dnl But we want to recognize the sparcv9 or amd64 subdirectory also if the
+      dnl symlink is missing, so we set acl_libdirstem2 too.
+      AC_CACHE_CHECK([for 64-bit host], [gl_cv_solaris_64bit],
+        [AC_EGREP_CPP([sixtyfour bits], [
+#ifdef _LP64
+sixtyfour bits
+#endif
+           ], [gl_cv_solaris_64bit=yes], [gl_cv_solaris_64bit=no])
+        ])
+      if test $gl_cv_solaris_64bit = yes; then
+        acl_libdirstem=lib/64
+        case "$host_cpu" in
+          sparc*)        acl_libdirstem2=lib/sparcv9 ;;
+          i*86 | x86_64) acl_libdirstem2=lib/amd64 ;;
+        esac
+      fi
+      ;;
+    *)
+      searchpath=`(LC_ALL=C $CC -print-search-dirs) 2>/dev/null | sed -n -e 's,^libraries: ,,p' | sed -e 's,^=,,'`
+      if test -n "$searchpath"; then
+        acl_save_IFS="${IFS= 	}"; IFS=":"
+        for searchdir in $searchpath; do
+          if test -d "$searchdir"; then
+            case "$searchdir" in
+              */lib64/ | */lib64 ) acl_libdirstem=lib64 ;;
+              */../ | */.. )
+                # Better ignore directories of this form. They are misleading.
+                ;;
+              *) searchdir=`cd "$searchdir" && pwd`
+                 case "$searchdir" in
+                   */lib64 ) acl_libdirstem=lib64 ;;
+                 esac ;;
+            esac
+          fi
+        done
+        IFS="$acl_save_IFS"
+      fi
+      ;;
+  esac
+  test -n "$acl_libdirstem2" || acl_libdirstem2="$acl_libdirstem"
+])
--- /dev/null
+++ b/lib/gl/m4/libunistring-base.m4
@@ -0,0 +1,141 @@
+# libunistring-base.m4 serial 5
+dnl Copyright (C) 2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Paolo Bonzini and Bruno Haible.
+
+dnl gl_LIBUNISTRING_MODULE([VERSION], [Module])
+dnl Declares that the source files of Module should be compiled, unless we
+dnl are linking with libunistring and its version is >= the given VERSION.
+dnl Defines an automake conditional LIBUNISTRING_COMPILE_$MODULE that is
+dnl true if the source files of Module should be compiled.
+dnl This macro is to be used for public libunistring API, not for
+dnl undocumented API.
+dnl
+dnl You have to bump the VERSION argument to the next projected version
+dnl number each time you make a change that affects the behaviour of the
+dnl functions defined in Module (even if the sources of Module itself do not
+dnl change).
+
+AC_DEFUN([gl_LIBUNISTRING_MODULE],
+[
+  AC_REQUIRE([gl_LIBUNISTRING_LIB_PREPARE])
+  dnl Use the variables HAVE_LIBUNISTRING, LIBUNISTRING_VERSION from
+  dnl gl_LIBUNISTRING_CORE if that macro has been run.
+  AM_CONDITIONAL(AS_TR_CPP([LIBUNISTRING_COMPILE_$2]),
+    [gl_LIBUNISTRING_VERSION_CMP([$1])])
+])
+
+dnl gl_LIBUNISTRING_LIBHEADER([VERSION], [HeaderFile])
+dnl Declares that HeaderFile should be created, unless we are linking
+dnl with libunistring and its version is >= the given VERSION.
+dnl HeaderFile should be relative to the lib directory and end in '.h'.
+dnl Prepares for substituting LIBUNISTRING_HEADERFILE (to HeaderFile or empty).
+dnl
+dnl When we are linking with the already installed libunistring and its version
+dnl is < VERSION, we create HeaderFile here, because we may compile functions
+dnl (via gl_LIBUNISTRING_MODULE above) that are not contained in the installed
+dnl version.
+dnl When we are linking with the already installed libunistring and its version
+dnl is > VERSION, we don't create HeaderFile here: it could cause compilation
+dnl errors in other libunistring header files if some types are missing.
+dnl
+dnl You have to bump the VERSION argument to the next projected version
+dnl number each time you make a non-comment change to the HeaderFile.
+
+AC_DEFUN([gl_LIBUNISTRING_LIBHEADER],
+[
+  AC_REQUIRE([gl_LIBUNISTRING_LIB_PREPARE])
+  dnl Use the variables HAVE_LIBUNISTRING, LIBUNISTRING_VERSION from
+  dnl gl_LIBUNISTRING_CORE if that macro has been run.
+  if gl_LIBUNISTRING_VERSION_CMP([$1]); then
+    LIBUNISTRING_[]AS_TR_CPP([$2])='$2'
+  else
+    LIBUNISTRING_[]AS_TR_CPP([$2])=
+  fi
+  AC_SUBST([LIBUNISTRING_]AS_TR_CPP([$2]))
+])
+
+dnl Miscellaneous preparations/initializations.
+
+AC_DEFUN([gl_LIBUNISTRING_LIB_PREPARE],
+[
+  dnl Ensure that HAVE_LIBUNISTRING is fully determined at this point.
+  m4_ifdef([gl_LIBUNISTRING], [AC_REQUIRE([gl_LIBUNISTRING])])
+
+  AC_REQUIRE([AC_PROG_AWK])
+
+dnl Sed expressions to extract the parts of a version number.
+changequote(,)
+gl_libunistring_sed_extract_major='/^[0-9]/{s/^\([0-9]*\).*/\1/p;q;}
+i\
+0
+q
+'
+gl_libunistring_sed_extract_minor='/^[0-9][0-9]*[.][0-9]/{s/^[0-9]*[.]\([0-9]*\).*/\1/p;q;}
+i\
+0
+q
+'
+gl_libunistring_sed_extract_subminor='/^[0-9][0-9]*[.][0-9][0-9]*[.][0-9]/{s/^[0-9]*[.][0-9]*[.]\([0-9]*\).*/\1/p;q;}
+i\
+0
+q
+'
+changequote([,])
+
+  if test "$HAVE_LIBUNISTRING" = yes; then
+    LIBUNISTRING_VERSION_MAJOR=`echo "$LIBUNISTRING_VERSION" | sed -n -e "$gl_libunistring_sed_extract_major"`
+    LIBUNISTRING_VERSION_MINOR=`echo "$LIBUNISTRING_VERSION" | sed -n -e "$gl_libunistring_sed_extract_minor"`
+    LIBUNISTRING_VERSION_SUBMINOR=`echo "$LIBUNISTRING_VERSION" | sed -n -e "$gl_libunistring_sed_extract_subminor"`
+  fi
+])
+
+dnl gl_LIBUNISTRING_VERSION_CMP([VERSION])
+dnl Expands to a shell statement that evaluates to true if LIBUNISTRING_VERSION
+dnl is less than the VERSION argument.
+AC_DEFUN([gl_LIBUNISTRING_VERSION_CMP],
+[ { test "$HAVE_LIBUNISTRING" != yes \
+    || {
+         dnl AS_LITERAL_IF exists and works fine since autoconf-2.59 at least.
+         AS_LITERAL_IF([$1],
+           [dnl This is the optimized variant, that assumes the argument is a literal:
+            m4_pushdef([requested_version_major],
+              [gl_LIBUNISTRING_ARG_OR_ZERO(m4_bpatsubst([$1], [^\([0-9]*\).*], [\1]), [])])
+            m4_pushdef([requested_version_minor],
+              [gl_LIBUNISTRING_ARG_OR_ZERO(m4_bpatsubst([$1], [^[0-9]*[.]\([0-9]*\).*], [\1]), [$1])])
+            m4_pushdef([requested_version_subminor],
+              [gl_LIBUNISTRING_ARG_OR_ZERO(m4_bpatsubst([$1], [^[0-9]*[.][0-9]*[.]\([0-9]*\).*], [\1]), [$1])])
+            test $LIBUNISTRING_VERSION_MAJOR -lt requested_version_major \
+            || { test $LIBUNISTRING_VERSION_MAJOR -eq requested_version_major \
+                 && { test $LIBUNISTRING_VERSION_MINOR -lt requested_version_minor \
+                      || { test $LIBUNISTRING_VERSION_MINOR -eq requested_version_minor \
+                           && test $LIBUNISTRING_VERSION_SUBMINOR -lt requested_version_subminor
+                         }
+                    }
+               }
+            m4_popdef([requested_version_subminor])
+            m4_popdef([requested_version_minor])
+            m4_popdef([requested_version_major])
+           ],
+           [dnl This is the unoptimized variant:
+            requested_version_major=`echo '$1' | sed -n -e "$gl_libunistring_sed_extract_major"`
+            requested_version_minor=`echo '$1' | sed -n -e "$gl_libunistring_sed_extract_minor"`
+            requested_version_subminor=`echo '$1' | sed -n -e "$gl_libunistring_sed_extract_subminor"`
+            test $LIBUNISTRING_VERSION_MAJOR -lt $requested_version_major \
+            || { test $LIBUNISTRING_VERSION_MAJOR -eq $requested_version_major \
+                 && { test $LIBUNISTRING_VERSION_MINOR -lt $requested_version_minor \
+                      || { test $LIBUNISTRING_VERSION_MINOR -eq $requested_version_minor \
+                           && test $LIBUNISTRING_VERSION_SUBMINOR -lt $requested_version_subminor
+                         }
+                    }
+               }
+           ])
+       }
+  }])
+
+dnl gl_LIBUNISTRING_ARG_OR_ZERO([ARG], [ORIG]) expands to ARG if it is not the
+dnl same as ORIG, otherwise to 0.
+m4_define([gl_LIBUNISTRING_ARG_OR_ZERO], [m4_if([$1], [$2], [0], [$1])])
--- a/lib/gl/m4/locale-fr.m4
+++ b/lib/gl/m4/locale-fr.m4
@@ -1,5 +1,5 @@
 # locale-fr.m4 serial 11
-dnl Copyright (C) 2003, 2005-2009 Free Software Foundation, Inc.
+dnl Copyright (C) 2003, 2005-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
--- a/lib/gl/m4/locale-tr.m4
+++ b/lib/gl/m4/locale-tr.m4
@@ -1,5 +1,5 @@
 # locale-tr.m4 serial 6
-dnl Copyright (C) 2003, 2005-2009 Free Software Foundation, Inc.
+dnl Copyright (C) 2003, 2005-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
--- /dev/null
+++ b/lib/gl/m4/longlong.m4
@@ -0,0 +1,106 @@
+# longlong.m4 serial 14
+dnl Copyright (C) 1999-2007, 2009-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Paul Eggert.
+
+# Define HAVE_LONG_LONG_INT if 'long long int' works.
+# This fixes a bug in Autoconf 2.61, but can be removed once we
+# assume 2.62 everywhere.
+
+# Note: If the type 'long long int' exists but is only 32 bits large
+# (as on some very old compilers), HAVE_LONG_LONG_INT will not be
+# defined. In this case you can treat 'long long int' like 'long int'.
+
+AC_DEFUN([AC_TYPE_LONG_LONG_INT],
+[
+  AC_CACHE_CHECK([for long long int], [ac_cv_type_long_long_int],
+    [AC_LINK_IFELSE(
+       [_AC_TYPE_LONG_LONG_SNIPPET],
+       [dnl This catches a bug in Tandem NonStop Kernel (OSS) cc -O circa 2004.
+        dnl If cross compiling, assume the bug isn't important, since
+        dnl nobody cross compiles for this platform as far as we know.
+        AC_RUN_IFELSE(
+          [AC_LANG_PROGRAM(
+             [[@%:@include <limits.h>
+               @%:@ifndef LLONG_MAX
+               @%:@ define HALF \
+                        (1LL << (sizeof (long long int) * CHAR_BIT - 2))
+               @%:@ define LLONG_MAX (HALF - 1 + HALF)
+               @%:@endif]],
+             [[long long int n = 1;
+               int i;
+               for (i = 0; ; i++)
+                 {
+                   long long int m = n << i;
+                   if (m >> i != n)
+                     return 1;
+                   if (LLONG_MAX / 2 < m)
+                     break;
+                 }
+               return 0;]])],
+          [ac_cv_type_long_long_int=yes],
+          [ac_cv_type_long_long_int=no],
+          [ac_cv_type_long_long_int=yes])],
+       [ac_cv_type_long_long_int=no])])
+  if test $ac_cv_type_long_long_int = yes; then
+    AC_DEFINE([HAVE_LONG_LONG_INT], [1],
+      [Define to 1 if the system has the type `long long int'.])
+  fi
+])
+
+# Define HAVE_UNSIGNED_LONG_LONG_INT if 'unsigned long long int' works.
+# This fixes a bug in Autoconf 2.61, but can be removed once we
+# assume 2.62 everywhere.
+
+# Note: If the type 'unsigned long long int' exists but is only 32 bits
+# large (as on some very old compilers), AC_TYPE_UNSIGNED_LONG_LONG_INT
+# will not be defined. In this case you can treat 'unsigned long long int'
+# like 'unsigned long int'.
+
+AC_DEFUN([AC_TYPE_UNSIGNED_LONG_LONG_INT],
+[
+  AC_CACHE_CHECK([for unsigned long long int],
+    [ac_cv_type_unsigned_long_long_int],
+    [AC_LINK_IFELSE(
+       [_AC_TYPE_LONG_LONG_SNIPPET],
+       [ac_cv_type_unsigned_long_long_int=yes],
+       [ac_cv_type_unsigned_long_long_int=no])])
+  if test $ac_cv_type_unsigned_long_long_int = yes; then
+    AC_DEFINE([HAVE_UNSIGNED_LONG_LONG_INT], [1],
+      [Define to 1 if the system has the type `unsigned long long int'.])
+  fi
+])
+
+# Expands to a C program that can be used to test for simultaneous support
+# of 'long long' and 'unsigned long long'. We don't want to say that
+# 'long long' is available if 'unsigned long long' is not, or vice versa,
+# because too many programs rely on the symmetry between signed and unsigned
+# integer types (excluding 'bool').
+AC_DEFUN([_AC_TYPE_LONG_LONG_SNIPPET],
+[
+  AC_LANG_PROGRAM(
+    [[/* For now, do not test the preprocessor; as of 2007 there are too many
+         implementations with broken preprocessors.  Perhaps this can
+         be revisited in 2012.  In the meantime, code should not expect
+         #if to work with literals wider than 32 bits.  */
+      /* Test literals.  */
+      long long int ll = 9223372036854775807ll;
+      long long int nll = -9223372036854775807LL;
+      unsigned long long int ull = 18446744073709551615ULL;
+      /* Test constant expressions.   */
+      typedef int a[((-9223372036854775807LL < 0 && 0 < 9223372036854775807ll)
+                     ? 1 : -1)];
+      typedef int b[(18446744073709551615ULL <= (unsigned long long int) -1
+                     ? 1 : -1)];
+      int i = 63;]],
+    [[/* Test availability of runtime routines for shift and division.  */
+      long long int llmax = 9223372036854775807ll;
+      unsigned long long int ullmax = 18446744073709551615ull;
+      return ((ll << 63) | (ll >> 63) | (ll < i) | (ll > i)
+              | (llmax / ll) | (llmax % ll)
+              | (ull << 63) | (ull >> 63) | (ull << i) | (ull >> i)
+              | (ullmax / ull) | (ullmax % ull));]])
+])
--- a/lib/gl/m4/multiarch.m4
+++ b/lib/gl/m4/multiarch.m4
@@ -1,5 +1,5 @@
 # multiarch.m4 serial 5
-dnl Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+dnl Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
--- a/lib/gl/m4/stdbool.m4
+++ b/lib/gl/m4/stdbool.m4
@@ -1,6 +1,6 @@
 # Check for stdbool.h that conforms to C99.
 
-dnl Copyright (C) 2002-2006, 2009 Free Software Foundation, Inc.
+dnl Copyright (C) 2002-2006, 2009-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
@@ -38,77 +38,77 @@ AC_DEFUN([AC_HEADER_STDBOOL],
   [AC_CACHE_CHECK([for stdbool.h that conforms to C99],
      [ac_cv_header_stdbool_h],
      [AC_TRY_COMPILE(
-	[
-	  #include <stdbool.h>
-	  #ifndef bool
-	   "error: bool is not defined"
-	  #endif
-	  #ifndef false
-	   "error: false is not defined"
-	  #endif
-	  #if false
-	   "error: false is not 0"
-	  #endif
-	  #ifndef true
-	   "error: true is not defined"
-	  #endif
-	  #if true != 1
-	   "error: true is not 1"
-	  #endif
-	  #ifndef __bool_true_false_are_defined
-	   "error: __bool_true_false_are_defined is not defined"
-	  #endif
-
-	  struct s { _Bool s: 1; _Bool t; } s;
-
-	  char a[true == 1 ? 1 : -1];
-	  char b[false == 0 ? 1 : -1];
-	  char c[__bool_true_false_are_defined == 1 ? 1 : -1];
-	  char d[(bool) 0.5 == true ? 1 : -1];
-	  bool e = &s;
-	  char f[(_Bool) 0.0 == false ? 1 : -1];
-	  char g[true];
-	  char h[sizeof (_Bool)];
-	  char i[sizeof s.t];
-	  enum { j = false, k = true, l = false * true, m = true * 256 };
-	  _Bool n[m];
-	  char o[sizeof n == m * sizeof n[0] ? 1 : -1];
-	  char p[-1 - (_Bool) 0 < 0 && -1 - (bool) 0 < 0 ? 1 : -1];
-	  #if defined __xlc__ || defined __GNUC__
-	   /* Catch a bug in IBM AIX xlc compiler version 6.0.0.0
-	      reported by James Lemley on 2005-10-05; see
-	      http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html
-	      This test is not quite right, since xlc is allowed to
-	      reject this program, as the initializer for xlcbug is
-	      not one of the forms that C requires support for.
-	      However, doing the test right would require a run-time
-	      test, and that would make cross-compilation harder.
-	      Let us hope that IBM fixes the xlc bug, and also adds
-	      support for this kind of constant expression.  In the
-	      meantime, this test will reject xlc, which is OK, since
-	      our stdbool.h substitute should suffice.  We also test
-	      this with GCC, where it should work, to detect more
-	      quickly whether someone messes up the test in the
-	      future.  */
-	   char digs[] = "0123456789";
-	   int xlcbug = 1 / (&(digs + 5)[-2 + (bool) 1] == &digs[4] ? 1 : -1);
-	  #endif
-	  /* Catch a bug in an HP-UX C compiler.  See
-	     http://gcc.gnu.org/ml/gcc-patches/2003-12/msg02303.html
-	     http://lists.gnu.org/archive/html/bug-coreutils/2005-11/msg00161.html
-	   */
-	  _Bool q = true;
-	  _Bool *pq = &q;
-	],
-	[
-	  *pq |= q;
-	  *pq |= ! q;
-	  /* Refer to every declared value, to avoid compiler optimizations.  */
-	  return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
-		  + !m + !n + !o + !p + !q + !pq);
-	],
-	[ac_cv_header_stdbool_h=yes],
-	[ac_cv_header_stdbool_h=no])])
+        [
+          #include <stdbool.h>
+          #ifndef bool
+           "error: bool is not defined"
+          #endif
+          #ifndef false
+           "error: false is not defined"
+          #endif
+          #if false
+           "error: false is not 0"
+          #endif
+          #ifndef true
+           "error: true is not defined"
+          #endif
+          #if true != 1
+           "error: true is not 1"
+          #endif
+          #ifndef __bool_true_false_are_defined
+           "error: __bool_true_false_are_defined is not defined"
+          #endif
+
+          struct s { _Bool s: 1; _Bool t; } s;
+
+          char a[true == 1 ? 1 : -1];
+          char b[false == 0 ? 1 : -1];
+          char c[__bool_true_false_are_defined == 1 ? 1 : -1];
+          char d[(bool) 0.5 == true ? 1 : -1];
+          bool e = &s;
+          char f[(_Bool) 0.0 == false ? 1 : -1];
+          char g[true];
+          char h[sizeof (_Bool)];
+          char i[sizeof s.t];
+          enum { j = false, k = true, l = false * true, m = true * 256 };
+          _Bool n[m];
+          char o[sizeof n == m * sizeof n[0] ? 1 : -1];
+          char p[-1 - (_Bool) 0 < 0 && -1 - (bool) 0 < 0 ? 1 : -1];
+          #if defined __xlc__ || defined __GNUC__
+           /* Catch a bug in IBM AIX xlc compiler version 6.0.0.0
+              reported by James Lemley on 2005-10-05; see
+              http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html
+              This test is not quite right, since xlc is allowed to
+              reject this program, as the initializer for xlcbug is
+              not one of the forms that C requires support for.
+              However, doing the test right would require a run-time
+              test, and that would make cross-compilation harder.
+              Let us hope that IBM fixes the xlc bug, and also adds
+              support for this kind of constant expression.  In the
+              meantime, this test will reject xlc, which is OK, since
+              our stdbool.h substitute should suffice.  We also test
+              this with GCC, where it should work, to detect more
+              quickly whether someone messes up the test in the
+              future.  */
+           char digs[] = "0123456789";
+           int xlcbug = 1 / (&(digs + 5)[-2 + (bool) 1] == &digs[4] ? 1 : -1);
+          #endif
+          /* Catch a bug in an HP-UX C compiler.  See
+             http://gcc.gnu.org/ml/gcc-patches/2003-12/msg02303.html
+             http://lists.gnu.org/archive/html/bug-coreutils/2005-11/msg00161.html
+           */
+          _Bool q = true;
+          _Bool *pq = &q;
+        ],
+        [
+          *pq |= q;
+          *pq |= ! q;
+          /* Refer to every declared value, to avoid compiler optimizations.  */
+          return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
+                  + !m + !n + !o + !p + !q + !pq);
+        ],
+        [ac_cv_header_stdbool_h=yes],
+        [ac_cv_header_stdbool_h=no])])
    AC_CHECK_TYPES([_Bool])
    if test $ac_cv_header_stdbool_h = yes; then
      AC_DEFINE([HAVE_STDBOOL_H], [1], [Define to 1 if stdbool.h conforms to C99.])
--- /dev/null
+++ b/lib/gl/m4/stddef_h.m4
@@ -0,0 +1,45 @@
+dnl A placeholder for POSIX 2008 <stddef.h>, for platforms that have issues.
+# stddef_h.m4 serial 2
+dnl Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_STDDEF_H],
+[
+  AC_REQUIRE([gl_STDDEF_H_DEFAULTS])
+  AC_REQUIRE([gt_TYPE_WCHAR_T])
+  if test $gt_cv_c_wchar_t = no; then
+    HAVE_WCHAR_T=0
+    STDDEF_H=stddef.h
+  fi
+  AC_CACHE_CHECK([whether NULL can be used in arbitrary expressions],
+    [gl_cv_decl_null_works],
+    [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <stddef.h>
+      int test[2 * (sizeof NULL == sizeof (void *)) -1];
+]])],
+      [gl_cv_decl_null_works=yes],
+      [gl_cv_decl_null_works=no])])
+  if test $gl_cv_decl_null_works = no; then
+    REPLACE_NULL=1
+    STDDEF_H=stddef.h
+  fi
+  if test -n "$STDDEF_H"; then
+    gl_CHECK_NEXT_HEADERS([stddef.h])
+  fi
+])
+
+AC_DEFUN([gl_STDDEF_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_STDDEF_H_DEFAULTS])
+  gl_MODULE_INDICATOR_SET_VARIABLE([$1])
+])
+
+AC_DEFUN([gl_STDDEF_H_DEFAULTS],
+[
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  REPLACE_NULL=0;                AC_SUBST([REPLACE_NULL])
+  HAVE_WCHAR_T=1;                AC_SUBST([HAVE_WCHAR_T])
+  STDDEF_H='';                   AC_SUBST([STDDEF_H])
+])
--- a/lib/gl/m4/stdint.m4
+++ b/lib/gl/m4/stdint.m4
@@ -1,5 +1,5 @@
-# stdint.m4 serial 34
-dnl Copyright (C) 2001-2009 Free Software Foundation, Inc.
+# stdint.m4 serial 35
+dnl Copyright (C) 2001-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
@@ -309,7 +309,7 @@ AC_DEFUN([gl_STDINT_BITSIZEOF],
   dnl   config.h.in,
   dnl - extra AC_SUBST calls, so that the right substitutions are made.
   m4_foreach_w([gltype], [$1],
-    [AH_TEMPLATE([BITSIZEOF_]translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]),
+    [AH_TEMPLATE([BITSIZEOF_]m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]),
        [Define to the number of bits in type ']gltype['.])])
   for gltype in $1 ; do
     AC_CACHE_CHECK([for bit size of $gltype], [gl_cv_bitsizeof_${gltype}],
@@ -334,7 +334,7 @@ AC_DEFUN([gl_STDINT_BITSIZEOF],
     eval BITSIZEOF_${GLTYPE}=\$result
   done
   m4_foreach_w([gltype], [$1],
-    [AC_SUBST([BITSIZEOF_]translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]))])
+    [AC_SUBST([BITSIZEOF_]m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]))])
 ])
 
 dnl gl_CHECK_TYPES_SIGNED(TYPES, INCLUDES)
@@ -347,7 +347,7 @@ AC_DEFUN([gl_CHECK_TYPES_SIGNED],
   dnl   config.h.in,
   dnl - extra AC_SUBST calls, so that the right substitutions are made.
   m4_foreach_w([gltype], [$1],
-    [AH_TEMPLATE([HAVE_SIGNED_]translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]),
+    [AH_TEMPLATE([HAVE_SIGNED_]m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]),
        [Define to 1 if ']gltype[' is a signed integer type.])])
   for gltype in $1 ; do
     AC_CACHE_CHECK([whether $gltype is signed], [gl_cv_type_${gltype}_signed],
@@ -367,7 +367,7 @@ AC_DEFUN([gl_CHECK_TYPES_SIGNED],
     fi
   done
   m4_foreach_w([gltype], [$1],
-    [AC_SUBST([HAVE_SIGNED_]translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]))])
+    [AC_SUBST([HAVE_SIGNED_]m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]))])
 ])
 
 dnl gl_INTEGER_TYPE_SUFFIX(TYPES, INCLUDES)
@@ -380,7 +380,7 @@ AC_DEFUN([gl_INTEGER_TYPE_SUFFIX],
   dnl   config.h.in,
   dnl - extra AC_SUBST calls, so that the right substitutions are made.
   m4_foreach_w([gltype], [$1],
-    [AH_TEMPLATE(translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_])[_SUFFIX],
+    [AH_TEMPLATE(m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_])[_SUFFIX],
        [Define to l, ll, u, ul, ull, etc., as suitable for
         constants of type ']gltype['.])])
   for gltype in $1 ; do
@@ -396,12 +396,12 @@ AC_DEFUN([gl_INTEGER_TYPE_SUFFIX],
        for glsuf in "$glsufu" ${glsufu}l ${glsufu}ll ${glsufu}i64; do
          case $glsuf in
            '')  gltype1='int';;
-           l)	gltype1='long int';;
-           ll)	gltype1='long long int';;
-           i64)	gltype1='__int64';;
-           u)	gltype1='unsigned int';;
-           ul)	gltype1='unsigned long int';;
-           ull)	gltype1='unsigned long long int';;
+           l)   gltype1='long int';;
+           ll)  gltype1='long long int';;
+           i64) gltype1='__int64';;
+           u)   gltype1='unsigned int';;
+           ul)  gltype1='unsigned long int';;
+           ull) gltype1='unsigned long long int';;
            ui64)gltype1='unsigned __int64';;
          esac
          AC_COMPILE_IFELSE(
@@ -419,7 +419,7 @@ AC_DEFUN([gl_INTEGER_TYPE_SUFFIX],
     AC_DEFINE_UNQUOTED([${GLTYPE}_SUFFIX], [$result])
   done
   m4_foreach_w([gltype], [$1],
-    [AC_SUBST(translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_])[_SUFFIX])])
+    [AC_SUBST(m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_])[_SUFFIX])])
 ])
 
 dnl gl_STDINT_INCLUDES
--- /dev/null
+++ b/lib/gl/m4/string_h.m4
@@ -0,0 +1,112 @@
+# Configure a GNU-like replacement for <string.h>.
+
+# Copyright (C) 2007-2010 Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 17
+
+# Written by Paul Eggert.
+
+AC_DEFUN([gl_HEADER_STRING_H],
+[
+  dnl Use AC_REQUIRE here, so that the default behavior below is expanded
+  dnl once only, before all statements that occur in other macros.
+  AC_REQUIRE([gl_HEADER_STRING_H_BODY])
+])
+
+AC_DEFUN([gl_HEADER_STRING_H_BODY],
+[
+  AC_REQUIRE([AC_C_RESTRICT])
+  AC_REQUIRE([gl_HEADER_STRING_H_DEFAULTS])
+  gl_CHECK_NEXT_HEADERS([string.h])
+
+  dnl Check for declarations of anything we want to poison if the
+  dnl corresponding gnulib module is not in use, and which is not
+  dnl guaranteed by C89.
+  gl_WARN_ON_USE_PREPARE([[#include <string.h>
+    ]],
+    [memmem mempcpy memrchr rawmemchr stpcpy stpncpy strchrnul strdup
+     strncat strndup strnlen strpbrk strsep strcasestr strtok_r strsignal
+     strverscmp])
+])
+
+AC_DEFUN([gl_STRING_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_HEADER_STRING_H_DEFAULTS])
+  gl_MODULE_INDICATOR_SET_VARIABLE([$1])
+  dnl Define it also as a C macro, for the benefit of the unit tests.
+  gl_MODULE_INDICATOR_FOR_TESTS([$1])
+])
+
+AC_DEFUN([gl_HEADER_STRING_H_DEFAULTS],
+[
+  GNULIB_MEMCHR=0;      AC_SUBST([GNULIB_MEMCHR])
+  GNULIB_MEMMEM=0;      AC_SUBST([GNULIB_MEMMEM])
+  GNULIB_MEMPCPY=0;     AC_SUBST([GNULIB_MEMPCPY])
+  GNULIB_MEMRCHR=0;     AC_SUBST([GNULIB_MEMRCHR])
+  GNULIB_RAWMEMCHR=0;   AC_SUBST([GNULIB_RAWMEMCHR])
+  GNULIB_STPCPY=0;      AC_SUBST([GNULIB_STPCPY])
+  GNULIB_STPNCPY=0;     AC_SUBST([GNULIB_STPNCPY])
+  GNULIB_STRCHRNUL=0;   AC_SUBST([GNULIB_STRCHRNUL])
+  GNULIB_STRDUP=0;      AC_SUBST([GNULIB_STRDUP])
+  GNULIB_STRNCAT=0;     AC_SUBST([GNULIB_STRNCAT])
+  GNULIB_STRNDUP=0;     AC_SUBST([GNULIB_STRNDUP])
+  GNULIB_STRNLEN=0;     AC_SUBST([GNULIB_STRNLEN])
+  GNULIB_STRPBRK=0;     AC_SUBST([GNULIB_STRPBRK])
+  GNULIB_STRSEP=0;      AC_SUBST([GNULIB_STRSEP])
+  GNULIB_STRSTR=0;      AC_SUBST([GNULIB_STRSTR])
+  GNULIB_STRCASESTR=0;  AC_SUBST([GNULIB_STRCASESTR])
+  GNULIB_STRTOK_R=0;    AC_SUBST([GNULIB_STRTOK_R])
+  GNULIB_MBSLEN=0;      AC_SUBST([GNULIB_MBSLEN])
+  GNULIB_MBSNLEN=0;     AC_SUBST([GNULIB_MBSNLEN])
+  GNULIB_MBSCHR=0;      AC_SUBST([GNULIB_MBSCHR])
+  GNULIB_MBSRCHR=0;     AC_SUBST([GNULIB_MBSRCHR])
+  GNULIB_MBSSTR=0;      AC_SUBST([GNULIB_MBSSTR])
+  GNULIB_MBSCASECMP=0;  AC_SUBST([GNULIB_MBSCASECMP])
+  GNULIB_MBSNCASECMP=0; AC_SUBST([GNULIB_MBSNCASECMP])
+  GNULIB_MBSPCASECMP=0; AC_SUBST([GNULIB_MBSPCASECMP])
+  GNULIB_MBSCASESTR=0;  AC_SUBST([GNULIB_MBSCASESTR])
+  GNULIB_MBSCSPN=0;     AC_SUBST([GNULIB_MBSCSPN])
+  GNULIB_MBSPBRK=0;     AC_SUBST([GNULIB_MBSPBRK])
+  GNULIB_MBSSPN=0;      AC_SUBST([GNULIB_MBSSPN])
+  GNULIB_MBSSEP=0;      AC_SUBST([GNULIB_MBSSEP])
+  GNULIB_MBSTOK_R=0;    AC_SUBST([GNULIB_MBSTOK_R])
+  GNULIB_STRERROR=0;    AC_SUBST([GNULIB_STRERROR])
+  GNULIB_STRSIGNAL=0;   AC_SUBST([GNULIB_STRSIGNAL])
+  GNULIB_STRVERSCMP=0;  AC_SUBST([GNULIB_STRVERSCMP])
+  HAVE_MBSLEN=0;        AC_SUBST([HAVE_MBSLEN])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_MEMCHR=1;                AC_SUBST([HAVE_MEMCHR])
+  HAVE_DECL_MEMMEM=1;           AC_SUBST([HAVE_DECL_MEMMEM])
+  HAVE_MEMPCPY=1;               AC_SUBST([HAVE_MEMPCPY])
+  HAVE_DECL_MEMRCHR=1;          AC_SUBST([HAVE_DECL_MEMRCHR])
+  HAVE_RAWMEMCHR=1;             AC_SUBST([HAVE_RAWMEMCHR])
+  HAVE_STPCPY=1;                AC_SUBST([HAVE_STPCPY])
+  HAVE_STPNCPY=1;               AC_SUBST([HAVE_STPNCPY])
+  HAVE_STRCHRNUL=1;             AC_SUBST([HAVE_STRCHRNUL])
+  HAVE_DECL_STRDUP=1;           AC_SUBST([HAVE_DECL_STRDUP])
+  HAVE_DECL_STRNDUP=1;          AC_SUBST([HAVE_DECL_STRNDUP])
+  HAVE_DECL_STRNLEN=1;          AC_SUBST([HAVE_DECL_STRNLEN])
+  HAVE_STRPBRK=1;               AC_SUBST([HAVE_STRPBRK])
+  HAVE_STRSEP=1;                AC_SUBST([HAVE_STRSEP])
+  HAVE_STRCASESTR=1;            AC_SUBST([HAVE_STRCASESTR])
+  HAVE_DECL_STRTOK_R=1;         AC_SUBST([HAVE_DECL_STRTOK_R])
+  HAVE_DECL_STRSIGNAL=1;        AC_SUBST([HAVE_DECL_STRSIGNAL])
+  HAVE_STRVERSCMP=1;            AC_SUBST([HAVE_STRVERSCMP])
+  REPLACE_MEMCHR=0;             AC_SUBST([REPLACE_MEMCHR])
+  REPLACE_MEMMEM=0;             AC_SUBST([REPLACE_MEMMEM])
+  REPLACE_STPNCPY=0;            AC_SUBST([REPLACE_STPNCPY])
+  REPLACE_STRDUP=0;             AC_SUBST([REPLACE_STRDUP])
+  REPLACE_STRSTR=0;             AC_SUBST([REPLACE_STRSTR])
+  REPLACE_STRCASESTR=0;         AC_SUBST([REPLACE_STRCASESTR])
+  REPLACE_STRERROR=0;           AC_SUBST([REPLACE_STRERROR])
+  REPLACE_STRNCAT=0;            AC_SUBST([REPLACE_STRNCAT])
+  REPLACE_STRNDUP=0;            AC_SUBST([REPLACE_STRNDUP])
+  REPLACE_STRNLEN=0;            AC_SUBST([REPLACE_STRNLEN])
+  REPLACE_STRSIGNAL=0;          AC_SUBST([REPLACE_STRSIGNAL])
+  REPLACE_STRTOK_R=0;           AC_SUBST([REPLACE_STRTOK_R])
+  UNDEFINE_STRTOK_R=0;          AC_SUBST([UNDEFINE_STRTOK_R])
+])
--- a/lib/gl/m4/strverscmp.m4
+++ b/lib/gl/m4/strverscmp.m4
@@ -1,5 +1,5 @@
 # strverscmp.m4 serial 7
-dnl Copyright (C) 2002, 2005-2009 Free Software Foundation, Inc.
+dnl Copyright (C) 2002, 2005-2010 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
--- /dev/null
+++ b/lib/gl/m4/visibility.m4
@@ -0,0 +1,74 @@
+# visibility.m4 serial 3 (gettext-0.18)
+dnl Copyright (C) 2005, 2008-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+dnl Tests whether the compiler supports the command-line option
+dnl -fvisibility=hidden and the function and variable attributes
+dnl __attribute__((__visibility__("hidden"))) and
+dnl __attribute__((__visibility__("default"))).
+dnl Does *not* test for __visibility__("protected") - which has tricky
+dnl semantics (see the 'vismain' test in glibc) and does not exist e.g. on
+dnl MacOS X.
+dnl Does *not* test for __visibility__("internal") - which has processor
+dnl dependent semantics.
+dnl Does *not* test for #pragma GCC visibility push(hidden) - which is
+dnl "really only recommended for legacy code".
+dnl Set the variable CFLAG_VISIBILITY.
+dnl Defines and sets the variable HAVE_VISIBILITY.
+
+AC_DEFUN([gl_VISIBILITY],
+[
+  AC_REQUIRE([AC_PROG_CC])
+  CFLAG_VISIBILITY=
+  HAVE_VISIBILITY=0
+  if test -n "$GCC"; then
+    dnl First, check whether -Werror can be added to the command line, or
+    dnl whether it leads to an error because of some other option that the
+    dnl user has put into $CC $CFLAGS $CPPFLAGS.
+    AC_MSG_CHECKING([whether the -Werror option is usable])
+    AC_CACHE_VAL([gl_cv_cc_vis_werror], [
+      gl_save_CFLAGS="$CFLAGS"
+      CFLAGS="$CFLAGS -Werror"
+      AC_TRY_COMPILE([], [],
+        [gl_cv_cc_vis_werror=yes],
+        [gl_cv_cc_vis_werror=no])
+      CFLAGS="$gl_save_CFLAGS"])
+    AC_MSG_RESULT([$gl_cv_cc_vis_werror])
+    dnl Now check whether visibility declarations are supported.
+    AC_MSG_CHECKING([for simple visibility declarations])
+    AC_CACHE_VAL([gl_cv_cc_visibility], [
+      gl_save_CFLAGS="$CFLAGS"
+      CFLAGS="$CFLAGS -fvisibility=hidden"
+      dnl We use the option -Werror and a function dummyfunc, because on some
+      dnl platforms (Cygwin 1.7) the use of -fvisibility triggers a warning
+      dnl "visibility attribute not supported in this configuration; ignored"
+      dnl at the first function definition in every compilation unit, and we
+      dnl don't want to use the option in this case.
+      if test $gl_cv_cc_vis_werror = yes; then
+        CFLAGS="$CFLAGS -Werror"
+      fi
+      AC_TRY_COMPILE(
+        [extern __attribute__((__visibility__("hidden"))) int hiddenvar;
+         extern __attribute__((__visibility__("default"))) int exportedvar;
+         extern __attribute__((__visibility__("hidden"))) int hiddenfunc (void);
+         extern __attribute__((__visibility__("default"))) int exportedfunc (void);
+         void dummyfunc (void) {}],
+        [],
+        [gl_cv_cc_visibility=yes],
+        [gl_cv_cc_visibility=no])
+      CFLAGS="$gl_save_CFLAGS"])
+    AC_MSG_RESULT([$gl_cv_cc_visibility])
+    if test $gl_cv_cc_visibility = yes; then
+      CFLAG_VISIBILITY="-fvisibility=hidden"
+      HAVE_VISIBILITY=1
+    fi
+  fi
+  AC_SUBST([CFLAG_VISIBILITY])
+  AC_SUBST([HAVE_VISIBILITY])
+  AC_DEFINE_UNQUOTED([HAVE_VISIBILITY], [$HAVE_VISIBILITY],
+    [Define to 1 or 0, depending whether the compiler supports simple visibility declarations.])
+])
--- /dev/null
+++ b/lib/gl/m4/warn-on-use.m4
@@ -0,0 +1,45 @@
+# warn-on-use.m4 serial 2
+dnl Copyright (C) 2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# gl_WARN_ON_USE_PREPARE(INCLUDES, NAMES)
+# ---------------------------------------
+# For each whitespace-separated element in the list of NAMES, define
+# HAVE_RAW_DECL_name if the function has a declaration among INCLUDES
+# even after being undefined as a macro.
+#
+# See warn-on-use.h for some hints on how to poison function names, as
+# well as ideas on poisoning global variables and macros.  NAMES may
+# include global variables, but remember that only functions work with
+# _GL_WARN_ON_USE.  Typically, INCLUDES only needs to list a single
+# header, but if the replacement header pulls in other headers because
+# some systems declare functions in the wrong header, then INCLUDES
+# should do likewise.
+#
+# If you assume C89, then it is generally safe to assume declarations
+# for functions declared in that standard (such as gets) without
+# needing gl_WARN_ON_USE_PREPARE.
+AC_DEFUN([gl_WARN_ON_USE_PREPARE],
+[
+  m4_foreach_w([gl_decl], [$2],
+    [AH_TEMPLATE([HAVE_RAW_DECL_]AS_TR_CPP(m4_defn([gl_decl])),
+      [Define to 1 if ]m4_defn([gl_decl])[ is declared even after
+       undefining macros.])])dnl
+  for gl_func in m4_flatten([$2]); do
+    AS_VAR_PUSHDEF([gl_Symbol], [gl_cv_have_raw_decl_$gl_func])dnl
+    AC_CACHE_CHECK([whether $gl_func is declared without a macro],
+      gl_Symbol,
+      [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([$1],
+[@%:@undef $gl_func
+  (void) $gl_func;])],
+        [AS_VAR_SET(gl_Symbol, [yes])], [AS_VAR_SET(gl_Symbol, [no])])])
+     AS_VAR_IF(gl_Symbol, [yes],
+       [AC_DEFINE_UNQUOTED(AS_TR_CPP([HAVE_RAW_DECL_$gl_func]), [1])
+       dnl shortcut - if the raw declaration exists, then set a cache
+       dnl variable to allow skipping any later AC_CHECK_DECL efforts
+       eval ac_cv_have_decl_$gl_func=yes])
+    AS_VAR_POPDEF([gl_Symbol])dnl
+  done
+])
--- a/lib/gl/m4/wchar.m4
+++ /dev/null
@@ -1,100 +0,0 @@
-dnl A placeholder for ISO C99 <wchar.h>, for platforms that have issues.
-
-dnl Copyright (C) 2007-2009 Free Software Foundation, Inc.
-dnl This file is free software; the Free Software Foundation
-dnl gives unlimited permission to copy and/or distribute it,
-dnl with or without modifications, as long as this notice is preserved.
-
-dnl Written by Eric Blake.
-
-# wchar.m4 serial 23
-
-AC_DEFUN([gl_WCHAR_H],
-[
-  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])
-  AC_CACHE_CHECK([whether <wchar.h> is standalone],
-    [gl_cv_header_wchar_h_standalone],
-    [AC_COMPILE_IFELSE([[#include <wchar.h>
-wchar_t w;]],
-      [gl_cv_header_wchar_h_standalone=yes],
-      [gl_cv_header_wchar_h_standalone=no])])
-
-  AC_REQUIRE([gt_TYPE_WINT_T])
-  if test $gt_cv_c_wint_t = yes; then
-    HAVE_WINT_T=1
-  else
-    HAVE_WINT_T=0
-  fi
-  AC_SUBST([HAVE_WINT_T])
-
-  if test $gl_cv_header_wchar_h_standalone != yes || test $gt_cv_c_wint_t != yes; then
-    WCHAR_H=wchar.h
-  fi
-
-  dnl Prepare for creating substitute <wchar.h>.
-  dnl Do it always: WCHAR_H may be empty here but can be set later.
-  dnl Check for <wchar.h> (missing in Linux uClibc when built without wide
-  dnl character support).
-  AC_CHECK_HEADERS_ONCE([wchar.h])
-  if test $ac_cv_header_wchar_h = yes; then
-    HAVE_WCHAR_H=1
-  else
-    HAVE_WCHAR_H=0
-  fi
-  AC_SUBST([HAVE_WCHAR_H])
-  gl_CHECK_NEXT_HEADERS([wchar.h])
-])
-
-dnl Unconditionally enables the replacement of <wchar.h>.
-AC_DEFUN([gl_REPLACE_WCHAR_H],
-[
-  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])
-  WCHAR_H=wchar.h
-])
-
-AC_DEFUN([gl_WCHAR_MODULE_INDICATOR],
-[
-  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
-  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])
-  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
-])
-
-AC_DEFUN([gl_WCHAR_H_DEFAULTS],
-[
-  GNULIB_BTOWC=0;      AC_SUBST([GNULIB_BTOWC])
-  GNULIB_WCTOB=0;      AC_SUBST([GNULIB_WCTOB])
-  GNULIB_MBSINIT=0;    AC_SUBST([GNULIB_MBSINIT])
-  GNULIB_MBRTOWC=0;    AC_SUBST([GNULIB_MBRTOWC])
-  GNULIB_MBRLEN=0;     AC_SUBST([GNULIB_MBRLEN])
-  GNULIB_MBSRTOWCS=0;  AC_SUBST([GNULIB_MBSRTOWCS])
-  GNULIB_MBSNRTOWCS=0; AC_SUBST([GNULIB_MBSNRTOWCS])
-  GNULIB_WCRTOMB=0;    AC_SUBST([GNULIB_WCRTOMB])
-  GNULIB_WCSRTOMBS=0;  AC_SUBST([GNULIB_WCSRTOMBS])
-  GNULIB_WCSNRTOMBS=0; AC_SUBST([GNULIB_WCSNRTOMBS])
-  GNULIB_WCWIDTH=0;    AC_SUBST([GNULIB_WCWIDTH])
-  dnl Assume proper GNU behavior unless another module says otherwise.
-  HAVE_BTOWC=1;         AC_SUBST([HAVE_BTOWC])
-  HAVE_MBSINIT=1;       AC_SUBST([HAVE_MBSINIT])
-  HAVE_MBRTOWC=1;       AC_SUBST([HAVE_MBRTOWC])
-  HAVE_MBRLEN=1;        AC_SUBST([HAVE_MBRLEN])
-  HAVE_MBSRTOWCS=1;     AC_SUBST([HAVE_MBSRTOWCS])
-  HAVE_MBSNRTOWCS=1;    AC_SUBST([HAVE_MBSNRTOWCS])
-  HAVE_WCRTOMB=1;       AC_SUBST([HAVE_WCRTOMB])
-  HAVE_WCSRTOMBS=1;     AC_SUBST([HAVE_WCSRTOMBS])
-  HAVE_WCSNRTOMBS=1;    AC_SUBST([HAVE_WCSNRTOMBS])
-  HAVE_DECL_WCTOB=1;    AC_SUBST([HAVE_DECL_WCTOB])
-  HAVE_DECL_WCWIDTH=1;  AC_SUBST([HAVE_DECL_WCWIDTH])
-  REPLACE_MBSTATE_T=0;  AC_SUBST([REPLACE_MBSTATE_T])
-  REPLACE_BTOWC=0;      AC_SUBST([REPLACE_BTOWC])
-  REPLACE_WCTOB=0;      AC_SUBST([REPLACE_WCTOB])
-  REPLACE_MBSINIT=0;    AC_SUBST([REPLACE_MBSINIT])
-  REPLACE_MBRTOWC=0;    AC_SUBST([REPLACE_MBRTOWC])
-  REPLACE_MBRLEN=0;     AC_SUBST([REPLACE_MBRLEN])
-  REPLACE_MBSRTOWCS=0;  AC_SUBST([REPLACE_MBSRTOWCS])
-  REPLACE_MBSNRTOWCS=0; AC_SUBST([REPLACE_MBSNRTOWCS])
-  REPLACE_WCRTOMB=0;    AC_SUBST([REPLACE_WCRTOMB])
-  REPLACE_WCSRTOMBS=0;  AC_SUBST([REPLACE_WCSRTOMBS])
-  REPLACE_WCSNRTOMBS=0; AC_SUBST([REPLACE_WCSNRTOMBS])
-  REPLACE_WCWIDTH=0;    AC_SUBST([REPLACE_WCWIDTH])
-  WCHAR_H='';           AC_SUBST([WCHAR_H])
-])
--- /dev/null
+++ b/lib/gl/m4/wchar_h.m4
@@ -0,0 +1,152 @@
+dnl A placeholder for ISO C99 <wchar.h>, for platforms that have issues.
+
+dnl Copyright (C) 2007-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Written by Eric Blake.
+
+# wchar_h.m4 serial 33
+
+AC_DEFUN([gl_WCHAR_H],
+[
+  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])
+  AC_REQUIRE([gl_WCHAR_H_INLINE_OK])
+  dnl Prepare for creating substitute <wchar.h>.
+  dnl Check for <wchar.h> (missing in Linux uClibc when built without wide
+  dnl character support).
+  dnl <wchar.h> is always overridden, because of GNULIB_POSIXCHECK.
+  AC_CHECK_HEADERS_ONCE([wchar.h])
+  gl_CHECK_NEXT_HEADERS([wchar.h])
+  if test $ac_cv_header_wchar_h = yes; then
+    HAVE_WCHAR_H=1
+  else
+    HAVE_WCHAR_H=0
+  fi
+  AC_SUBST([HAVE_WCHAR_H])
+
+  AC_REQUIRE([gt_TYPE_WINT_T])
+  if test $gt_cv_c_wint_t = yes; then
+    HAVE_WINT_T=1
+  else
+    HAVE_WINT_T=0
+  fi
+  AC_SUBST([HAVE_WINT_T])
+
+  dnl Check for declarations of anything we want to poison if the
+  dnl corresponding gnulib module is not in use.
+  gl_WARN_ON_USE_PREPARE([[
+/* Some systems require additional headers.  */
+#ifndef __GLIBC__
+# include <stddef.h>
+# include <stdio.h>
+# include <time.h>
+#endif
+#include <wchar.h>
+    ]], [btowc wctob mbsinit mbrtowc mbrlen mbsrtowcs mbsnrtowcs wcrtomb
+    wcsrtombs wcsnrtombs wcwidth])
+])
+
+dnl Check whether <wchar.h> is usable at all.
+AC_DEFUN([gl_WCHAR_H_INLINE_OK],
+[
+  dnl Test whether <wchar.h> suffers due to the transition from '__inline' to
+  dnl 'gnu_inline'. See <http://sourceware.org/bugzilla/show_bug.cgi?id=4022>
+  dnl and <http://gcc.gnu.org/bugzilla/show_bug.cgi?id=42440>. In summary,
+  dnl glibc version 2.5 or older, together with gcc version 4.3 or newer and
+  dnl the option -std=c99 or -std=gnu99, leads to a broken <wchar.h>.
+  AC_CACHE_CHECK([whether <wchar.h> uses 'inline' correctly],
+    [gl_cv_header_wchar_h_correct_inline],
+    [gl_cv_header_wchar_h_correct_inline=yes
+     AC_LANG_CONFTEST([
+       AC_LANG_SOURCE([[#define wcstod renamed_wcstod
+#include <wchar.h>
+extern int zero (void);
+int main () { return zero(); }
+]])])
+     if AC_TRY_EVAL([ac_compile]); then
+       mv conftest.$ac_objext conftest1.$ac_objext
+       AC_LANG_CONFTEST([
+         AC_LANG_SOURCE([[#define wcstod renamed_wcstod
+#include <wchar.h>
+int zero (void) { return 0; }
+]])])
+       if AC_TRY_EVAL([ac_compile]); then
+         mv conftest.$ac_objext conftest2.$ac_objext
+         if $CC -o conftest$ac_exeext $CFLAGS $LDFLAGS conftest1.$ac_objext conftest2.$ac_objext $LIBS >&AS_MESSAGE_LOG_FD 2>&1; then
+           :
+         else
+           gl_cv_header_wchar_h_correct_inline=no
+         fi
+       fi
+     fi
+     rm -f conftest1.$ac_objext conftest2.$ac_objext conftest$ac_exeext
+    ])
+  if test $gl_cv_header_wchar_h_correct_inline = no; then
+    AC_MSG_ERROR([<wchar.h> cannot be used with this compiler ($CC $CFLAGS $CPPFLAGS).
+This is a known interoperability problem of glibc <= 2.5 with gcc >= 4.3 in
+C99 mode. You have four options:
+  - Add the flag -fgnu89-inline to CC and reconfigure, or
+  - Fix your include files, using parts of
+    <http://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b037a293a48718af30d706c2e18c929d0e69a621>, or
+  - Use a gcc version older than 4.3, or
+  - Don't use the flags -std=c99 or -std=gnu99.
+Configuration aborted.])
+  fi
+])
+
+dnl Unconditionally enables the replacement of <wchar.h>.
+AC_DEFUN([gl_REPLACE_WCHAR_H],
+[
+  dnl This is a no-op, because <wchar.h> is always overridden.
+  :
+])
+
+AC_DEFUN([gl_WCHAR_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])
+  gl_MODULE_INDICATOR_SET_VARIABLE([$1])
+  dnl Define it also as a C macro, for the benefit of the unit tests.
+  gl_MODULE_INDICATOR_FOR_TESTS([$1])
+])
+
+AC_DEFUN([gl_WCHAR_H_DEFAULTS],
+[
+  GNULIB_BTOWC=0;      AC_SUBST([GNULIB_BTOWC])
+  GNULIB_WCTOB=0;      AC_SUBST([GNULIB_WCTOB])
+  GNULIB_MBSINIT=0;    AC_SUBST([GNULIB_MBSINIT])
+  GNULIB_MBRTOWC=0;    AC_SUBST([GNULIB_MBRTOWC])
+  GNULIB_MBRLEN=0;     AC_SUBST([GNULIB_MBRLEN])
+  GNULIB_MBSRTOWCS=0;  AC_SUBST([GNULIB_MBSRTOWCS])
+  GNULIB_MBSNRTOWCS=0; AC_SUBST([GNULIB_MBSNRTOWCS])
+  GNULIB_WCRTOMB=0;    AC_SUBST([GNULIB_WCRTOMB])
+  GNULIB_WCSRTOMBS=0;  AC_SUBST([GNULIB_WCSRTOMBS])
+  GNULIB_WCSNRTOMBS=0; AC_SUBST([GNULIB_WCSNRTOMBS])
+  GNULIB_WCWIDTH=0;    AC_SUBST([GNULIB_WCWIDTH])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_BTOWC=1;         AC_SUBST([HAVE_BTOWC])
+  HAVE_MBSINIT=1;       AC_SUBST([HAVE_MBSINIT])
+  HAVE_MBRTOWC=1;       AC_SUBST([HAVE_MBRTOWC])
+  HAVE_MBRLEN=1;        AC_SUBST([HAVE_MBRLEN])
+  HAVE_MBSRTOWCS=1;     AC_SUBST([HAVE_MBSRTOWCS])
+  HAVE_MBSNRTOWCS=1;    AC_SUBST([HAVE_MBSNRTOWCS])
+  HAVE_WCRTOMB=1;       AC_SUBST([HAVE_WCRTOMB])
+  HAVE_WCSRTOMBS=1;     AC_SUBST([HAVE_WCSRTOMBS])
+  HAVE_WCSNRTOMBS=1;    AC_SUBST([HAVE_WCSNRTOMBS])
+  HAVE_DECL_WCTOB=1;    AC_SUBST([HAVE_DECL_WCTOB])
+  HAVE_DECL_WCWIDTH=1;  AC_SUBST([HAVE_DECL_WCWIDTH])
+  REPLACE_MBSTATE_T=0;  AC_SUBST([REPLACE_MBSTATE_T])
+  REPLACE_BTOWC=0;      AC_SUBST([REPLACE_BTOWC])
+  REPLACE_WCTOB=0;      AC_SUBST([REPLACE_WCTOB])
+  REPLACE_MBSINIT=0;    AC_SUBST([REPLACE_MBSINIT])
+  REPLACE_MBRTOWC=0;    AC_SUBST([REPLACE_MBRTOWC])
+  REPLACE_MBRLEN=0;     AC_SUBST([REPLACE_MBRLEN])
+  REPLACE_MBSRTOWCS=0;  AC_SUBST([REPLACE_MBSRTOWCS])
+  REPLACE_MBSNRTOWCS=0; AC_SUBST([REPLACE_MBSNRTOWCS])
+  REPLACE_WCRTOMB=0;    AC_SUBST([REPLACE_WCRTOMB])
+  REPLACE_WCSRTOMBS=0;  AC_SUBST([REPLACE_WCSRTOMBS])
+  REPLACE_WCSNRTOMBS=0; AC_SUBST([REPLACE_WCSNRTOMBS])
+  REPLACE_WCWIDTH=0;    AC_SUBST([REPLACE_WCWIDTH])
+])
--- /dev/null
+++ b/lib/gl/m4/wchar_t.m4
@@ -0,0 +1,20 @@
+# wchar_t.m4 serial 3 (gettext-0.18)
+dnl Copyright (C) 2002-2003, 2008-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+dnl Test whether <stddef.h> has the 'wchar_t' type.
+dnl Prerequisite: AC_PROG_CC
+
+AC_DEFUN([gt_TYPE_WCHAR_T],
+[
+  AC_CACHE_CHECK([for wchar_t], [gt_cv_c_wchar_t],
+    [AC_TRY_COMPILE([#include <stddef.h>
+       wchar_t foo = (wchar_t)'\0';], ,
+       [gt_cv_c_wchar_t=yes], [gt_cv_c_wchar_t=no])])
+  if test $gt_cv_c_wchar_t = yes; then
+    AC_DEFINE([HAVE_WCHAR_T], [1], [Define if you have the 'wchar_t' type.])
+  fi
+])
--- /dev/null
+++ b/lib/gl/m4/wint_t.m4
@@ -0,0 +1,28 @@
+# wint_t.m4 serial 4 (gettext-0.18)
+dnl Copyright (C) 2003, 2007-2010 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+dnl Test whether <wchar.h> has the 'wint_t' type.
+dnl Prerequisite: AC_PROG_CC
+
+AC_DEFUN([gt_TYPE_WINT_T],
+[
+  AC_CACHE_CHECK([for wint_t], [gt_cv_c_wint_t],
+    [AC_TRY_COMPILE([
+/* Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
+   <wchar.h>.
+   BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be included
+   before <wchar.h>.  */
+#include <stddef.h>
+#include <stdio.h>
+#include <time.h>
+#include <wchar.h>
+       wint_t foo = (wchar_t)'\0';], ,
+       [gt_cv_c_wint_t=yes], [gt_cv_c_wint_t=no])])
+  if test $gt_cv_c_wint_t = yes; then
+    AC_DEFINE([HAVE_WINT_T], [1], [Define if you have the 'wint_t' type.])
+  fi
+])
--- a/lib/gl/stdbool.in.h
+++ b/lib/gl/stdbool.in.h
@@ -1,9 +1,9 @@
-/* Copyright (C) 2001-2003, 2006-2008 Free Software Foundation, Inc.
+/* Copyright (C) 2001-2003, 2006-2010 Free Software Foundation, Inc.
    Written by Bruno Haible <haible@clisp.cons.org>, 2001.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -50,6 +50,9 @@
          with this substitute.  With this substitute, only the values 0 and 1
          give the expected result when converted to _Bool' or 'bool'.
 
+       - C99 allows the use of (_Bool)0.0 in constant expressions, but
+         this substitute cannot always provide this property.
+
    Also, it is suggested that programs use 'bool' rather than '_Bool';
    this isn't required, but 'bool' is more common.  */
 
--- /dev/null
+++ b/lib/gl/stddef.in.h
@@ -0,0 +1,86 @@
+/* A substitute for POSIX 2008 <stddef.h>, for platforms that have issues.
+
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Written by Eric Blake.  */
+
+/*
+ * POSIX 2008 <stddef.h> for platforms that have issues.
+ * <http://www.opengroup.org/susv3xbd/stddef.h.html>
+ */
+
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
+#if defined __need_wchar_t || defined __need_size_t  \
+  || defined __need_ptrdiff_t || defined __need_NULL \
+  || defined __need_wint_t
+/* Special invocation convention inside gcc header files.  In
+   particular, gcc provides a version of <stddef.h> that blindly
+   redefines NULL even when __need_wint_t was defined, even though
+   wint_t is not normally provided by <stddef.h>.  Hence, we must
+   remember if special invocation has ever been used to obtain wint_t,
+   in which case we need to clean up NULL yet again.  */
+
+# if !(defined _GL_STDDEF_H && defined _GL_STDDEF_WINT_T)
+#  ifdef __need_wint_t
+#   undef _GL_STDDEF_H
+#   define _GL_STDDEF_WINT_T
+#  endif
+#  @INCLUDE_NEXT@ @NEXT_STDDEF_H@
+# endif
+
+#else
+/* Normal invocation convention.  */
+
+# ifndef _GL_STDDEF_H
+
+/* The include_next requires a split double-inclusion guard.  */
+
+#  @INCLUDE_NEXT@ @NEXT_STDDEF_H@
+
+#  ifndef _GL_STDDEF_H
+#   define _GL_STDDEF_H
+
+/* On NetBSD 5.0, the definition of NULL lacks proper parentheses.  */
+#if @REPLACE_NULL@
+# undef NULL
+# ifdef __cplusplus
+   /* ISO C++ says that the macro NULL must expand to an integer constant
+      expression, hence '((void *) 0)' is not allowed in C++.  */
+#  if __GNUG__ >= 3
+    /* GNU C++ has a __null macro that behaves like an integer ('int' or
+       'long') but has the same size as a pointer.  Use that, to avoid
+       warnings.  */
+#   define NULL __null
+#  else
+#   define NULL 0L
+#  endif
+# else
+#  define NULL ((void *) 0)
+# endif
+#endif
+
+/* Some platforms lack wchar_t.  */
+#if !@HAVE_WCHAR_T@
+# define wchar_t int
+#endif
+
+#  endif /* _GL_STDDEF_H */
+# endif /* _GL_STDDEF_H */
+#endif /* __need_XXX */
--- a/lib/gl/stdint.in.h
+++ b/lib/gl/stdint.in.h
@@ -1,10 +1,10 @@
-/* Copyright (C) 2001-2002, 2004-2009 Free Software Foundation, Inc.
+/* Copyright (C) 2001-2002, 2004-2010 Free Software Foundation, Inc.
    Written by Paul Eggert, Bruno Haible, Sam Steingold, Peter Burwood.
    This file is part of gnulib.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -23,6 +23,10 @@
 
 #ifndef _GL_STDINT_H
 
+#if __GNUC__ >= 3
+@PRAGMA_SYSTEM_HEADER@
+#endif
+
 /* When including a system file that in turn includes <inttypes.h>,
    use the system <inttypes.h>, not our substitute.  This avoids
    problems with (for example) VMS, whose <sys/bitypes.h> includes
@@ -49,9 +53,6 @@
      in <inttypes.h> would reinclude us, skipping our contents because
      _GL_STDINT_H is defined.
      The include_next requires a split double-inclusion guard.  */
-# if __GNUC__ >= 3
-@PRAGMA_SYSTEM_HEADER@
-# endif
 # @INCLUDE_NEXT@ @NEXT_STDINT_H@
 #endif
 
@@ -102,8 +103,8 @@
   ((signed) \
    ? ~ _STDINT_MIN (signed, bits, zero) \
    : /* The expression for the unsigned case.  The subtraction of (signed) \
-	is a nop in the unsigned case and avoids "signed integer overflow" \
-	warnings in the signed case.  */ \
+        is a nop in the unsigned case and avoids "signed integer overflow" \
+        warnings in the signed case.  */ \
      ((((zero) + 1) << ((bits) ? (bits) - 1 - (signed) : 0)) - 1) * 2 + 1)
 
 /* 7.18.1.1. Exact-width integer types */
@@ -454,10 +455,10 @@ typedef int _verify_intmax_size[2 * (siz
 #undef SIG_ATOMIC_MAX
 #define SIG_ATOMIC_MIN  \
    _STDINT_MIN (@HAVE_SIGNED_SIG_ATOMIC_T@, @BITSIZEOF_SIG_ATOMIC_T@, \
-		0@SIG_ATOMIC_T_SUFFIX@)
+                0@SIG_ATOMIC_T_SUFFIX@)
 #define SIG_ATOMIC_MAX  \
    _STDINT_MAX (@HAVE_SIGNED_SIG_ATOMIC_T@, @BITSIZEOF_SIG_ATOMIC_T@, \
-		0@SIG_ATOMIC_T_SUFFIX@)
+                0@SIG_ATOMIC_T_SUFFIX@)
 
 
 /* size_t limit */
@@ -479,8 +480,7 @@ typedef int _verify_intmax_size[2 * (siz
    <stdint.h> and assumes its types are already defined.  */
 #if ! (defined WCHAR_MIN && defined WCHAR_MAX)
 # define _GL_JUST_INCLUDE_SYSTEM_WCHAR_H
-/*  We don't need WCHAR_* in libidn, so to avoid problems with
-    missing wchar.h, don't include wchar.h here.  */
+# include <wchar.h>
 # undef _GL_JUST_INCLUDE_SYSTEM_WCHAR_H
 #endif
 #undef WCHAR_MIN
--- a/lib/gl/striconv.c
+++ b/lib/gl/striconv.c
@@ -1,10 +1,10 @@
 /* Charset conversion.
-   Copyright (C) 2001-2007 Free Software Foundation, Inc.
+   Copyright (C) 2001-2007, 2009-2010 Free Software Foundation, Inc.
    Written by Bruno Haible and Simon Josefsson.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -42,7 +42,7 @@
 
 int
 mem_cd_iconv (const char *src, size_t srclen, iconv_t cd,
-	      char **resultp, size_t *lengthp)
+              char **resultp, size_t *lengthp)
 {
 # define tmpbufsize 4096
   size_t length;
@@ -67,33 +67,33 @@ mem_cd_iconv (const char *src, size_t sr
 
     while (insize > 0)
       {
-	char *outptr = tmpbuf;
-	size_t outsize = tmpbufsize;
-	size_t res = iconv (cd,
-			    (ICONV_CONST char **) &inptr, &insize,
-			    &outptr, &outsize);
-
-	if (res == (size_t)(-1))
-	  {
-	    if (errno == E2BIG)
-	      ;
-	    else if (errno == EINVAL)
-	      break;
-	    else
-	      return -1;
-	  }
+        char *outptr = tmpbuf;
+        size_t outsize = tmpbufsize;
+        size_t res = iconv (cd,
+                            (ICONV_CONST char **) &inptr, &insize,
+                            &outptr, &outsize);
+
+        if (res == (size_t)(-1))
+          {
+            if (errno == E2BIG)
+              ;
+            else if (errno == EINVAL)
+              break;
+            else
+              return -1;
+          }
 # if !defined _LIBICONV_VERSION && !defined __GLIBC__
-	/* Irix iconv() inserts a NUL byte if it cannot convert.
-	   NetBSD iconv() inserts a question mark if it cannot convert.
-	   Only GNU libiconv and GNU libc are known to prefer to fail rather
-	   than doing a lossy conversion.  */
-	else if (res > 0)
-	  {
-	    errno = EILSEQ;
-	    return -1;
-	  }
+        /* Irix iconv() inserts a NUL byte if it cannot convert.
+           NetBSD iconv() inserts a question mark if it cannot convert.
+           Only GNU libiconv and GNU libc are known to prefer to fail rather
+           than doing a lossy conversion.  */
+        else if (res > 0)
+          {
+            errno = EILSEQ;
+            return -1;
+          }
 # endif
-	count += outptr - tmpbuf;
+        count += outptr - tmpbuf;
       }
     /* Avoid glibc-2.1 bug and Solaris 2.7 bug.  */
 # if defined _LIBICONV_VERSION \
@@ -104,7 +104,7 @@ mem_cd_iconv (const char *src, size_t sr
       size_t res = iconv (cd, NULL, NULL, &outptr, &outsize);
 
       if (res == (size_t)(-1))
-	return -1;
+        return -1;
       count += outptr - tmpbuf;
     }
 # endif
@@ -123,10 +123,10 @@ mem_cd_iconv (const char *src, size_t sr
     {
       result = (char *) malloc (length);
       if (result == NULL)
-	{
-	  errno = ENOMEM;
-	  return -1;
-	}
+        {
+          errno = ENOMEM;
+          return -1;
+        }
     }
 
   /* Avoid glibc-2.1 bug and Solaris 2.7-2.9 bug.  */
@@ -145,27 +145,27 @@ mem_cd_iconv (const char *src, size_t sr
 
     while (insize > 0)
       {
-	size_t res = iconv (cd,
-			    (ICONV_CONST char **) &inptr, &insize,
-			    &outptr, &outsize);
-
-	if (res == (size_t)(-1))
-	  {
-	    if (errno == EINVAL)
-	      break;
-	    else
-	      goto fail;
-	  }
+        size_t res = iconv (cd,
+                            (ICONV_CONST char **) &inptr, &insize,
+                            &outptr, &outsize);
+
+        if (res == (size_t)(-1))
+          {
+            if (errno == EINVAL)
+              break;
+            else
+              goto fail;
+          }
 # if !defined _LIBICONV_VERSION && !defined __GLIBC__
-	/* Irix iconv() inserts a NUL byte if it cannot convert.
-	   NetBSD iconv() inserts a question mark if it cannot convert.
-	   Only GNU libiconv and GNU libc are known to prefer to fail rather
-	   than doing a lossy conversion.  */
-	else if (res > 0)
-	  {
-	    errno = EILSEQ;
-	    goto fail;
-	  }
+        /* Irix iconv() inserts a NUL byte if it cannot convert.
+           NetBSD iconv() inserts a question mark if it cannot convert.
+           Only GNU libiconv and GNU libc are known to prefer to fail rather
+           than doing a lossy conversion.  */
+        else if (res > 0)
+          {
+            errno = EILSEQ;
+            goto fail;
+          }
 # endif
       }
     /* Avoid glibc-2.1 bug and Solaris 2.7 bug.  */
@@ -175,7 +175,7 @@ mem_cd_iconv (const char *src, size_t sr
       size_t res = iconv (cd, NULL, NULL, &outptr, &outsize);
 
       if (res == (size_t)(-1))
-	goto fail;
+        goto fail;
     }
 # endif
     if (outsize != 0)
@@ -191,9 +191,9 @@ mem_cd_iconv (const char *src, size_t sr
   {
     if (result != *resultp)
       {
-	int saved_errno = errno;
-	free (result);
-	errno = saved_errno;
+        int saved_errno = errno;
+        free (result);
+        errno = saved_errno;
       }
     return -1;
   }
@@ -224,7 +224,7 @@ str_cd_iconv (const char *src, iconv_t c
   if (retval < 0)
     {
       if (result != NULL)
-	abort ();
+        abort ();
       return NULL;
     }
 
@@ -233,8 +233,7 @@ str_cd_iconv (const char *src, iconv_t c
     (result != NULL ? realloc (result, length + 1) : malloc (length + 1));
   if (final_result == NULL)
     {
-      if (result != NULL)
-	free (result);
+      free (result);
       errno = ENOMEM;
       return NULL;
     }
@@ -285,81 +284,81 @@ str_cd_iconv (const char *src, iconv_t c
 
     for (;;)
       {
-	/* Here inptr + inbytes_remaining = src + strlen (src),
-		outptr + outbytes_remaining = result + result_size - 1.  */
-	size_t res = iconv (cd,
-			    (ICONV_CONST char **) &inptr, &inbytes_remaining,
-			    &outptr, &outbytes_remaining);
-
-	if (res == (size_t)(-1))
-	  {
-	    if (errno == EINVAL)
-	      break;
-	    else if (errno == E2BIG)
-	      {
-		size_t used = outptr - result;
-		size_t newsize = result_size * 2;
-		char *newresult;
-
-		if (!(newsize > result_size))
-		  {
-		    errno = ENOMEM;
-		    goto failed;
-		  }
-		newresult = (char *) realloc (result, newsize);
-		if (newresult == NULL)
-		  {
-		    errno = ENOMEM;
-		    goto failed;
-		  }
-		result = newresult;
-		result_size = newsize;
-		outptr = result + used;
-		outbytes_remaining = result_size - 1 - used;
-	      }
-	    else
-	      goto failed;
-	  }
-	else
-	  break;
+        /* Here inptr + inbytes_remaining = src + strlen (src),
+                outptr + outbytes_remaining = result + result_size - 1.  */
+        size_t res = iconv (cd,
+                            (ICONV_CONST char **) &inptr, &inbytes_remaining,
+                            &outptr, &outbytes_remaining);
+
+        if (res == (size_t)(-1))
+          {
+            if (errno == EINVAL)
+              break;
+            else if (errno == E2BIG)
+              {
+                size_t used = outptr - result;
+                size_t newsize = result_size * 2;
+                char *newresult;
+
+                if (!(newsize > result_size))
+                  {
+                    errno = ENOMEM;
+                    goto failed;
+                  }
+                newresult = (char *) realloc (result, newsize);
+                if (newresult == NULL)
+                  {
+                    errno = ENOMEM;
+                    goto failed;
+                  }
+                result = newresult;
+                result_size = newsize;
+                outptr = result + used;
+                outbytes_remaining = result_size - 1 - used;
+              }
+            else
+              goto failed;
+          }
+        else
+          break;
       }
     /* Avoid glibc-2.1 bug and Solaris 2.7 bug.  */
 # if defined _LIBICONV_VERSION \
      || !((__GLIBC__ - 0 == 2 && __GLIBC_MINOR__ - 0 <= 1) || defined __sun)
     for (;;)
       {
-	/* Here outptr + outbytes_remaining = result + result_size - 1.  */
-	size_t res = iconv (cd, NULL, NULL, &outptr, &outbytes_remaining);
+        /* Here outptr + outbytes_remaining = result + result_size - 1.  */
+        size_t res = iconv (cd, NULL, NULL, &outptr, &outbytes_remaining);
 
-	if (res == (size_t)(-1))
-	  {
-	    if (errno == E2BIG)
-	      {
-		size_t used = outptr - result;
-		size_t newsize = result_size * 2;
-		char *newresult;
-
-		if (!(newsize > result_size))
-		  {
-		    errno = ENOMEM;
-		    goto failed;
-		  }
-		newresult = (char *) realloc (result, newsize);
-		if (newresult == NULL)
-		  {
-		    errno = ENOMEM;
-		    goto failed;
-		  }
-		result = newresult;
-		result_size = newsize;
-		outptr = result + used;
-		outbytes_remaining = result_size - 1 - used;
-	      }
-	    else
-	      goto failed;
-	  }
-	else
-	  break;
+        if (res == (size_t)(-1))
+          {
+            if (errno == E2BIG)
+              {
+                size_t used = outptr - result;
+                size_t newsize = result_size * 2;
+                char *newresult;
+
+                if (!(newsize > result_size))
+                  {
+                    errno = ENOMEM;
+                    goto failed;
+                  }
+                newresult = (char *) realloc (result, newsize);
+                if (newresult == NULL)
+                  {
+                    errno = ENOMEM;
+                    goto failed;
+                  }
+                result = newresult;
+                result_size = newsize;
+                outptr = result + used;
+                outbytes_remaining = result_size - 1 - used;
+              }
+            else
+              goto failed;
+          }
+        else
+          break;
       }
 # endif
 
@@ -375,7 +374,7 @@ str_cd_iconv (const char *src, iconv_t c
       char *smaller_result = (char *) realloc (result, length);
 
       if (smaller_result != NULL)
-	result = smaller_result;
+        result = smaller_result;
     }
 
   return result;
@@ -401,7 +400,7 @@ str_iconv (const char *src, const char *
       char *result = strdup (src);
 
       if (result == NULL)
-	errno = ENOMEM;
+        errno = ENOMEM;
       return result;
     }
   else
@@ -413,44 +412,44 @@ str_iconv (const char *src, const char *
       /* Avoid glibc-2.1 bug with EUC-KR.  */
 # if (__GLIBC__ - 0 == 2 && __GLIBC_MINOR__ - 0 <= 1) && !defined _LIBICONV_VERSION
       if (c_strcasecmp (from_codeset, "EUC-KR") == 0
-	  || c_strcasecmp (to_codeset, "EUC-KR") == 0)
-	{
-	  errno = EINVAL;
-	  return NULL;
-	}
+          || c_strcasecmp (to_codeset, "EUC-KR") == 0)
+        {
+          errno = EINVAL;
+          return NULL;
+        }
 # endif
       cd = iconv_open (to_codeset, from_codeset);
       if (cd == (iconv_t) -1)
-	return NULL;
+        return NULL;
 
       result = str_cd_iconv (src, cd);
 
       if (result == NULL)
-	{
-	  /* Close cd, but preserve the errno from str_cd_iconv.  */
-	  int saved_errno = errno;
-	  iconv_close (cd);
-	  errno = saved_errno;
-	}
+        {
+          /* Close cd, but preserve the errno from str_cd_iconv.  */
+          int saved_errno = errno;
+          iconv_close (cd);
+          errno = saved_errno;
+        }
       else
-	{
-	  if (iconv_close (cd) < 0)
-	    {
-	      /* Return NULL, but free the allocated memory, and while doing
-		 that, preserve the errno from iconv_close.  */
-	      int saved_errno = errno;
-	      free (result);
-	      errno = saved_errno;
-	      return NULL;
-	    }
-	}
+        {
+          if (iconv_close (cd) < 0)
+            {
+              /* Return NULL, but free the allocated memory, and while doing
+                 that, preserve the errno from iconv_close.  */
+              int saved_errno = errno;
+              free (result);
+              errno = saved_errno;
+              return NULL;
+            }
+        }
       return result;
 #else
       /* This is a different error code than if iconv_open existed but didn't
-	 support from_codeset and to_codeset, so that the caller can emit
-	 an error message such as
-	   "iconv() is not supported. Installing GNU libiconv and
-	    then reinstalling this package would fix this."  */
+         support from_codeset and to_codeset, so that the caller can emit
+         an error message such as
+           "iconv() is not supported. Installing GNU libiconv and
+            then reinstalling this package would fix this."  */
       errno = ENOSYS;
       return NULL;
 #endif
--- a/lib/gl/striconv.h
+++ b/lib/gl/striconv.h
@@ -1,10 +1,10 @@
 /* Charset conversion.
-   Copyright (C) 2001-2004, 2006-2007 Free Software Foundation, Inc.
+   Copyright (C) 2001-2004, 2006-2007, 2009-2010 Free Software Foundation, Inc.
    Written by Bruno Haible and Simon Josefsson.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -43,7 +43,7 @@ extern "C" {
    in *LENGTHP.  *RESULTP is set to a freshly allocated memory block, or is
    unchanged if no dynamic memory allocation was necessary.  */
 extern int mem_cd_iconv (const char *src, size_t srclen, iconv_t cd,
-			 char **resultp, size_t *lengthp);
+                         char **resultp, size_t *lengthp);
 
 /* Convert an entire string from one encoding to another, using iconv.
    The original string is the NUL-terminated string starting at SRC.
@@ -65,7 +65,7 @@ extern char * str_cd_iconv (const char *
    Return value: the freshly allocated resulting NUL-terminated string if
    successful, otherwise NULL and errno set.  */
 extern char * str_iconv (const char *src,
-			 const char *from_codeset, const char *to_codeset);
+                         const char *from_codeset, const char *to_codeset);
 
 
 #ifdef __cplusplus
--- a/lib/gl/string.in.h
+++ b/lib/gl/string.in.h
@@ -1,10 +1,10 @@
 /* A GNU-like <string.h>.
 
-   Copyright (C) 1995-1996, 2001-2008 Free Software Foundation, Inc.
+   Copyright (C) 1995-1996, 2001-2010 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -28,73 +28,156 @@
 #ifndef _GL_STRING_H
 #define _GL_STRING_H
 
+/* NetBSD 5.0 mis-defines NULL.  */
+#include <stddef.h>
+
+/* MirBSD defines mbslen as a macro.  */
+#if @GNULIB_MBSLEN@ && defined __MirBSD__
+# include <wchar.h>
+#endif
 
 #ifndef __attribute__
 /* This feature is available in gcc versions 2.5 and later.  */
 # if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5)
 #  define __attribute__(Spec) /* empty */
 # endif
+#endif
 /* The attribute __pure__ was added in gcc 2.96.  */
-# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
-#  define __pure__ /* empty */
-# endif
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)
+# define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
+#else
+# define _GL_ATTRIBUTE_PURE /* empty */
 #endif
 
 
-/* The definition of GL_LINK_WARNING is copied here.  */
-
-
-#ifdef __cplusplus
-extern "C" {
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+
+
+/* Return the first instance of C within N bytes of S, or NULL.  */
+#if @GNULIB_MEMCHR@
+# if @REPLACE_MEMCHR@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define memchr rpl_memchr
+#  endif
+_GL_FUNCDECL_RPL (memchr, void *, (void const *__s, int __c, size_t __n)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (memchr, void *, (void const *__s, int __c, size_t __n));
+# else
+#  if ! @HAVE_MEMCHR@
+_GL_FUNCDECL_SYS (memchr, void *, (void const *__s, int __c, size_t __n)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+#  endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C" { const void * std::memchr (const void *, int, size_t); }
+       extern "C++" { void * std::memchr (void *, int, size_t); }  */
+_GL_CXXALIAS_SYS_CAST2 (memchr,
+                        void *, (void const *__s, int __c, size_t __n),
+                        void const *, (void const *__s, int __c, size_t __n));
+# endif
+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 10 \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (memchr, void *, (void *__s, int __c, size_t __n));
+_GL_CXXALIASWARN1 (memchr, void const *,
+                   (void const *__s, int __c, size_t __n));
+# else
+_GL_CXXALIASWARN (memchr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef memchr
+/* Assume memchr is always declared.  */
+_GL_WARN_ON_USE (memchr, "memchr has platform-specific bugs - "
+                 "use gnulib module memchr for portability" );
 #endif
 
-
 /* Return the first occurrence of NEEDLE in HAYSTACK.  */
 #if @GNULIB_MEMMEM@
 # if @REPLACE_MEMMEM@
-#  define memmem rpl_memmem
-# endif
-# if ! @HAVE_DECL_MEMMEM@ || @REPLACE_MEMMEM@
-extern void *memmem (void const *__haystack, size_t __haystack_len,
-		     void const *__needle, size_t __needle_len)
-  __attribute__ ((__pure__));
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define memmem rpl_memmem
+#  endif
+_GL_FUNCDECL_RPL (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 3)));
+_GL_CXXALIAS_RPL (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len));
+# else
+#  if ! @HAVE_DECL_MEMMEM@
+_GL_FUNCDECL_SYS (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 3)));
+#  endif
+_GL_CXXALIAS_SYS (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len));
 # endif
+_GL_CXXALIASWARN (memmem);
 #elif defined GNULIB_POSIXCHECK
 # undef memmem
-# define memmem(a,al,b,bl) \
-    (GL_LINK_WARNING ("memmem is unportable and often quadratic - " \
-                      "use gnulib module memmem-simple for portability, " \
-                      "and module memmem for speed" ), \
-     memmem (a, al, b, bl))
+# if HAVE_RAW_DECL_MEMMEM
+_GL_WARN_ON_USE (memmem, "memmem is unportable and often quadratic - "
+                 "use gnulib module memmem-simple for portability, "
+                 "and module memmem for speed" );
+# endif
 #endif
 
 /* Copy N bytes of SRC to DEST, return pointer to bytes after the
    last written byte.  */
 #if @GNULIB_MEMPCPY@
 # if ! @HAVE_MEMPCPY@
-extern void *mempcpy (void *restrict __dest, void const *restrict __src,
-		      size_t __n);
-# endif
+_GL_FUNCDECL_SYS (mempcpy, void *,
+                  (void *restrict __dest, void const *restrict __src,
+                   size_t __n)
+                  _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (mempcpy, void *,
+                  (void *restrict __dest, void const *restrict __src,
+                   size_t __n));
+_GL_CXXALIASWARN (mempcpy);
 #elif defined GNULIB_POSIXCHECK
 # undef mempcpy
-# define mempcpy(a,b,n) \
-    (GL_LINK_WARNING ("mempcpy is unportable - " \
-                      "use gnulib module mempcpy for portability"), \
-     mempcpy (a, b, n))
+# if HAVE_RAW_DECL_MEMPCPY
+_GL_WARN_ON_USE (mempcpy, "mempcpy is unportable - "
+                 "use gnulib module mempcpy for portability");
+# endif
 #endif
 
 /* Search backwards through a block for a byte (specified as an int).  */
 #if @GNULIB_MEMRCHR@
 # if ! @HAVE_DECL_MEMRCHR@
-extern void *memrchr (void const *, int, size_t)
-  __attribute__ ((__pure__));
+_GL_FUNCDECL_SYS (memrchr, void *, (void const *, int, size_t)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const void * std::memrchr (const void *, int, size_t); }
+       extern "C++" { void * std::memrchr (void *, int, size_t); }  */
+_GL_CXXALIAS_SYS_CAST2 (memrchr,
+                        void *, (void const *, int, size_t),
+                        void const *, (void const *, int, size_t));
+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 10 \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (memrchr, void *, (void *, int, size_t));
+_GL_CXXALIASWARN1 (memrchr, void const *, (void const *, int, size_t));
+# else
+_GL_CXXALIASWARN (memrchr);
 # endif
 #elif defined GNULIB_POSIXCHECK
 # undef memrchr
-# define memrchr(a,b,c) \
-    (GL_LINK_WARNING ("memrchr is unportable - " \
-                      "use gnulib module memrchr for portability"), \
-     memrchr (a, b, c))
+# if HAVE_RAW_DECL_MEMRCHR
+_GL_WARN_ON_USE (memrchr, "memrchr is unportable - "
+                 "use gnulib module memrchr for portability");
+# endif
 #endif
 
 /* Find the first occurrence of C in S.  More efficient than
@@ -102,119 +185,221 @@ extern void *memrchr (void const *, int,
    occur within N bytes.  */
 #if @GNULIB_RAWMEMCHR@
 # if ! @HAVE_RAWMEMCHR@
-extern void *rawmemchr (void const *__s, int __c_in)
-  __attribute__ ((__pure__));
+_GL_FUNCDECL_SYS (rawmemchr, void *, (void const *__s, int __c_in)
+                                     _GL_ATTRIBUTE_PURE
+                                     _GL_ARG_NONNULL ((1)));
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const void * std::rawmemchr (const void *, int); }
+       extern "C++" { void * std::rawmemchr (void *, int); }  */
+_GL_CXXALIAS_SYS_CAST2 (rawmemchr,
+                        void *, (void const *__s, int __c_in),
+                        void const *, (void const *__s, int __c_in));
+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 10 \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (rawmemchr, void *, (void *__s, int __c_in));
+_GL_CXXALIASWARN1 (rawmemchr, void const *, (void const *__s, int __c_in));
+# else
+_GL_CXXALIASWARN (rawmemchr);
 # endif
 #elif defined GNULIB_POSIXCHECK
 # undef rawmemchr
-# define rawmemchr(a,b) \
-    (GL_LINK_WARNING ("rawmemchr is unportable - " \
-                      "use gnulib module rawmemchr for portability"), \
-     rawmemchr (a, b))
+# if HAVE_RAW_DECL_RAWMEMCHR
+_GL_WARN_ON_USE (rawmemchr, "rawmemchr is unportable - "
+                 "use gnulib module rawmemchr for portability");
+# endif
 #endif
 
 /* Copy SRC to DST, returning the address of the terminating '\0' in DST.  */
 #if @GNULIB_STPCPY@
 # if ! @HAVE_STPCPY@
-extern char *stpcpy (char *restrict __dst, char const *restrict __src);
-# endif
+_GL_FUNCDECL_SYS (stpcpy, char *,
+                  (char *restrict __dst, char const *restrict __src)
+                  _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (stpcpy, char *,
+                  (char *restrict __dst, char const *restrict __src));
+_GL_CXXALIASWARN (stpcpy);
 #elif defined GNULIB_POSIXCHECK
 # undef stpcpy
-# define stpcpy(a,b) \
-    (GL_LINK_WARNING ("stpcpy is unportable - " \
-                      "use gnulib module stpcpy for portability"), \
-     stpcpy (a, b))
+# if HAVE_RAW_DECL_STPCPY
+_GL_WARN_ON_USE (stpcpy, "stpcpy is unportable - "
+                 "use gnulib module stpcpy for portability");
+# endif
 #endif
 
 /* Copy no more than N bytes of SRC to DST, returning a pointer past the
    last non-NUL byte written into DST.  */
 #if @GNULIB_STPNCPY@
-# if ! @HAVE_STPNCPY@
-#  define stpncpy gnu_stpncpy
-extern char *stpncpy (char *restrict __dst, char const *restrict __src,
-		      size_t __n);
+# if @REPLACE_STPNCPY@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define stpncpy rpl_stpncpy
+#  endif
+_GL_FUNCDECL_RPL (stpncpy, char *,
+                  (char *restrict __dst, char const *restrict __src,
+                   size_t __n)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (stpncpy, char *,
+                  (char *restrict __dst, char const *restrict __src,
+                   size_t __n));
+# else
+#  if ! @HAVE_STPNCPY@
+_GL_FUNCDECL_SYS (stpncpy, char *,
+                  (char *restrict __dst, char const *restrict __src,
+                   size_t __n)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (stpncpy, char *,
+                  (char *restrict __dst, char const *restrict __src,
+                   size_t __n));
 # endif
+_GL_CXXALIASWARN (stpncpy);
 #elif defined GNULIB_POSIXCHECK
 # undef stpncpy
-# define stpncpy(a,b,n) \
-    (GL_LINK_WARNING ("stpncpy is unportable - " \
-                      "use gnulib module stpncpy for portability"), \
-     stpncpy (a, b, n))
+# if HAVE_RAW_DECL_STPNCPY
+_GL_WARN_ON_USE (stpncpy, "stpncpy is unportable - "
+                 "use gnulib module stpncpy for portability");
+# endif
 #endif
 
 #if defined GNULIB_POSIXCHECK
 /* strchr() does not work with multibyte strings if the locale encoding is
    GB18030 and the character to be searched is a digit.  */
 # undef strchr
-# define strchr(s,c) \
-    (GL_LINK_WARNING ("strchr cannot work correctly on character strings " \
-                      "in some multibyte locales - " \
-                      "use mbschr if you care about internationalization"), \
-     strchr (s, c))
+/* Assume strchr is always declared.  */
+_GL_WARN_ON_USE (strchr, "strchr cannot work correctly on character strings "
+                 "in some multibyte locales - "
+                 "use mbschr if you care about internationalization");
 #endif
 
 /* Find the first occurrence of C in S or the final NUL byte.  */
 #if @GNULIB_STRCHRNUL@
 # if ! @HAVE_STRCHRNUL@
-extern char *strchrnul (char const *__s, int __c_in)
-  __attribute__ ((__pure__));
+_GL_FUNCDECL_SYS (strchrnul, char *, (char const *__s, int __c_in)
+                                     _GL_ATTRIBUTE_PURE
+                                     _GL_ARG_NONNULL ((1)));
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const char * std::strchrnul (const char *, int); }
+       extern "C++" { char * std::strchrnul (char *, int); }  */
+_GL_CXXALIAS_SYS_CAST2 (strchrnul,
+                        char *, (char const *__s, int __c_in),
+                        char const *, (char const *__s, int __c_in));
+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 10 \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (strchrnul, char *, (char *__s, int __c_in));
+_GL_CXXALIASWARN1 (strchrnul, char const *, (char const *__s, int __c_in));
+# else
+_GL_CXXALIASWARN (strchrnul);
 # endif
 #elif defined GNULIB_POSIXCHECK
 # undef strchrnul
-# define strchrnul(a,b) \
-    (GL_LINK_WARNING ("strchrnul is unportable - " \
-                      "use gnulib module strchrnul for portability"), \
-     strchrnul (a, b))
+# if HAVE_RAW_DECL_STRCHRNUL
+_GL_WARN_ON_USE (strchrnul, "strchrnul is unportable - "
+                 "use gnulib module strchrnul for portability");
+# endif
 #endif
 
 /* Duplicate S, returning an identical malloc'd string.  */
 #if @GNULIB_STRDUP@
 # if @REPLACE_STRDUP@
-#  undef strdup
-#  define strdup rpl_strdup
-# endif
-# if !(@HAVE_DECL_STRDUP@ || defined strdup) || @REPLACE_STRDUP@
-extern char *strdup (char const *__s);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strdup
+#   define strdup rpl_strdup
+#  endif
+_GL_FUNCDECL_RPL (strdup, char *, (char const *__s) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strdup, char *, (char const *__s));
+# else
+#  if !(@HAVE_DECL_STRDUP@ || defined strdup)
+_GL_FUNCDECL_SYS (strdup, char *, (char const *__s) _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strdup, char *, (char const *__s));
 # endif
+_GL_CXXALIASWARN (strdup);
 #elif defined GNULIB_POSIXCHECK
 # undef strdup
-# define strdup(a) \
-    (GL_LINK_WARNING ("strdup is unportable - " \
-                      "use gnulib module strdup for portability"), \
-     strdup (a))
+# if HAVE_RAW_DECL_STRDUP
+_GL_WARN_ON_USE (strdup, "strdup is unportable - "
+                 "use gnulib module strdup for portability");
+# endif
+#endif
+
+/* Append no more than N characters from SRC onto DEST.  */
+#if @GNULIB_STRNCAT@
+# if @REPLACE_STRNCAT@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strncat
+#   define strncat rpl_strncat
+#  endif
+_GL_FUNCDECL_RPL (strncat, char *, (char *dest, const char *src, size_t n)
+                                   _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (strncat, char *, (char *dest, const char *src, size_t n));
+# else
+_GL_CXXALIAS_SYS (strncat, char *, (char *dest, const char *src, size_t n));
+# endif
+_GL_CXXALIASWARN (strncat);
+#elif defined GNULIB_POSIXCHECK
+# undef strncat
+# if HAVE_RAW_DECL_STRNCAT
+_GL_WARN_ON_USE (strncat, "strncat is unportable - "
+                 "use gnulib module strncat for portability");
+# endif
 #endif
 
 /* Return a newly allocated copy of at most N bytes of STRING.  */
 #if @GNULIB_STRNDUP@
-# if ! @HAVE_STRNDUP@
-#  undef strndup
-#  define strndup rpl_strndup
-# endif
-# if ! @HAVE_STRNDUP@ || ! @HAVE_DECL_STRNDUP@
-extern char *strndup (char const *__string, size_t __n);
+# if @REPLACE_STRNDUP@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strndup
+#   define strndup rpl_strndup
+#  endif
+_GL_FUNCDECL_RPL (strndup, char *, (char const *__string, size_t __n)
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strndup, char *, (char const *__string, size_t __n));
+# else
+#  if ! @HAVE_DECL_STRNDUP@
+_GL_FUNCDECL_SYS (strndup, char *, (char const *__string, size_t __n)
+                                   _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strndup, char *, (char const *__string, size_t __n));
 # endif
+_GL_CXXALIASWARN (strndup);
 #elif defined GNULIB_POSIXCHECK
 # undef strndup
-# define strndup(a,n) \
-    (GL_LINK_WARNING ("strndup is unportable - " \
-                      "use gnulib module strndup for portability"), \
-     strndup (a, n))
+# if HAVE_RAW_DECL_STRNDUP
+_GL_WARN_ON_USE (strndup, "strndup is unportable - "
+                 "use gnulib module strndup for portability");
+# endif
 #endif
 
 /* Find the length (number of bytes) of STRING, but scan at most
    MAXLEN bytes.  If no '\0' terminator is found in that many bytes,
    return MAXLEN.  */
 #if @GNULIB_STRNLEN@
-# if ! @HAVE_DECL_STRNLEN@
-extern size_t strnlen (char const *__string, size_t __maxlen)
-  __attribute__ ((__pure__));
+# if @REPLACE_STRNLEN@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strnlen
+#   define strnlen rpl_strnlen
+#  endif
+_GL_FUNCDECL_RPL (strnlen, size_t, (char const *__string, size_t __maxlen)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strnlen, size_t, (char const *__string, size_t __maxlen));
+# else
+#  if ! @HAVE_DECL_STRNLEN@
+_GL_FUNCDECL_SYS (strnlen, size_t, (char const *__string, size_t __maxlen)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strnlen, size_t, (char const *__string, size_t __maxlen));
 # endif
+_GL_CXXALIASWARN (strnlen);
 #elif defined GNULIB_POSIXCHECK
 # undef strnlen
-# define strnlen(a,n) \
-    (GL_LINK_WARNING ("strnlen is unportable - " \
-                      "use gnulib module strnlen for portability"), \
-     strnlen (a, n))
+# if HAVE_RAW_DECL_STRNLEN
+_GL_WARN_ON_USE (strnlen, "strnlen is unportable - "
+                 "use gnulib module strnlen for portability");
+# endif
 #endif
 
 #if defined GNULIB_POSIXCHECK
@@ -223,18 +408,32 @@ extern size_t strnlen (char const *__str
    locale encoding is GB18030 and one of the characters to be searched is a
    digit.  */
 # undef strcspn
-# define strcspn(s,a) \
-    (GL_LINK_WARNING ("strcspn cannot work correctly on character strings " \
-                      "in multibyte locales - " \
-                      "use mbscspn if you care about internationalization"), \
-     strcspn (s, a))
+/* Assume strcspn is always declared.  */
+_GL_WARN_ON_USE (strcspn, "strcspn cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbscspn if you care about internationalization");
 #endif
 
 /* Find the first occurrence in S of any character in ACCEPT.  */
 #if @GNULIB_STRPBRK@
 # if ! @HAVE_STRPBRK@
-extern char *strpbrk (char const *__s, char const *__accept)
-  __attribute__ ((__pure__));
+_GL_FUNCDECL_SYS (strpbrk, char *, (char const *__s, char const *__accept)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1, 2)));
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C" { const char * strpbrk (const char *, const char *); }
+       extern "C++" { char * strpbrk (char *, const char *); }  */
+_GL_CXXALIAS_SYS_CAST2 (strpbrk,
+                        char *, (char const *__s, char const *__accept),
+                        const char *, (char const *__s, char const *__accept));
+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 10 \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (strpbrk, char *, (char *__s, char const *__accept));
+_GL_CXXALIASWARN1 (strpbrk, char const *,
+                   (char const *__s, char const *__accept));
+# else
+_GL_CXXALIASWARN (strpbrk);
 # endif
 # if defined GNULIB_POSIXCHECK
 /* strpbrk() assumes the second argument is a list of single-byte characters.
@@ -242,40 +441,36 @@ extern char *strpbrk (char const *__s, c
    locale encoding is GB18030 and one of the characters to be searched is a
    digit.  */
 #  undef strpbrk
-#  define strpbrk(s,a) \
-     (GL_LINK_WARNING ("strpbrk cannot work correctly on character strings " \
-                       "in multibyte locales - " \
-                       "use mbspbrk if you care about internationalization"), \
-      strpbrk (s, a))
+_GL_WARN_ON_USE (strpbrk, "strpbrk cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbspbrk if you care about internationalization");
 # endif
 #elif defined GNULIB_POSIXCHECK
 # undef strpbrk
-# define strpbrk(s,a) \
-    (GL_LINK_WARNING ("strpbrk is unportable - " \
-                      "use gnulib module strpbrk for portability"), \
-     strpbrk (s, a))
+# if HAVE_RAW_DECL_STRPBRK
+_GL_WARN_ON_USE (strpbrk, "strpbrk is unportable - "
+                 "use gnulib module strpbrk for portability");
+# endif
 #endif
 
 #if defined GNULIB_POSIXCHECK
 /* strspn() assumes the second argument is a list of single-byte characters.
    Even in this simple case, it cannot work with multibyte strings.  */
 # undef strspn
-# define strspn(s,a) \
-    (GL_LINK_WARNING ("strspn cannot work correctly on character strings " \
-                      "in multibyte locales - " \
-                      "use mbsspn if you care about internationalization"), \
-     strspn (s, a))
+/* Assume strspn is always declared.  */
+_GL_WARN_ON_USE (strspn, "strspn cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbsspn if you care about internationalization");
 #endif
 
 #if defined GNULIB_POSIXCHECK
 /* strrchr() does not work with multibyte strings if the locale encoding is
    GB18030 and the character to be searched is a digit.  */
 # undef strrchr
-# define strrchr(s,c) \
-    (GL_LINK_WARNING ("strrchr cannot work correctly on character strings " \
-                      "in some multibyte locales - " \
-                      "use mbsrchr if you care about internationalization"), \
-     strrchr (s, c))
+/* Assume strrchr is always declared.  */
+_GL_WARN_ON_USE (strrchr, "strrchr cannot work correctly on character strings "
+                 "in some multibyte locales - "
+                 "use mbsrchr if you care about internationalization");
 #endif
 
 /* Search the next delimiter (char listed in DELIM) starting at *STRINGP.
@@ -296,29 +491,51 @@ extern char *strpbrk (char const *__s, c
    See also strtok_r().  */
 #if @GNULIB_STRSEP@
 # if ! @HAVE_STRSEP@
-extern char *strsep (char **restrict __stringp, char const *restrict __delim);
-# endif
+_GL_FUNCDECL_SYS (strsep, char *,
+                  (char **restrict __stringp, char const *restrict __delim)
+                  _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (strsep, char *,
+                  (char **restrict __stringp, char const *restrict __delim));
+_GL_CXXALIASWARN (strsep);
 # if defined GNULIB_POSIXCHECK
 #  undef strsep
-#  define strsep(s,d) \
-     (GL_LINK_WARNING ("strsep cannot work correctly on character strings " \
-                       "in multibyte locales - " \
-                       "use mbssep if you care about internationalization"), \
-      strsep (s, d))
+_GL_WARN_ON_USE (strsep, "strsep cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbssep if you care about internationalization");
 # endif
 #elif defined GNULIB_POSIXCHECK
 # undef strsep
-# define strsep(s,d) \
-    (GL_LINK_WARNING ("strsep is unportable - " \
-                      "use gnulib module strsep for portability"), \
-     strsep (s, d))
+# if HAVE_RAW_DECL_STRSEP
+_GL_WARN_ON_USE (strsep, "strsep is unportable - "
+                 "use gnulib module strsep for portability");
+# endif
 #endif
 
 #if @GNULIB_STRSTR@
 # if @REPLACE_STRSTR@
-#  define strstr rpl_strstr
-char *strstr (const char *haystack, const char *needle)
-  __attribute__ ((__pure__));
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strstr rpl_strstr
+#  endif
+_GL_FUNCDECL_RPL (strstr, char *, (const char *haystack, const char *needle)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (strstr, char *, (const char *haystack, const char *needle));
+# else
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const char * strstr (const char *, const char *); }
+       extern "C++" { char * strstr (char *, const char *); }  */
+_GL_CXXALIAS_SYS_CAST2 (strstr,
+                        char *, (const char *haystack, const char *needle),
+                        const char *, (const char *haystack, const char *needle));
+# endif
+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 10 \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (strstr, char *, (char *haystack, const char *needle));
+_GL_CXXALIASWARN1 (strstr, const char *,
+                   (const char *haystack, const char *needle));
+# else
+_GL_CXXALIASWARN (strstr);
 # endif
 #elif defined GNULIB_POSIXCHECK
 /* strstr() does not work with multibyte strings if the locale encoding is
@@ -326,48 +543,72 @@ char *strstr (const char *haystack, cons
    POSIX says that it operates on "strings", and "string" in POSIX is defined
    as a sequence of bytes, not of characters.  */
 # undef strstr
-# define strstr(a,b) \
-    (GL_LINK_WARNING ("strstr is quadratic on many systems, and cannot " \
-                      "work correctly on character strings in most "    \
-                      "multibyte locales - " \
-                      "use mbsstr if you care about internationalization, " \
-                      "or use strstr if you care about speed"), \
-     strstr (a, b))
+/* Assume strstr is always declared.  */
+_GL_WARN_ON_USE (strstr, "strstr is quadratic on many systems, and cannot "
+                 "work correctly on character strings in most "
+                 "multibyte locales - "
+                 "use mbsstr if you care about internationalization, "
+                 "or use strstr if you care about speed");
 #endif
 
 /* Find the first occurrence of NEEDLE in HAYSTACK, using case-insensitive
    comparison.  */
 #if @GNULIB_STRCASESTR@
 # if @REPLACE_STRCASESTR@
-#  define strcasestr rpl_strcasestr
-# endif
-# if ! @HAVE_STRCASESTR@ || @REPLACE_STRCASESTR@
-extern char *strcasestr (const char *haystack, const char *needle)
-  __attribute__ ((__pure__));
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strcasestr rpl_strcasestr
+#  endif
+_GL_FUNCDECL_RPL (strcasestr, char *,
+                  (const char *haystack, const char *needle)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (strcasestr, char *,
+                  (const char *haystack, const char *needle));
+# else
+#  if ! @HAVE_STRCASESTR@
+_GL_FUNCDECL_SYS (strcasestr, char *,
+                  (const char *haystack, const char *needle)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const char * strcasestr (const char *, const char *); }
+       extern "C++" { char * strcasestr (char *, const char *); }  */
+_GL_CXXALIAS_SYS_CAST2 (strcasestr,
+                        char *, (const char *haystack, const char *needle),
+                        const char *, (const char *haystack, const char *needle));
+# endif
+# if __GLIBC__ == 2 && __GLIBC_MINOR__ >= 10 \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (strcasestr, char *, (char *haystack, const char *needle));
+_GL_CXXALIASWARN1 (strcasestr, const char *,
+                   (const char *haystack, const char *needle));
+# else
+_GL_CXXALIASWARN (strcasestr);
 # endif
 #elif defined GNULIB_POSIXCHECK
 /* strcasestr() does not work with multibyte strings:
    It is a glibc extension, and glibc implements it only for unibyte
    locales.  */
 # undef strcasestr
-# define strcasestr(a,b) \
-    (GL_LINK_WARNING ("strcasestr does work correctly on character strings " \
-                      "in multibyte locales - " \
-                      "use mbscasestr if you care about " \
-                      "internationalization, or use c-strcasestr if you want " \
-                      "a locale independent function"), \
-     strcasestr (a, b))
+# if HAVE_RAW_DECL_STRCASESTR
+_GL_WARN_ON_USE (strcasestr, "strcasestr does work correctly on character "
+                 "strings in multibyte locales - "
+                 "use mbscasestr if you care about "
+                 "internationalization, or use c-strcasestr if you want "
+                 "a locale independent function");
+# endif
 #endif
 
 /* Parse S into tokens separated by characters in DELIM.
    If S is NULL, the saved pointer in SAVE_PTR is used as
    the next starting point.  For example:
-	char s[] = "-abc-=-def";
-	char *sp;
-	x = strtok_r(s, "-", &sp);	// x = "abc", sp = "=-def"
-	x = strtok_r(NULL, "-=", &sp);	// x = "def", sp = NULL
-	x = strtok_r(NULL, "=", &sp);	// x = NULL
-		// s = "abc\0-def\0"
+        char s[] = "-abc-=-def";
+        char *sp;
+        x = strtok_r(s, "-", &sp);      // x = "abc", sp = "=-def"
+        x = strtok_r(NULL, "-=", &sp);  // x = "def", sp = NULL
+        x = strtok_r(NULL, "=", &sp);   // x = NULL
+                // s = "abc\0-def\0"
 
    This is a variant of strtok() that is multithread-safe.
 
@@ -382,24 +623,44 @@ extern char *strcasestr (const char *hay
 
    See also strsep().  */
 #if @GNULIB_STRTOK_R@
-# if ! @HAVE_DECL_STRTOK_R@
-extern char *strtok_r (char *restrict s, char const *restrict delim,
-		       char **restrict save_ptr);
+# if @REPLACE_STRTOK_R@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strtok_r
+#   define strtok_r rpl_strtok_r
+#  endif
+_GL_FUNCDECL_RPL (strtok_r, char *,
+                  (char *restrict s, char const *restrict delim,
+                   char **restrict save_ptr)
+                  _GL_ARG_NONNULL ((2, 3)));
+_GL_CXXALIAS_RPL (strtok_r, char *,
+                  (char *restrict s, char const *restrict delim,
+                   char **restrict save_ptr));
+# else
+#  if @UNDEFINE_STRTOK_R@ || defined GNULIB_POSIXCHECK
+#   undef strtok_r
+#  endif
+#  if ! @HAVE_DECL_STRTOK_R@
+_GL_FUNCDECL_SYS (strtok_r, char *,
+                  (char *restrict s, char const *restrict delim,
+                   char **restrict save_ptr)
+                  _GL_ARG_NONNULL ((2, 3)));
+#  endif
+_GL_CXXALIAS_SYS (strtok_r, char *,
+                  (char *restrict s, char const *restrict delim,
+                   char **restrict save_ptr));
 # endif
+_GL_CXXALIASWARN (strtok_r);
 # if defined GNULIB_POSIXCHECK
-#  undef strtok_r
-#  define strtok_r(s,d,p) \
-     (GL_LINK_WARNING ("strtok_r cannot work correctly on character strings " \
-                       "in multibyte locales - " \
-                       "use mbstok_r if you care about internationalization"), \
-      strtok_r (s, d, p))
+_GL_WARN_ON_USE (strtok_r, "strtok_r cannot work correctly on character "
+                 "strings in multibyte locales - "
+                 "use mbstok_r if you care about internationalization");
 # endif
 #elif defined GNULIB_POSIXCHECK
 # undef strtok_r
-# define strtok_r(s,d,p) \
-    (GL_LINK_WARNING ("strtok_r is unportable - " \
-                      "use gnulib module strtok_r for portability"), \
-     strtok_r (s, d, p))
+# if HAVE_RAW_DECL_STRTOK_R
+_GL_WARN_ON_USE (strtok_r, "strtok_r is unportable - "
+                 "use gnulib module strtok_r for portability");
+# endif
 #endif
 
 
@@ -409,13 +670,27 @@ extern char *strtok_r (char *restrict s,
 #if @GNULIB_MBSLEN@
 /* Return the number of multibyte characters in the character string STRING.
    This considers multibyte characters, unlike strlen, which counts bytes.  */
-extern size_t mbslen (const char *string);
+# ifdef __MirBSD__  /* MirBSD defines mbslen as a macro.  Override it.  */
+#  undef mbslen
+# endif
+# if @HAVE_MBSLEN@  /* AIX, OSF/1, MirBSD define mbslen already in libc.  */
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbslen rpl_mbslen
+#  endif
+_GL_FUNCDECL_RPL (mbslen, size_t, (const char *string) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mbslen, size_t, (const char *string));
+# else
+_GL_FUNCDECL_SYS (mbslen, size_t, (const char *string) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (mbslen, size_t, (const char *string));
+# endif
+_GL_CXXALIASWARN (mbslen);
 #endif
 
 #if @GNULIB_MBSNLEN@
 /* Return the number of multibyte characters in the character string starting
    at STRING and ending at STRING + LEN.  */
-extern size_t mbsnlen (const char *string, size_t len);
+_GL_EXTERN_C size_t mbsnlen (const char *string, size_t len)
+     _GL_ARG_NONNULL ((1));
 #endif
 
 #if @GNULIB_MBSCHR@
@@ -423,8 +698,19 @@ extern size_t mbsnlen (const char *strin
    and return a pointer to it.  Return NULL if C is not found in STRING.
    Unlike strchr(), this function works correctly in multibyte locales with
    encodings such as GB18030.  */
-# define mbschr rpl_mbschr /* avoid collision with HP-UX function */
-extern char * mbschr (const char *string, int c);
+# if defined __hpux
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbschr rpl_mbschr /* avoid collision with HP-UX function */
+#  endif
+_GL_FUNCDECL_RPL (mbschr, char *, (const char *string, int c)
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mbschr, char *, (const char *string, int c));
+# else
+_GL_FUNCDECL_SYS (mbschr, char *, (const char *string, int c)
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (mbschr, char *, (const char *string, int c));
+# endif
+_GL_CXXALIASWARN (mbschr);
 #endif
 
 #if @GNULIB_MBSRCHR@
@@ -432,8 +718,19 @@ extern char * mbschr (const char *string
    and return a pointer to it.  Return NULL if C is not found in STRING.
    Unlike strrchr(), this function works correctly in multibyte locales with
    encodings such as GB18030.  */
-# define mbsrchr rpl_mbsrchr /* avoid collision with HP-UX function */
-extern char * mbsrchr (const char *string, int c);
+# if defined __hpux
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbsrchr rpl_mbsrchr /* avoid collision with HP-UX function */
+#  endif
+_GL_FUNCDECL_RPL (mbsrchr, char *, (const char *string, int c)
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mbsrchr, char *, (const char *string, int c));
+# else
+_GL_FUNCDECL_SYS (mbsrchr, char *, (const char *string, int c)
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (mbsrchr, char *, (const char *string, int c));
+# endif
+_GL_CXXALIASWARN (mbsrchr);
 #endif
 
 #if @GNULIB_MBSSTR@
@@ -441,7 +738,8 @@ extern char * mbsrchr (const char *strin
    string HAYSTACK.  Return NULL if NEEDLE is not found in HAYSTACK.
    Unlike strstr(), this function works correctly in multibyte locales with
    encodings different from UTF-8.  */
-extern char * mbsstr (const char *haystack, const char *needle);
+_GL_EXTERN_C char * mbsstr (const char *haystack, const char *needle)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSCASECMP@
@@ -451,7 +749,8 @@ extern char * mbsstr (const char *haysta
    Note: This function may, in multibyte locales, return 0 for strings of
    different lengths!
    Unlike strcasecmp(), this function works correctly in multibyte locales.  */
-extern int mbscasecmp (const char *s1, const char *s2);
+_GL_EXTERN_C int mbscasecmp (const char *s1, const char *s2)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSNCASECMP@
@@ -464,7 +763,8 @@ extern int mbscasecmp (const char *s1, c
    of different lengths!
    Unlike strncasecmp(), this function works correctly in multibyte locales.
    But beware that N is not a byte count but a character count!  */
-extern int mbsncasecmp (const char *s1, const char *s2, size_t n);
+_GL_EXTERN_C int mbsncasecmp (const char *s1, const char *s2, size_t n)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSPCASECMP@
@@ -477,7 +777,8 @@ extern int mbsncasecmp (const char *s1,
    smaller length than PREFIX!
    Unlike strncasecmp(), this function works correctly in multibyte
    locales.  */
-extern char * mbspcasecmp (const char *string, const char *prefix);
+_GL_EXTERN_C char * mbspcasecmp (const char *string, const char *prefix)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSCASESTR@
@@ -486,7 +787,8 @@ extern char * mbspcasecmp (const char *s
    Note: This function may, in multibyte locales, return success even if
    strlen (haystack) < strlen (needle) !
    Unlike strcasestr(), this function works correctly in multibyte locales.  */
-extern char * mbscasestr (const char *haystack, const char *needle);
+_GL_EXTERN_C char * mbscasestr (const char *haystack, const char *needle)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSCSPN@
@@ -495,7 +797,8 @@ extern char * mbscasestr (const char *ha
    beginning of the string to this occurrence, or to the end of the string
    if none exists.
    Unlike strcspn(), this function works correctly in multibyte locales.  */
-extern size_t mbscspn (const char *string, const char *accept);
+_GL_EXTERN_C size_t mbscspn (const char *string, const char *accept)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSPBRK@
@@ -503,8 +806,19 @@ extern size_t mbscspn (const char *strin
    in the character string ACCEPT.  Return the pointer to it, or NULL if none
    exists.
    Unlike strpbrk(), this function works correctly in multibyte locales.  */
-# define mbspbrk rpl_mbspbrk /* avoid collision with HP-UX function */
-extern char * mbspbrk (const char *string, const char *accept);
+# if defined __hpux
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbspbrk rpl_mbspbrk /* avoid collision with HP-UX function */
+#  endif
+_GL_FUNCDECL_RPL (mbspbrk, char *, (const char *string, const char *accept)
+                                   _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (mbspbrk, char *, (const char *string, const char *accept));
+# else
+_GL_FUNCDECL_SYS (mbspbrk, char *, (const char *string, const char *accept)
+                                   _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_SYS (mbspbrk, char *, (const char *string, const char *accept));
+# endif
+_GL_CXXALIASWARN (mbspbrk);
 #endif
 
 #if @GNULIB_MBSSPN@
@@ -513,7 +827,8 @@ extern char * mbspbrk (const char *strin
    beginning of the string to this occurrence, or to the end of the string
    if none exists.
    Unlike strspn(), this function works correctly in multibyte locales.  */
-extern size_t mbsspn (const char *string, const char *reject);
+_GL_EXTERN_C size_t mbsspn (const char *string, const char *reject)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSSEP@
@@ -531,7 +846,8 @@ extern size_t mbsspn (const char *string
    Caveat: The identity of the delimiting character is lost.
 
    See also mbstok_r().  */
-extern char * mbssep (char **stringp, const char *delim);
+_GL_EXTERN_C char * mbssep (char **stringp, const char *delim)
+     _GL_ARG_NONNULL ((1, 2));
 #endif
 
 #if @GNULIB_MBSTOK_R@
@@ -539,67 +855,81 @@ extern char * mbssep (char **stringp, co
    the character string DELIM.
    If STRING is NULL, the saved pointer in SAVE_PTR is used as
    the next starting point.  For example:
-	char s[] = "-abc-=-def";
-	char *sp;
-	x = mbstok_r(s, "-", &sp);	// x = "abc", sp = "=-def"
-	x = mbstok_r(NULL, "-=", &sp);	// x = "def", sp = NULL
-	x = mbstok_r(NULL, "=", &sp);	// x = NULL
-		// s = "abc\0-def\0"
+        char s[] = "-abc-=-def";
+        char *sp;
+        x = mbstok_r(s, "-", &sp);      // x = "abc", sp = "=-def"
+        x = mbstok_r(NULL, "-=", &sp);  // x = "def", sp = NULL
+        x = mbstok_r(NULL, "=", &sp);   // x = NULL
+                // s = "abc\0-def\0"
 
    Caveat: It modifies the original string.
    Caveat: These functions cannot be used on constant strings.
    Caveat: The identity of the delimiting character is lost.
 
    See also mbssep().  */
-extern char * mbstok_r (char *string, const char *delim, char **save_ptr);
+_GL_EXTERN_C char * mbstok_r (char *string, const char *delim, char **save_ptr)
+     _GL_ARG_NONNULL ((2, 3));
 #endif
 
 /* Map any int, typically from errno, into an error message.  */
 #if @GNULIB_STRERROR@
 # if @REPLACE_STRERROR@
-#  undef strerror
-#  define strerror rpl_strerror
-extern char *strerror (int);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strerror
+#   define strerror rpl_strerror
+#  endif
+_GL_FUNCDECL_RPL (strerror, char *, (int));
+_GL_CXXALIAS_RPL (strerror, char *, (int));
+# else
+_GL_CXXALIAS_SYS (strerror, char *, (int));
 # endif
+_GL_CXXALIASWARN (strerror);
 #elif defined GNULIB_POSIXCHECK
 # undef strerror
-# define strerror(e) \
-    (GL_LINK_WARNING ("strerror is unportable - " \
-                      "use gnulib module strerror to guarantee non-NULL result"), \
-     strerror (e))
+/* Assume strerror is always declared.  */
+_GL_WARN_ON_USE (strerror, "strerror is unportable - "
+                 "use gnulib module strerror to guarantee non-NULL result");
 #endif
 
 #if @GNULIB_STRSIGNAL@
 # if @REPLACE_STRSIGNAL@
-#  define strsignal rpl_strsignal
-# endif
-# if ! @HAVE_DECL_STRSIGNAL@ || @REPLACE_STRSIGNAL@
-extern char *strsignal (int __sig);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strsignal rpl_strsignal
+#  endif
+_GL_FUNCDECL_RPL (strsignal, char *, (int __sig));
+_GL_CXXALIAS_RPL (strsignal, char *, (int __sig));
+# else
+#  if ! @HAVE_DECL_STRSIGNAL@
+_GL_FUNCDECL_SYS (strsignal, char *, (int __sig));
+#  endif
+/* Need to cast, because on Cygwin 1.5.x systems, the return type is
+   'const char *'.  */
+_GL_CXXALIAS_SYS_CAST (strsignal, char *, (int __sig));
 # endif
+_GL_CXXALIASWARN (strsignal);
 #elif defined GNULIB_POSIXCHECK
 # undef strsignal
-# define strsignal(a) \
-    (GL_LINK_WARNING ("strsignal is unportable - " \
-                      "use gnulib module strsignal for portability"), \
-     strsignal (a))
+# if HAVE_RAW_DECL_STRSIGNAL
+_GL_WARN_ON_USE (strsignal, "strsignal is unportable - "
+                 "use gnulib module strsignal for portability");
+# endif
 #endif
 
 #if @GNULIB_STRVERSCMP@
 # if !@HAVE_STRVERSCMP@
-extern int strverscmp (const char *, const char *);
+_GL_FUNCDECL_SYS (strverscmp, int, (const char *, const char *)
+                                   _GL_ARG_NONNULL ((1, 2)));
 # endif
+_GL_CXXALIAS_SYS (strverscmp, int, (const char *, const char *));
+_GL_CXXALIASWARN (strverscmp);
 #elif defined GNULIB_POSIXCHECK
 # undef strverscmp
-# define strverscmp(a, b) \
-    (GL_LINK_WARNING ("strverscmp is unportable - " \
-                      "use gnulib module strverscmp for portability"), \
-     strverscmp (a, b))
+# if HAVE_RAW_DECL_STRVERSCMP
+_GL_WARN_ON_USE (strverscmp, "strverscmp is unportable - "
+                 "use gnulib module strverscmp for portability");
+# endif
 #endif
 
 
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* _GL_STRING_H */
 #endif /* _GL_STRING_H */
--- a/lib/gl/strverscmp.c
+++ b/lib/gl/strverscmp.c
@@ -1,11 +1,12 @@
 /* Compare strings while treating digits characters numerically.
-   Copyright (C) 1997, 2000, 2002, 2004, 2006 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2000, 2002, 2004, 2006, 2009-2010 Free Software
+   Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Jean-François Bignolles <bignolle@ecoledoc.ibp.fr>, 1997.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -117,8 +118,8 @@ __strverscmp (const char *s1, const char
 
     case LEN:
       while (ISDIGIT (*p1++))
-	if (!ISDIGIT (*p2++))
-	  return 1;
+        if (!ISDIGIT (*p2++))
+          return 1;
 
       return ISDIGIT (*p2) ? -1 : diff;
 
--- /dev/null
+++ b/lib/gl/unistr.in.h
@@ -0,0 +1,685 @@
+/* Elementary Unicode string functions.
+   Copyright (C) 2001-2002, 2005-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _UNISTR_H
+#define _UNISTR_H
+
+#include "unitypes.h"
+
+/* Get common macros for C.  */
+#include "unused-parameter.h"
+
+/* Get bool.  */
+#include <stdbool.h>
+
+/* Get size_t.  */
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Conventions:
+
+   All functions prefixed with u8_ operate on UTF-8 encoded strings.
+   Their unit is an uint8_t (1 byte).
+
+   All functions prefixed with u16_ operate on UTF-16 encoded strings.
+   Their unit is an uint16_t (a 2-byte word).
+
+   All functions prefixed with u32_ operate on UCS-4 encoded strings.
+   Their unit is an uint32_t (a 4-byte word).
+
+   All argument pairs (s, n) denote a Unicode string s[0..n-1] with exactly
+   n units.
+
+   All arguments starting with "str" and the arguments of functions starting
+   with u8_str/u16_str/u32_str denote a NUL terminated string, i.e. a string
+   which terminates at the first NUL unit.  This termination unit is
+   considered part of the string for all memory allocation purposes, but
+   is not considered part of the string for all other logical purposes.
+
+   Functions returning a string result take a (resultbuf, lengthp) argument
+   pair.  If resultbuf is not NULL and the result fits into *lengthp units,
+   it is put in resultbuf, and resultbuf is returned.  Otherwise, a freshly
+   allocated string is returned.  In both cases, *lengthp is set to the
+   length (number of units) of the returned string.  In case of error,
+   NULL is returned and errno is set.  */
+
+
+/* Elementary string checks.  */
+
+/* Check whether an UTF-8 string is well-formed.
+   Return NULL if valid, or a pointer to the first invalid unit otherwise.  */
+extern const uint8_t *
+       u8_check (const uint8_t *s, size_t n);
+
+/* Check whether an UTF-16 string is well-formed.
+   Return NULL if valid, or a pointer to the first invalid unit otherwise.  */
+extern const uint16_t *
+       u16_check (const uint16_t *s, size_t n);
+
+/* Check whether an UCS-4 string is well-formed.
+   Return NULL if valid, or a pointer to the first invalid unit otherwise.  */
+extern const uint32_t *
+       u32_check (const uint32_t *s, size_t n);
+
+
+/* Elementary string conversions.  */
+
+/* Convert an UTF-8 string to an UTF-16 string.  */
+extern uint16_t *
+       u8_to_u16 (const uint8_t *s, size_t n, uint16_t *resultbuf,
+                  size_t *lengthp);
+
+/* Convert an UTF-8 string to an UCS-4 string.  */
+extern uint32_t *
+       u8_to_u32 (const uint8_t *s, size_t n, uint32_t *resultbuf,
+                  size_t *lengthp);
+
+/* Convert an UTF-16 string to an UTF-8 string.  */
+extern uint8_t *
+       u16_to_u8 (const uint16_t *s, size_t n, uint8_t *resultbuf,
+                  size_t *lengthp);
+
+/* Convert an UTF-16 string to an UCS-4 string.  */
+extern uint32_t *
+       u16_to_u32 (const uint16_t *s, size_t n, uint32_t *resultbuf,
+                   size_t *lengthp);
+
+/* Convert an UCS-4 string to an UTF-8 string.  */
+extern uint8_t *
+       u32_to_u8 (const uint32_t *s, size_t n, uint8_t *resultbuf,
+                  size_t *lengthp);
+
+/* Convert an UCS-4 string to an UTF-16 string.  */
+extern uint16_t *
+       u32_to_u16 (const uint32_t *s, size_t n, uint16_t *resultbuf,
+                   size_t *lengthp);
+
+
+/* Elementary string functions.  */
+
+/* Return the length (number of units) of the first character in S, which is
+   no longer than N.  Return 0 if it is the NUL character.  Return -1 upon
+   failure.  */
+/* Similar to mblen(), except that s must not be NULL.  */
+extern int
+       u8_mblen (const uint8_t *s, size_t n);
+extern int
+       u16_mblen (const uint16_t *s, size_t n);
+extern int
+       u32_mblen (const uint32_t *s, size_t n);
+
+/* Return the length (number of units) of the first character in S, putting
+   its 'ucs4_t' representation in *PUC.  Upon failure, *PUC is set to 0xfffd,
+   and an appropriate number of units is returned.
+   The number of available units, N, must be > 0.  */
+/* Similar to mbtowc(), except that puc and s must not be NULL, n must be > 0,
+   and the NUL character is not treated specially.  */
+/* The variants with _safe suffix are safe, even if the library is compiled
+   without --enable-safety.  */
+
+#ifdef GNULIB_UNISTR_U8_MBTOUC_UNSAFE
+# if !HAVE_INLINE
+extern int
+       u8_mbtouc_unsafe (ucs4_t *puc, const uint8_t *s, size_t n);
+# else
+extern int
+       u8_mbtouc_unsafe_aux (ucs4_t *puc, const uint8_t *s, size_t n);
+static inline int
+u8_mbtouc_unsafe (ucs4_t *puc, const uint8_t *s, size_t n)
+{
+  uint8_t c = *s;
+
+  if (c < 0x80)
+    {
+      *puc = c;
+      return 1;
+    }
+  else
+    return u8_mbtouc_unsafe_aux (puc, s, n);
+}
+# endif
+#endif
+
+#ifdef GNULIB_UNISTR_U16_MBTOUC_UNSAFE
+# if !HAVE_INLINE
+extern int
+       u16_mbtouc_unsafe (ucs4_t *puc, const uint16_t *s, size_t n);
+# else
+extern int
+       u16_mbtouc_unsafe_aux (ucs4_t *puc, const uint16_t *s, size_t n);
+static inline int
+u16_mbtouc_unsafe (ucs4_t *puc, const uint16_t *s, size_t n)
+{
+  uint16_t c = *s;
+
+  if (c < 0xd800 || c >= 0xe000)
+    {
+      *puc = c;
+      return 1;
+    }
+  else
+    return u16_mbtouc_unsafe_aux (puc, s, n);
+}
+# endif
+#endif
+
+#ifdef GNULIB_UNISTR_U32_MBTOUC_UNSAFE
+# if !HAVE_INLINE
+extern int
+       u32_mbtouc_unsafe (ucs4_t *puc, const uint32_t *s, size_t n);
+# else
+static inline int
+u32_mbtouc_unsafe (ucs4_t *puc,
+                   const uint32_t *s, size_t n _GL_UNUSED_PARAMETER)
+{
+  uint32_t c = *s;
+
+#  if CONFIG_UNICODE_SAFETY
+  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))
+#  endif
+    *puc = c;
+#  if CONFIG_UNICODE_SAFETY
+  else
+    /* invalid multibyte character */
+    *puc = 0xfffd;
+#  endif
+  return 1;
+}
+# endif
+#endif
+
+#ifdef GNULIB_UNISTR_U8_MBTOUC
+# if !HAVE_INLINE
+extern int
+       u8_mbtouc (ucs4_t *puc, const uint8_t *s, size_t n);
+# else
+extern int
+       u8_mbtouc_aux (ucs4_t *puc, const uint8_t *s, size_t n);
+static inline int
+u8_mbtouc (ucs4_t *puc, const uint8_t *s, size_t n)
+{
+  uint8_t c = *s;
+
+  if (c < 0x80)
+    {
+      *puc = c;
+      return 1;
+    }
+  else
+    return u8_mbtouc_aux (puc, s, n);
+}
+# endif
+#endif
+
+#ifdef GNULIB_UNISTR_U16_MBTOUC
+# if !HAVE_INLINE
+extern int
+       u16_mbtouc (ucs4_t *puc, const uint16_t *s, size_t n);
+# else
+extern int
+       u16_mbtouc_aux (ucs4_t *puc, const uint16_t *s, size_t n);
+static inline int
+u16_mbtouc (ucs4_t *puc, const uint16_t *s, size_t n)
+{
+  uint16_t c = *s;
+
+  if (c < 0xd800 || c >= 0xe000)
+    {
+      *puc = c;
+      return 1;
+    }
+  else
+    return u16_mbtouc_aux (puc, s, n);
+}
+# endif
+#endif
+
+#ifdef GNULIB_UNISTR_U32_MBTOUC
+# if !HAVE_INLINE
+extern int
+       u32_mbtouc (ucs4_t *puc, const uint32_t *s, size_t n);
+# else
+static inline int
+u32_mbtouc (ucs4_t *puc, const uint32_t *s, size_t n _GL_UNUSED_PARAMETER)
+{
+  uint32_t c = *s;
+
+  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))
+    *puc = c;
+  else
+    /* invalid multibyte character */
+    *puc = 0xfffd;
+  return 1;
+}
+# endif
+#endif
+
+/* Return the length (number of units) of the first character in S, putting
+   its 'ucs4_t' representation in *PUC.  Upon failure, *PUC is set to 0xfffd,
+   and -1 is returned for an invalid sequence of units, -2 is returned for an
+   incomplete sequence of units.
+   The number of available units, N, must be > 0.  */
+/* Similar to u*_mbtouc(), except that the return value gives more details
+   about the failure, similar to mbrtowc().  */
+
+#ifdef GNULIB_UNISTR_U8_MBTOUCR
+extern int
+       u8_mbtoucr (ucs4_t *puc, const uint8_t *s, size_t n);
+#endif
+
+#ifdef GNULIB_UNISTR_U16_MBTOUCR
+extern int
+       u16_mbtoucr (ucs4_t *puc, const uint16_t *s, size_t n);
+#endif
+
+#ifdef GNULIB_UNISTR_U32_MBTOUCR
+extern int
+       u32_mbtoucr (ucs4_t *puc, const uint32_t *s, size_t n);
+#endif
+
+/* Put the multibyte character represented by UC in S, returning its
+   length.  Return -1 upon failure, -2 if the number of available units, N,
+   is too small.  The latter case cannot occur if N >= 6/2/1, respectively.  */
+/* Similar to wctomb(), except that s must not be NULL, and the argument n
+   must be specified.  */
+
+#ifdef GNULIB_UNISTR_U8_UCTOMB
+/* Auxiliary function, also used by u8_chr, u8_strchr, u8_strrchr.  */
+extern int
+       u8_uctomb_aux (uint8_t *s, ucs4_t uc, int n);
+# if !HAVE_INLINE
+extern int
+       u8_uctomb (uint8_t *s, ucs4_t uc, int n);
+# else
+static inline int
+u8_uctomb (uint8_t *s, ucs4_t uc, int n)
+{
+  if (uc < 0x80 && n > 0)
+    {
+      s[0] = uc;
+      return 1;
+    }
+  else
+    return u8_uctomb_aux (s, uc, n);
+}
+# endif
+#endif
+
+#ifdef GNULIB_UNISTR_U16_UCTOMB
+/* Auxiliary function, also used by u16_chr, u16_strchr, u16_strrchr.  */
+extern int
+       u16_uctomb_aux (uint16_t *s, ucs4_t uc, int n);
+# if !HAVE_INLINE
+extern int
+       u16_uctomb (uint16_t *s, ucs4_t uc, int n);
+# else
+static inline int
+u16_uctomb (uint16_t *s, ucs4_t uc, int n)
+{
+  if (uc < 0xd800 && n > 0)
+    {
+      s[0] = uc;
+      return 1;
+    }
+  else
+    return u16_uctomb_aux (s, uc, n);
+}
+# endif
+#endif
+
+#ifdef GNULIB_UNISTR_U32_UCTOMB
+# if !HAVE_INLINE
+extern int
+       u32_uctomb (uint32_t *s, ucs4_t uc, int n);
+# else
+static inline int
+u32_uctomb (uint32_t *s, ucs4_t uc, int n)
+{
+  if (uc < 0xd800 || (uc >= 0xe000 && uc < 0x110000))
+    {
+      if (n > 0)
+        {
+          *s = uc;
+          return 1;
+        }
+      else
+        return -2;
+    }
+  else
+    return -1;
+}
+# endif
+#endif
+
+/* Copy N units from SRC to DEST.  */
+/* Similar to memcpy().  */
+extern uint8_t *
+       u8_cpy (uint8_t *dest, const uint8_t *src, size_t n);
+extern uint16_t *
+       u16_cpy (uint16_t *dest, const uint16_t *src, size_t n);
+extern uint32_t *
+       u32_cpy (uint32_t *dest, const uint32_t *src, size_t n);
+
+/* Copy N units from SRC to DEST, guaranteeing correct behavior for
+   overlapping memory areas.  */
+/* Similar to memmove().  */
+extern uint8_t *
+       u8_move (uint8_t *dest, const uint8_t *src, size_t n);
+extern uint16_t *
+       u16_move (uint16_t *dest, const uint16_t *src, size_t n);
+extern uint32_t *
+       u32_move (uint32_t *dest, const uint32_t *src, size_t n);
+
+/* Set the first N characters of S to UC.  UC should be a character that
+   occupies only 1 unit.  */
+/* Similar to memset().  */
+extern uint8_t *
+       u8_set (uint8_t *s, ucs4_t uc, size_t n);
+extern uint16_t *
+       u16_set (uint16_t *s, ucs4_t uc, size_t n);
+extern uint32_t *
+       u32_set (uint32_t *s, ucs4_t uc, size_t n);
+
+/* Compare S1 and S2, each of length N.  */
+/* Similar to memcmp().  */
+extern int
+       u8_cmp (const uint8_t *s1, const uint8_t *s2, size_t n);
+extern int
+       u16_cmp (const uint16_t *s1, const uint16_t *s2, size_t n);
+extern int
+       u32_cmp (const uint32_t *s1, const uint32_t *s2, size_t n);
+
+/* Compare S1 and S2.  */
+/* Similar to the gnulib function memcmp2().  */
+extern int
+       u8_cmp2 (const uint8_t *s1, size_t n1, const uint8_t *s2, size_t n2);
+extern int
+       u16_cmp2 (const uint16_t *s1, size_t n1, const uint16_t *s2, size_t n2);
+extern int
+       u32_cmp2 (const uint32_t *s1, size_t n1, const uint32_t *s2, size_t n2);
+
+/* Search the string at S for UC.  */
+/* Similar to memchr().  */
+extern uint8_t *
+       u8_chr (const uint8_t *s, size_t n, ucs4_t uc);
+extern uint16_t *
+       u16_chr (const uint16_t *s, size_t n, ucs4_t uc);
+extern uint32_t *
+       u32_chr (const uint32_t *s, size_t n, ucs4_t uc);
+
+/* Count the number of Unicode characters in the N units from S.  */
+/* Similar to mbsnlen().  */
+extern size_t
+       u8_mbsnlen (const uint8_t *s, size_t n);
+extern size_t
+       u16_mbsnlen (const uint16_t *s, size_t n);
+extern size_t
+       u32_mbsnlen (const uint32_t *s, size_t n);
+
+/* Elementary string functions with memory allocation.  */
+
+/* Make a freshly allocated copy of S, of length N.  */
+extern uint8_t *
+       u8_cpy_alloc (const uint8_t *s, size_t n);
+extern uint16_t *
+       u16_cpy_alloc (const uint16_t *s, size_t n);
+extern uint32_t *
+       u32_cpy_alloc (const uint32_t *s, size_t n);
+
+/* Elementary string functions on NUL terminated strings.  */
+
+/* Return the length (number of units) of the first character in S.
+   Return 0 if it is the NUL character.  Return -1 upon failure.  */
+extern int
+       u8_strmblen (const uint8_t *s);
+extern int
+       u16_strmblen (const uint16_t *s);
+extern int
+       u32_strmblen (const uint32_t *s);
+
+/* Return the length (number of units) of the first character in S, putting
+   its 'ucs4_t' representation in *PUC.  Return 0 if it is the NUL
+   character.  Return -1 upon failure.  */
+extern int
+       u8_strmbtouc (ucs4_t *puc, const uint8_t *s);
+extern int
+       u16_strmbtouc (ucs4_t *puc, const uint16_t *s);
+extern int
+       u32_strmbtouc (ucs4_t *puc, const uint32_t *s);
+
+/* Forward iteration step.  Advances the pointer past the next character,
+   or returns NULL if the end of the string has been reached.  Puts the
+   character's 'ucs4_t' representation in *PUC.  */
+extern const uint8_t *
+       u8_next (ucs4_t *puc, const uint8_t *s);
+extern const uint16_t *
+       u16_next (ucs4_t *puc, const uint16_t *s);
+extern const uint32_t *
+       u32_next (ucs4_t *puc, const uint32_t *s);
+
+/* Backward iteration step.  Advances the pointer to point to the previous
+   character, or returns NULL if the beginning of the string had been reached.
+   Puts the character's 'ucs4_t' representation in *PUC.  */
+extern const uint8_t *
+       u8_prev (ucs4_t *puc, const uint8_t *s, const uint8_t *start);
+extern const uint16_t *
+       u16_prev (ucs4_t *puc, const uint16_t *s, const uint16_t *start);
+extern const uint32_t *
+       u32_prev (ucs4_t *puc, const uint32_t *s, const uint32_t *start);
+
+/* Return the number of units in S.  */
+/* Similar to strlen(), wcslen().  */
+extern size_t
+       u8_strlen (const uint8_t *s);
+extern size_t
+       u16_strlen (const uint16_t *s);
+extern size_t
+       u32_strlen (const uint32_t *s);
+
+/* Return the number of units in S, but at most MAXLEN.  */
+/* Similar to strnlen(), wcsnlen().  */
+extern size_t
+       u8_strnlen (const uint8_t *s, size_t maxlen);
+extern size_t
+       u16_strnlen (const uint16_t *s, size_t maxlen);
+extern size_t
+       u32_strnlen (const uint32_t *s, size_t maxlen);
+
+/* Copy SRC to DEST.  */
+/* Similar to strcpy(), wcscpy().  */
+extern uint8_t *
+       u8_strcpy (uint8_t *dest, const uint8_t *src);
+extern uint16_t *
+       u16_strcpy (uint16_t *dest, const uint16_t *src);
+extern uint32_t *
+       u32_strcpy (uint32_t *dest, const uint32_t *src);
+
+/* Copy SRC to DEST, returning the address of the terminating NUL in DEST.  */
+/* Similar to stpcpy().  */
+extern uint8_t *
+       u8_stpcpy (uint8_t *dest, const uint8_t *src);
+extern uint16_t *
+       u16_stpcpy (uint16_t *dest, const uint16_t *src);
+extern uint32_t *
+       u32_stpcpy (uint32_t *dest, const uint32_t *src);
+
+/* Copy no more than N units of SRC to DEST.  */
+/* Similar to strncpy(), wcsncpy().  */
+extern uint8_t *
+       u8_strncpy (uint8_t *dest, const uint8_t *src, size_t n);
+extern uint16_t *
+       u16_strncpy (uint16_t *dest, const uint16_t *src, size_t n);
+extern uint32_t *
+       u32_strncpy (uint32_t *dest, const uint32_t *src, size_t n);
+
+/* Copy no more than N units of SRC to DEST.  Return a pointer past the last
+   non-NUL unit written into DEST.  */
+/* Similar to stpncpy().  */
+extern uint8_t *
+       u8_stpncpy (uint8_t *dest, const uint8_t *src, size_t n);
+extern uint16_t *
+       u16_stpncpy (uint16_t *dest, const uint16_t *src, size_t n);
+extern uint32_t *
+       u32_stpncpy (uint32_t *dest, const uint32_t *src, size_t n);
+
+/* Append SRC onto DEST.  */
+/* Similar to strcat(), wcscat().  */
+extern uint8_t *
+       u8_strcat (uint8_t *dest, const uint8_t *src);
+extern uint16_t *
+       u16_strcat (uint16_t *dest, const uint16_t *src);
+extern uint32_t *
+       u32_strcat (uint32_t *dest, const uint32_t *src);
+
+/* Append no more than N units of SRC onto DEST.  */
+/* Similar to strncat(), wcsncat().  */
+extern uint8_t *
+       u8_strncat (uint8_t *dest, const uint8_t *src, size_t n);
+extern uint16_t *
+       u16_strncat (uint16_t *dest, const uint16_t *src, size_t n);
+extern uint32_t *
+       u32_strncat (uint32_t *dest, const uint32_t *src, size_t n);
+
+/* Compare S1 and S2.  */
+/* Similar to strcmp(), wcscmp().  */
+extern int
+       u8_strcmp (const uint8_t *s1, const uint8_t *s2);
+extern int
+       u16_strcmp (const uint16_t *s1, const uint16_t *s2);
+extern int
+       u32_strcmp (const uint32_t *s1, const uint32_t *s2);
+
+/* Compare S1 and S2 using the collation rules of the current locale.
+   Return -1 if S1 < S2, 0 if S1 = S2, 1 if S1 > S2.
+   Upon failure, set errno and return any value.  */
+/* Similar to strcoll(), wcscoll().  */
+extern int
+       u8_strcoll (const uint8_t *s1, const uint8_t *s2);
+extern int
+       u16_strcoll (const uint16_t *s1, const uint16_t *s2);
+extern int
+       u32_strcoll (const uint32_t *s1, const uint32_t *s2);
+
+/* Compare no more than N units of S1 and S2.  */
+/* Similar to strncmp(), wcsncmp().  */
+extern int
+       u8_strncmp (const uint8_t *s1, const uint8_t *s2, size_t n);
+extern int
+       u16_strncmp (const uint16_t *s1, const uint16_t *s2, size_t n);
+extern int
+       u32_strncmp (const uint32_t *s1, const uint32_t *s2, size_t n);
+
+/* Duplicate S, returning an identical malloc'd string.  */
+/* Similar to strdup(), wcsdup().  */
+extern uint8_t *
+       u8_strdup (const uint8_t *s);
+extern uint16_t *
+       u16_strdup (const uint16_t *s);
+extern uint32_t *
+       u32_strdup (const uint32_t *s);
+
+/* Find the first occurrence of UC in STR.  */
+/* Similar to strchr(), wcschr().  */
+extern uint8_t *
+       u8_strchr (const uint8_t *str, ucs4_t uc);
+extern uint16_t *
+       u16_strchr (const uint16_t *str, ucs4_t uc);
+extern uint32_t *
+       u32_strchr (const uint32_t *str, ucs4_t uc);
+
+/* Find the last occurrence of UC in STR.  */
+/* Similar to strrchr(), wcsrchr().  */
+extern uint8_t *
+       u8_strrchr (const uint8_t *str, ucs4_t uc);
+extern uint16_t *
+       u16_strrchr (const uint16_t *str, ucs4_t uc);
+extern uint32_t *
+       u32_strrchr (const uint32_t *str, ucs4_t uc);
+
+/* Return the length of the initial segment of STR which consists entirely
+   of Unicode characters not in REJECT.  */
+/* Similar to strcspn(), wcscspn().  */
+extern size_t
+       u8_strcspn (const uint8_t *str, const uint8_t *reject);
+extern size_t
+       u16_strcspn (const uint16_t *str, const uint16_t *reject);
+extern size_t
+       u32_strcspn (const uint32_t *str, const uint32_t *reject);
+
+/* Return the length of the initial segment of STR which consists entirely
+   of Unicode characters in ACCEPT.  */
+/* Similar to strspn(), wcsspn().  */
+extern size_t
+       u8_strspn (const uint8_t *str, const uint8_t *accept);
+extern size_t
+       u16_strspn (const uint16_t *str, const uint16_t *accept);
+extern size_t
+       u32_strspn (const uint32_t *str, const uint32_t *accept);
+
+/* Find the first occurrence in STR of any character in ACCEPT.  */
+/* Similar to strpbrk(), wcspbrk().  */
+extern uint8_t *
+       u8_strpbrk (const uint8_t *str, const uint8_t *accept);
+extern uint16_t *
+       u16_strpbrk (const uint16_t *str, const uint16_t *accept);
+extern uint32_t *
+       u32_strpbrk (const uint32_t *str, const uint32_t *accept);
+
+/* Find the first occurrence of NEEDLE in HAYSTACK.  */
+/* Similar to strstr(), wcsstr().  */
+extern uint8_t *
+       u8_strstr (const uint8_t *haystack, const uint8_t *needle);
+extern uint16_t *
+       u16_strstr (const uint16_t *haystack, const uint16_t *needle);
+extern uint32_t *
+       u32_strstr (const uint32_t *haystack, const uint32_t *needle);
+
+/* Test whether STR starts with PREFIX.  */
+extern bool
+       u8_startswith (const uint8_t *str, const uint8_t *prefix);
+extern bool
+       u16_startswith (const uint16_t *str, const uint16_t *prefix);
+extern bool
+       u32_startswith (const uint32_t *str, const uint32_t *prefix);
+
+/* Test whether STR ends with SUFFIX.  */
+extern bool
+       u8_endswith (const uint8_t *str, const uint8_t *suffix);
+extern bool
+       u16_endswith (const uint16_t *str, const uint16_t *suffix);
+extern bool
+       u32_endswith (const uint32_t *str, const uint32_t *suffix);
+
+/* Divide STR into tokens separated by characters in DELIM.
+   This interface is actually more similar to wcstok than to strtok.  */
+/* Similar to strtok_r(), wcstok().  */
+extern uint8_t *
+       u8_strtok (uint8_t *str, const uint8_t *delim, uint8_t **ptr);
+extern uint16_t *
+       u16_strtok (uint16_t *str, const uint16_t *delim, uint16_t **ptr);
+extern uint32_t *
+       u32_strtok (uint32_t *str, const uint32_t *delim, uint32_t **ptr);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _UNISTR_H */
--- /dev/null
+++ b/lib/gl/unistr/u8-check.c
@@ -0,0 +1,105 @@
+/* Check UTF-8 string.
+   Copyright (C) 2002, 2006-2007, 2009-2010 Free Software Foundation, Inc.
+   Written by Bruno Haible <bruno@clisp.org>, 2002.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+/* Specification.  */
+#include "unistr.h"
+
+const uint8_t *
+u8_check (const uint8_t *s, size_t n)
+{
+  const uint8_t *s_end = s + n;
+
+  while (s < s_end)
+    {
+      /* Keep in sync with unistr.h and utf8-ucs4.c.  */
+      uint8_t c = *s;
+
+      if (c < 0x80)
+        {
+          s++;
+          continue;
+        }
+      if (c >= 0xc2)
+        {
+          if (c < 0xe0)
+            {
+              if (s + 2 <= s_end
+                  && (s[1] ^ 0x80) < 0x40)
+                {
+                  s += 2;
+                  continue;
+                }
+            }
+          else if (c < 0xf0)
+            {
+              if (s + 3 <= s_end
+                  && (s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40
+                  && (c >= 0xe1 || s[1] >= 0xa0)
+                  && (c != 0xed || s[1] < 0xa0))
+                {
+                  s += 3;
+                  continue;
+                }
+            }
+          else if (c < 0xf8)
+            {
+              if (s + 4 <= s_end
+                  && (s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40
+                  && (s[3] ^ 0x80) < 0x40
+                  && (c >= 0xf1 || s[1] >= 0x90)
+#if 1
+                  && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90))
+#endif
+                 )
+                {
+                  s += 4;
+                  continue;
+                }
+            }
+#if 0
+          else if (c < 0xfc)
+            {
+              if (s + 5 <= s_end
+                  && (s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40
+                  && (s[3] ^ 0x80) < 0x40 && (s[4] ^ 0x80) < 0x40
+                  && (c >= 0xf9 || s[1] >= 0x88))
+                {
+                  s += 5;
+                  continue;
+                }
+            }
+          else if (c < 0xfe)
+            {
+              if (s + 6 <= s_end
+                  && (s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40
+                  && (s[3] ^ 0x80) < 0x40 && (s[4] ^ 0x80) < 0x40
+                  && (s[5] ^ 0x80) < 0x40
+                  && (c >= 0xfd || s[1] >= 0x84))
+                {
+                  s += 6;
+                  continue;
+                }
+            }
+#endif
+        }
+      /* invalid or incomplete multibyte character */
+      return s;
+    }
+  return NULL;
+}
--- /dev/null
+++ b/lib/gl/unitypes.in.h
@@ -0,0 +1,26 @@
+/* Elementary types for the GNU UniString library.
+   Copyright (C) 2002, 2005-2006, 2009-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _UNITYPES_H
+#define _UNITYPES_H
+
+/* Get uint8_t, uint16_t, uint32_t.  */
+#include <stdint.h>
+
+/* Type representing a Unicode character.  */
+typedef uint32_t ucs4_t;
+
+#endif /* _UNITYPES_H */
--- a/lib/gl/wchar.in.h
+++ b/lib/gl/wchar.in.h
@@ -1,10 +1,10 @@
 /* A substitute for ISO C99 <wchar.h>, for platforms that have issues.
 
-   Copyright (C) 2007-2009 Free Software Foundation, Inc.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1, or (at your option)
+   the Free Software Foundation; either version 2, or (at your option)
    any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -30,9 +30,9 @@
 @PRAGMA_SYSTEM_HEADER@
 #endif
 
-#if defined __need_mbstate_t || (defined __hpux && ((defined _INTTYPES_INCLUDED && !defined strtoimax) || defined _GL_JUST_INCLUDE_SYSTEM_WCHAR_H)) || defined _GL_ALREADY_INCLUDING_WCHAR_H
+#if defined __need_mbstate_t || defined __need_wint_t || (defined __hpux && ((defined _INTTYPES_INCLUDED && !defined strtoimax) || defined _GL_JUST_INCLUDE_SYSTEM_WCHAR_H)) || defined _GL_ALREADY_INCLUDING_WCHAR_H
 /* Special invocation convention:
-   - Inside uClibc header files.
+   - Inside glibc and uClibc header files.
    - On HP-UX 11.00 we have a sequence of nested includes
      <wchar.h> -> <stdlib.h> -> <stdint.h>, and the latter includes <wchar.h>,
      once indirectly <stdint.h> -> <sys/types.h> -> <inttypes.h> -> <wchar.h>
@@ -55,10 +55,13 @@
 /* Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
    <wchar.h>.
    BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be
-   included before <wchar.h>.  */
-#include <stddef.h>
-#include <stdio.h>
-#include <time.h>
+   included before <wchar.h>.
+   But avoid namespace pollution on glibc systems.  */
+#ifndef __GLIBC__
+# include <stddef.h>
+# include <stdio.h>
+# include <time.h>
+#endif
 
 /* Include the original <wchar.h> if it exists.
    Some builds of uClibc lack it.  */
@@ -72,19 +75,23 @@
 #ifndef _GL_WCHAR_H
 #define _GL_WCHAR_H
 
-/* The definition of GL_LINK_WARNING is copied here.  */
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
 
-#ifdef __cplusplus
-extern "C" {
-#endif
+/* The definition of _GL_ARG_NONNULL is copied here.  */
 
+/* The definition of _GL_WARN_ON_USE is copied here.  */
 
-/* Define wint_t.  (Also done in wctype.in.h.)  */
+
+/* Define wint_t and WEOF.  (Also done in wctype.in.h.)  */
 #if !@HAVE_WINT_T@ && !defined wint_t
 # define wint_t int
 # ifndef WEOF
 #  define WEOF -1
 # endif
+#else
+# ifndef WEOF
+#  define WEOF ((wint_t) -1)
+# endif
 #endif
 
 
@@ -102,209 +109,320 @@ typedef int rpl_mbstate_t;
 /* Convert a single-byte character to a wide character.  */
 #if @GNULIB_BTOWC@
 # if @REPLACE_BTOWC@
-#  undef btowc
-#  define btowc rpl_btowc
-# endif
-# if !@HAVE_BTOWC@ || @REPLACE_BTOWC@
-extern wint_t btowc (int c);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef btowc
+#   define btowc rpl_btowc
+#  endif
+_GL_FUNCDECL_RPL (btowc, wint_t, (int c));
+_GL_CXXALIAS_RPL (btowc, wint_t, (int c));
+# else
+#  if !@HAVE_BTOWC@
+_GL_FUNCDECL_SYS (btowc, wint_t, (int c));
+#  endif
+_GL_CXXALIAS_SYS (btowc, wint_t, (int c));
 # endif
+_GL_CXXALIASWARN (btowc);
 #elif defined GNULIB_POSIXCHECK
 # undef btowc
-# define btowc(c) \
-    (GL_LINK_WARNING ("btowc is unportable - " \
-                      "use gnulib module btowc for portability"), \
-     btowc (c))
+# if HAVE_RAW_DECL_BTOWC
+_GL_WARN_ON_USE (btowc, "btowc is unportable - "
+                 "use gnulib module btowc for portability");
+# endif
 #endif
 
 
 /* Convert a wide character to a single-byte character.  */
 #if @GNULIB_WCTOB@
 # if @REPLACE_WCTOB@
-#  undef wctob
-#  define wctob rpl_wctob
-# endif
-# if (!defined wctob && !@HAVE_DECL_WCTOB@) || @REPLACE_WCTOB@
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wctob
+#   define wctob rpl_wctob
+#  endif
+_GL_FUNCDECL_RPL (wctob, int, (wint_t wc));
+_GL_CXXALIAS_RPL (wctob, int, (wint_t wc));
+# else
+#  if !defined wctob && !@HAVE_DECL_WCTOB@
 /* wctob is provided by gnulib, or wctob exists but is not declared.  */
-extern int wctob (wint_t wc);
+_GL_FUNCDECL_SYS (wctob, int, (wint_t wc));
+#  endif
+_GL_CXXALIAS_SYS (wctob, int, (wint_t wc));
 # endif
+_GL_CXXALIASWARN (wctob);
 #elif defined GNULIB_POSIXCHECK
 # undef wctob
-# define wctob(w) \
-    (GL_LINK_WARNING ("wctob is unportable - " \
-                      "use gnulib module wctob for portability"), \
-     wctob (w))
+# if HAVE_RAW_DECL_WCTOB
+_GL_WARN_ON_USE (wctob, "wctob is unportable - "
+                 "use gnulib module wctob for portability");
+# endif
 #endif
 
 
 /* Test whether *PS is in the initial state.  */
 #if @GNULIB_MBSINIT@
 # if @REPLACE_MBSINIT@
-#  undef mbsinit
-#  define mbsinit rpl_mbsinit
-# endif
-# if !@HAVE_MBSINIT@ || @REPLACE_MBSINIT@
-extern int mbsinit (const mbstate_t *ps);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbsinit
+#   define mbsinit rpl_mbsinit
+#  endif
+_GL_FUNCDECL_RPL (mbsinit, int, (const mbstate_t *ps));
+_GL_CXXALIAS_RPL (mbsinit, int, (const mbstate_t *ps));
+# else
+#  if !@HAVE_MBSINIT@
+_GL_FUNCDECL_SYS (mbsinit, int, (const mbstate_t *ps));
+#  endif
+_GL_CXXALIAS_SYS (mbsinit, int, (const mbstate_t *ps));
 # endif
+_GL_CXXALIASWARN (mbsinit);
 #elif defined GNULIB_POSIXCHECK
 # undef mbsinit
-# define mbsinit(p) \
-    (GL_LINK_WARNING ("mbsinit is unportable - " \
-                      "use gnulib module mbsinit for portability"), \
-     mbsinit (p))
+# if HAVE_RAW_DECL_MBSINIT
+_GL_WARN_ON_USE (mbsinit, "mbsinit is unportable - "
+                 "use gnulib module mbsinit for portability");
+# endif
 #endif
 
 
 /* Convert a multibyte character to a wide character.  */
 #if @GNULIB_MBRTOWC@
 # if @REPLACE_MBRTOWC@
-#  undef mbrtowc
-#  define mbrtowc rpl_mbrtowc
-# endif
-# if !@HAVE_MBRTOWC@ || @REPLACE_MBRTOWC@
-extern size_t mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbrtowc
+#   define mbrtowc rpl_mbrtowc
+#  endif
+_GL_FUNCDECL_RPL (mbrtowc, size_t,
+                  (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps));
+_GL_CXXALIAS_RPL (mbrtowc, size_t,
+                  (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps));
+# else
+#  if !@HAVE_MBRTOWC@
+_GL_FUNCDECL_SYS (mbrtowc, size_t,
+                  (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps));
+#  endif
+_GL_CXXALIAS_SYS (mbrtowc, size_t,
+                  (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps));
 # endif
+_GL_CXXALIASWARN (mbrtowc);
 #elif defined GNULIB_POSIXCHECK
 # undef mbrtowc
-# define mbrtowc(w,s,n,p) \
-    (GL_LINK_WARNING ("mbrtowc is unportable - " \
-                      "use gnulib module mbrtowc for portability"), \
-     mbrtowc (w, s, n, p))
+# if HAVE_RAW_DECL_MBRTOWC
+_GL_WARN_ON_USE (mbrtowc, "mbrtowc is unportable - "
+                 "use gnulib module mbrtowc for portability");
+# endif
 #endif
 
 
 /* Recognize a multibyte character.  */
 #if @GNULIB_MBRLEN@
 # if @REPLACE_MBRLEN@
-#  undef mbrlen
-#  define mbrlen rpl_mbrlen
-# endif
-# if !@HAVE_MBRLEN@ || @REPLACE_MBRLEN@
-extern size_t mbrlen (const char *s, size_t n, mbstate_t *ps);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbrlen
+#   define mbrlen rpl_mbrlen
+#  endif
+_GL_FUNCDECL_RPL (mbrlen, size_t, (const char *s, size_t n, mbstate_t *ps));
+_GL_CXXALIAS_RPL (mbrlen, size_t, (const char *s, size_t n, mbstate_t *ps));
+# else
+#  if !@HAVE_MBRLEN@
+_GL_FUNCDECL_SYS (mbrlen, size_t, (const char *s, size_t n, mbstate_t *ps));
+#  endif
+_GL_CXXALIAS_SYS (mbrlen, size_t, (const char *s, size_t n, mbstate_t *ps));
 # endif
+_GL_CXXALIASWARN (mbrlen);
 #elif defined GNULIB_POSIXCHECK
 # undef mbrlen
-# define mbrlen(s,n,p) \
-    (GL_LINK_WARNING ("mbrlen is unportable - " \
-                      "use gnulib module mbrlen for portability"), \
-     mbrlen (s, n, p))
+# if HAVE_RAW_DECL_MBRLEN
+_GL_WARN_ON_USE (mbrlen, "mbrlen is unportable - "
+                 "use gnulib module mbrlen for portability");
+# endif
 #endif
 
 
 /* Convert a string to a wide string.  */
 #if @GNULIB_MBSRTOWCS@
 # if @REPLACE_MBSRTOWCS@
-#  undef mbsrtowcs
-#  define mbsrtowcs rpl_mbsrtowcs
-# endif
-# if !@HAVE_MBSRTOWCS@ || @REPLACE_MBSRTOWCS@
-extern size_t mbsrtowcs (wchar_t *dest, const char **srcp, size_t len, mbstate_t *ps);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbsrtowcs
+#   define mbsrtowcs rpl_mbsrtowcs
+#  endif
+_GL_FUNCDECL_RPL (mbsrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t len, mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (mbsrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t len,
+                   mbstate_t *ps));
+# else
+#  if !@HAVE_MBSRTOWCS@
+_GL_FUNCDECL_SYS (mbsrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t len, mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (mbsrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t len,
+                   mbstate_t *ps));
 # endif
+_GL_CXXALIASWARN (mbsrtowcs);
 #elif defined GNULIB_POSIXCHECK
 # undef mbsrtowcs
-# define mbsrtowcs(d,s,l,p) \
-    (GL_LINK_WARNING ("mbsrtowcs is unportable - " \
-                      "use gnulib module mbsrtowcs for portability"), \
-     mbsrtowcs (d, s, l, p))
+# if HAVE_RAW_DECL_MBSRTOWCS
+_GL_WARN_ON_USE (mbsrtowcs, "mbsrtowcs is unportable - "
+                 "use gnulib module mbsrtowcs for portability");
+# endif
 #endif
 
 
 /* Convert a string to a wide string.  */
 #if @GNULIB_MBSNRTOWCS@
 # if @REPLACE_MBSNRTOWCS@
-#  undef mbsnrtowcs
-#  define mbsnrtowcs rpl_mbsnrtowcs
-# endif
-# if !@HAVE_MBSNRTOWCS@ || @REPLACE_MBSNRTOWCS@
-extern size_t mbsnrtowcs (wchar_t *dest, const char **srcp, size_t srclen, size_t len, mbstate_t *ps);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbsnrtowcs
+#   define mbsnrtowcs rpl_mbsnrtowcs
+#  endif
+_GL_FUNCDECL_RPL (mbsnrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (mbsnrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps));
+# else
+#  if !@HAVE_MBSNRTOWCS@
+_GL_FUNCDECL_SYS (mbsnrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (mbsnrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps));
 # endif
+_GL_CXXALIASWARN (mbsnrtowcs);
 #elif defined GNULIB_POSIXCHECK
 # undef mbsnrtowcs
-# define mbsnrtowcs(d,s,n,l,p) \
-    (GL_LINK_WARNING ("mbsnrtowcs is unportable - " \
-                      "use gnulib module mbsnrtowcs for portability"), \
-     mbsnrtowcs (d, s, n, l, p))
+# if HAVE_RAW_DECL_MBSNRTOWCS
+_GL_WARN_ON_USE (mbsnrtowcs, "mbsnrtowcs is unportable - "
+                 "use gnulib module mbsnrtowcs for portability");
+# endif
 #endif
 
 
 /* Convert a wide character to a multibyte character.  */
 #if @GNULIB_WCRTOMB@
 # if @REPLACE_WCRTOMB@
-#  undef wcrtomb
-#  define wcrtomb rpl_wcrtomb
-# endif
-# if !@HAVE_WCRTOMB@ || @REPLACE_WCRTOMB@
-extern size_t wcrtomb (char *s, wchar_t wc, mbstate_t *ps);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcrtomb
+#   define wcrtomb rpl_wcrtomb
+#  endif
+_GL_FUNCDECL_RPL (wcrtomb, size_t, (char *s, wchar_t wc, mbstate_t *ps));
+_GL_CXXALIAS_RPL (wcrtomb, size_t, (char *s, wchar_t wc, mbstate_t *ps));
+# else
+#  if !@HAVE_WCRTOMB@
+_GL_FUNCDECL_SYS (wcrtomb, size_t, (char *s, wchar_t wc, mbstate_t *ps));
+#  endif
+_GL_CXXALIAS_SYS (wcrtomb, size_t, (char *s, wchar_t wc, mbstate_t *ps));
 # endif
+_GL_CXXALIASWARN (wcrtomb);
 #elif defined GNULIB_POSIXCHECK
 # undef wcrtomb
-# define wcrtomb(s,w,p) \
-    (GL_LINK_WARNING ("wcrtomb is unportable - " \
-                      "use gnulib module wcrtomb for portability"), \
-     wcrtomb (s, w, p))
+# if HAVE_RAW_DECL_WCRTOMB
+_GL_WARN_ON_USE (wcrtomb, "wcrtomb is unportable - "
+                 "use gnulib module wcrtomb for portability");
+# endif
 #endif
 
 
 /* Convert a wide string to a string.  */
 #if @GNULIB_WCSRTOMBS@
 # if @REPLACE_WCSRTOMBS@
-#  undef wcsrtombs
-#  define wcsrtombs rpl_wcsrtombs
-# endif
-# if !@HAVE_WCSRTOMBS@ || @REPLACE_WCSRTOMBS@
-extern size_t wcsrtombs (char *dest, const wchar_t **srcp, size_t len, mbstate_t *ps);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcsrtombs
+#   define wcsrtombs rpl_wcsrtombs
+#  endif
+_GL_FUNCDECL_RPL (wcsrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t len, mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (wcsrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t len,
+                   mbstate_t *ps));
+# else
+#  if !@HAVE_WCSRTOMBS@
+_GL_FUNCDECL_SYS (wcsrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t len, mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (wcsrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t len,
+                   mbstate_t *ps));
 # endif
+_GL_CXXALIASWARN (wcsrtombs);
 #elif defined GNULIB_POSIXCHECK
 # undef wcsrtombs
-# define wcsrtombs(d,s,l,p) \
-    (GL_LINK_WARNING ("wcsrtombs is unportable - " \
-                      "use gnulib module wcsrtombs for portability"), \
-     wcsrtombs (d, s, l, p))
+# if HAVE_RAW_DECL_WCSRTOMBS
+_GL_WARN_ON_USE (wcsrtombs, "wcsrtombs is unportable - "
+                 "use gnulib module wcsrtombs for portability");
+# endif
 #endif
 
 
 /* Convert a wide string to a string.  */
 #if @GNULIB_WCSNRTOMBS@
 # if @REPLACE_WCSNRTOMBS@
-#  undef wcsnrtombs
-#  define wcsnrtombs rpl_wcsnrtombs
-# endif
-# if !@HAVE_WCSNRTOMBS@ || @REPLACE_WCSNRTOMBS@
-extern size_t wcsnrtombs (char *dest, const wchar_t **srcp, size_t srclen, size_t len, mbstate_t *ps);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcsnrtombs
+#   define wcsnrtombs rpl_wcsnrtombs
+#  endif
+_GL_FUNCDECL_RPL (wcsnrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (wcsnrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps));
+# else
+#  if !@HAVE_WCSNRTOMBS@
+_GL_FUNCDECL_SYS (wcsnrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (wcsnrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps));
 # endif
+_GL_CXXALIASWARN (wcsnrtombs);
 #elif defined GNULIB_POSIXCHECK
 # undef wcsnrtombs
-# define wcsnrtombs(d,s,n,l,p) \
-    (GL_LINK_WARNING ("wcsnrtombs is unportable - " \
-                      "use gnulib module wcsnrtombs for portability"), \
-     wcsnrtombs (d, s, n, l, p))
+# if HAVE_RAW_DECL_WCSNRTOMBS
+_GL_WARN_ON_USE (wcsnrtombs, "wcsnrtombs is unportable - "
+                 "use gnulib module wcsnrtombs for portability");
+# endif
 #endif
 
 
 /* Return the number of screen columns needed for WC.  */
 #if @GNULIB_WCWIDTH@
 # if @REPLACE_WCWIDTH@
-#  undef wcwidth
-#  define wcwidth rpl_wcwidth
-extern int wcwidth (wchar_t);
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcwidth
+#   define wcwidth rpl_wcwidth
+#  endif
+_GL_FUNCDECL_RPL (wcwidth, int, (wchar_t));
+_GL_CXXALIAS_RPL (wcwidth, int, (wchar_t));
 # else
-#  if !defined wcwidth && !@HAVE_DECL_WCWIDTH@
+#  if !@HAVE_DECL_WCWIDTH@
 /* wcwidth exists but is not declared.  */
-extern int wcwidth (int /* actually wchar_t */);
+_GL_FUNCDECL_SYS (wcwidth, int, (wchar_t));
 #  endif
+_GL_CXXALIAS_SYS (wcwidth, int, (wchar_t));
 # endif
+_GL_CXXALIASWARN (wcwidth);
 #elif defined GNULIB_POSIXCHECK
 # undef wcwidth
-# define wcwidth(w) \
-    (GL_LINK_WARNING ("wcwidth is unportable - " \
-                      "use gnulib module wcwidth for portability"), \
-     wcwidth (w))
+# if HAVE_RAW_DECL_WCWIDTH
+_GL_WARN_ON_USE (wcwidth, "wcwidth is unportable - "
+                 "use gnulib module wcwidth for portability");
+# endif
 #endif
 
 
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* _GL_WCHAR_H */
 #endif /* _GL_WCHAR_H */
 #endif
--- a/lib/gltests/Makefile.am
+++ b/lib/gltests/Makefile.am
@@ -1,6 +1,6 @@
 ## DO NOT EDIT! GENERATED AUTOMATICALLY!
 ## Process this file with automake to produce Makefile.in.
-# Copyright (C) 2002-2009 Free Software Foundation, Inc.
+# Copyright (C) 2002-2010 Free Software Foundation, Inc.
 #
 # This file is free software, distributed under the terms of the GNU
 # General Public License.  As a special exception to the GNU General
@@ -10,10 +10,11 @@
 #
 # Generated by gnulib-tool.
 
-AUTOMAKE_OPTIONS = 1.5 foreign
+AUTOMAKE_OPTIONS = 1.5 foreign subdir-objects
 
-SUBDIRS =
+SUBDIRS = .
 TESTS =
+XFAIL_TESTS =
 TESTS_ENVIRONMENT =
 noinst_PROGRAMS =
 check_PROGRAMS =
@@ -30,6 +31,7 @@ DISTCLEANFILES =
 MAINTAINERCLEANFILES =
 
 AM_CPPFLAGS = \
+  -D@lgltests_WITNESS@=1 \
   -I. -I$(srcdir) \
   -I../.. -I$(srcdir)/../.. \
   -I../../lib/gl -I$(srcdir)/../../lib/gl
@@ -42,31 +44,89 @@ libtests_a_DEPENDENCIES = $(lgltests_LIB
 EXTRA_libtests_a_SOURCES =
 AM_LIBTOOLFLAGS = --preserve-dup-deps
 
+TESTS_ENVIRONMENT += EXEEXT='@EXEEXT@' srcdir='$(srcdir)'
+
+## begin gnulib module arg-nonnull
+
+# The BUILT_SOURCES created by this Makefile snippet are not used via #include
+# statements but through direct file reference. Therefore this snippet must be
+# present in all Makefile.am that need it. This is ensured by the applicability
+# 'all' defined above.
+
+BUILT_SOURCES += arg-nonnull.h
+# The arg-nonnull.h that gets inserted into generated .h files is the same as
+# build-aux/arg-nonnull.h, except that it has the copyright header cut off.
+arg-nonnull.h: $(top_srcdir)/build-aux/arg-nonnull.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	sed -n -e '/GL_ARG_NONNULL/,$$p' \
+	  < $(top_srcdir)/build-aux/arg-nonnull.h \
+	  > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += arg-nonnull.h arg-nonnull.h-t
+
+ARG_NONNULL_H=arg-nonnull.h
+
+EXTRA_DIST += $(top_srcdir)/build-aux/arg-nonnull.h
+
+## end   gnulib module arg-nonnull
+
+## begin gnulib module c++defs
+
+# The BUILT_SOURCES created by this Makefile snippet are not used via #include
+# statements but through direct file reference. Therefore this snippet must be
+# present in all Makefile.am that need it. This is ensured by the applicability
+# 'all' defined above.
+
+BUILT_SOURCES += c++defs.h
+# The c++defs.h that gets inserted into generated .h files is the same as
+# build-aux/c++defs.h, except that it has the copyright header cut off.
+c++defs.h: $(top_srcdir)/build-aux/c++defs.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	sed -n -e '/_GL_CXXDEFS/,$$p' \
+	  < $(top_srcdir)/build-aux/c++defs.h \
+	  > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += c++defs.h c++defs.h-t
+
+CXXDEFS_H=c++defs.h
+
+EXTRA_DIST += $(top_srcdir)/build-aux/c++defs.h
+
+## end   gnulib module c++defs
+
 ## begin gnulib module c-ctype-tests
 
 TESTS += test-c-ctype
 check_PROGRAMS += test-c-ctype
 
-EXTRA_DIST += test-c-ctype.c
+EXTRA_DIST += test-c-ctype.c macros.h
 
 ## end   gnulib module c-ctype-tests
 
 ## begin gnulib module c-strcase-tests
 
 TESTS += test-c-strcase.sh
-TESTS_ENVIRONMENT += EXEEXT='@EXEEXT@' LOCALE_FR='@LOCALE_FR@' LOCALE_TR_UTF8='@LOCALE_TR_UTF8@'
+TESTS_ENVIRONMENT += LOCALE_FR='@LOCALE_FR@' LOCALE_TR_UTF8='@LOCALE_TR_UTF8@'
 check_PROGRAMS += test-c-strcasecmp test-c-strncasecmp
-EXTRA_DIST += test-c-strcase.sh test-c-strcasecmp.c test-c-strncasecmp.c
+EXTRA_DIST += test-c-strcase.sh test-c-strcasecmp.c test-c-strncasecmp.c macros.h
 
 ## end   gnulib module c-strcase-tests
 
+## begin gnulib module iconv-h-tests
+
+TESTS += test-iconv-h
+check_PROGRAMS += test-iconv-h
+EXTRA_DIST += test-iconv-h.c
+
+## end   gnulib module iconv-h-tests
+
 ## begin gnulib module iconv-tests
 
 TESTS += test-iconv
 check_PROGRAMS += test-iconv
 test_iconv_LDADD = $(LDADD) @LIBICONV@
 
-EXTRA_DIST += test-iconv.c
+EXTRA_DIST += test-iconv.c signature.h macros.h
 
 ## end   gnulib module iconv-tests
 
@@ -81,16 +141,22 @@ EXTRA_DIST += intprops.h
 
 TESTS += test-stdbool
 check_PROGRAMS += test-stdbool
-
 EXTRA_DIST += test-stdbool.c
 
 ## end   gnulib module stdbool-tests
 
+## begin gnulib module stddef-tests
+
+TESTS += test-stddef
+check_PROGRAMS += test-stddef
+EXTRA_DIST += test-stddef.c
+
+## end   gnulib module stddef-tests
+
 ## begin gnulib module stdint-tests
 
 TESTS += test-stdint
 check_PROGRAMS += test-stdint
-
 EXTRA_DIST += test-stdint.c
 
 ## end   gnulib module stdint-tests
@@ -101,7 +167,7 @@ TESTS += test-striconv
 check_PROGRAMS += test-striconv
 test_striconv_LDADD = $(LDADD) @LIBICONV@
 
-EXTRA_DIST += test-striconv.c
+EXTRA_DIST += test-striconv.c macros.h
 
 ## end   gnulib module striconv-tests
 
@@ -109,7 +175,6 @@ EXTRA_DIST += test-striconv.c
 
 TESTS += test-string
 check_PROGRAMS += test-string
-
 EXTRA_DIST += test-string.c
 
 ## end   gnulib module string-tests
@@ -118,21 +183,83 @@ EXTRA_DIST += test-string.c
 
 TESTS += test-strverscmp
 check_PROGRAMS += test-strverscmp
-EXTRA_DIST += test-strverscmp.c
+EXTRA_DIST += test-strverscmp.c signature.h macros.h
 
 ## end   gnulib module strverscmp-tests
 
+## begin gnulib module unistr/u8-check-tests
+
+TESTS += test-u8-check
+check_PROGRAMS += test-u8-check
+test_u8_check_SOURCES = unistr/test-u8-check.c
+test_u8_check_LDADD = $(LDADD) $(LIBUNISTRING)
+EXTRA_DIST += unistr/test-u8-check.c macros.h
+
+## end   gnulib module unistr/u8-check-tests
+
+## begin gnulib module unused-parameter
+
+# The BUILT_SOURCES created by this Makefile snippet are not used via #include
+# statements but through direct file reference. Therefore this snippet must be
+# present in all Makefile.am that need it. This is ensured by the applicability
+# 'all' defined above.
+
+BUILT_SOURCES += unused-parameter.h
+# The unused-parameter.h that gets inserted into generated .h files is the same
+# as build-aux/unused-parameter.h, except that it has the copyright header cut
+# off.
+unused-parameter.h: $(top_srcdir)/build-aux/unused-parameter.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	sed -n -e '/GL_UNUSED_PARAMETER/,$$p' \
+	  < $(top_srcdir)/build-aux/unused-parameter.h \
+	  > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += unused-parameter.h unused-parameter.h-t
+
+UNUSED_PARAMETER_H=unused-parameter.h
+
+EXTRA_DIST += $(top_srcdir)/build-aux/unused-parameter.h
+
+## end   gnulib module unused-parameter
+
 ## begin gnulib module verify
 
 libtests_a_SOURCES += verify.h
 
 ## end   gnulib module verify
 
+## begin gnulib module verify-tests
+
+TESTS_ENVIRONMENT += MAKE='$(MAKE)'
+TESTS += test-verify test-verify.sh
+check_PROGRAMS += test-verify
+EXTRA_DIST += test-verify.c test-verify.sh init.sh
+
+## end   gnulib module verify-tests
+
+## begin gnulib module warn-on-use
+
+BUILT_SOURCES += warn-on-use.h
+# The warn-on-use.h that gets inserted into generated .h files is the same as
+# build-aux/warn-on-use.h, except that it has the copyright header cut off.
+warn-on-use.h: $(top_srcdir)/build-aux/warn-on-use.h
+	$(AM_V_GEN)rm -f $@-t $@ && \
+	sed -n -e '/^.ifndef/,$$p' \
+	  < $(top_srcdir)/build-aux/warn-on-use.h \
+	  > $@-t && \
+	mv $@-t $@
+MOSTLYCLEANFILES += warn-on-use.h warn-on-use.h-t
+
+WARN_ON_USE_H=warn-on-use.h
+
+EXTRA_DIST += $(top_srcdir)/build-aux/warn-on-use.h
+
+## end   gnulib module warn-on-use
+
 ## begin gnulib module wchar-tests
 
 TESTS += test-wchar
 check_PROGRAMS += test-wchar
-
 EXTRA_DIST += test-wchar.c
 
 ## end   gnulib module wchar-tests
--- a/lib/gltests/dummy.c
+++ b/lib/gltests/dummy.c
@@ -1,5 +1,5 @@
 /* A dummy file, to prevent empty libraries from breaking builds.
-   Copyright (C) 2004, 2007 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2007, 2009, 2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
--- /dev/null
+++ b/lib/gltests/init.sh
@@ -0,0 +1,387 @@
+# source this file; set up for tests
+
+# Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# Using this file in a test
+# =========================
+#
+# The typical skeleton of a test looks like this:
+#
+#   #!/bin/sh
+#   . "${srcdir=.}/init.sh"; path_prepend_ .
+#   Execute some commands.
+#   Note that these commands are executed in a subdirectory, therefore you
+#   need to prepend "../" to relative filenames in the build directory.
+#   Note that the "path_prepend_ ." is useful only if the body of your
+#   test invokes programs residing in the initial directory.
+#   For example, if the programs you want to test are in src/, and this test
+#   script is named tests/test-1, then you would use "path_prepend_ ../src",
+#   or perhaps export PATH='$(abs_top_builddir)/src$(PATH_SEPARATOR)'"$$PATH"
+#   to all tests via automake's TESTS_ENVIRONMENT.
+#   Set the exit code 0 for success, 77 for skipped, or 1 or other for failure.
+#   Use the skip_ and fail_ functions to print a diagnostic and then exit
+#   with the corresponding exit code.
+#   Exit $?
+
+# Executing a test that uses this file
+# ====================================
+#
+# Running a single test:
+#   $ make check TESTS=test-foo.sh
+#
+# Running a single test, with verbose output:
+#   $ make check TESTS=test-foo.sh VERBOSE=yes
+#
+# Running a single test, with single-stepping:
+#   1. Go into a sub-shell:
+#   $ bash
+#   2. Set relevant environment variables from TESTS_ENVIRONMENT in the
+#      Makefile:
+#   $ export srcdir=../../tests # this is an example
+#   3. Execute the commands from the test, copy&pasting them one by one:
+#   $ . "$srcdir/init.sh"; path_prepend_ .
+#   ...
+#   4. Finally
+#   $ exit
+
+ME_=`expr "./$0" : '.*/\(.*\)$'`
+
+# We use a trap below for cleanup.  This requires us to go through
+# hoops to get the right exit status transported through the handler.
+# So use `Exit STATUS' instead of `exit STATUS' inside of the tests.
+# Turn off errexit here so that we don't trip the bug with OSF1/Tru64
+# sh inside this function.
+Exit () { set +e; (exit $1); exit $1; }
+
+# Print warnings (e.g., about skipped and failed tests) to this file number.
+# Override by defining to say, 9, in init.cfg, and putting say,
+# "export ...ENVVAR_SETTINGS...; exec 9>&2; $(SHELL)" in the definition
+# of TESTS_ENVIRONMENT in your tests/Makefile.am file.
+# This is useful when using automake's parallel tests mode, to print
+# the reason for skip/failure to console, rather than to the .log files.
+: ${stderr_fileno_=2}
+
+warn_() { echo "$@" 1>&$stderr_fileno_; }
+fail_() { warn_ "$ME_: failed test: $@"; Exit 1; }
+skip_() { warn_ "$ME_: skipped test: $@"; Exit 77; }
+framework_failure_() { warn_ "$ME_: set-up failure: $@"; Exit 99; }
+
+# We require $(...) support unconditionally.
+# We require a few additional shell features only when $EXEEXT is nonempty,
+# in order to support automatic $EXEEXT emulation:
+# - hyphen-containing alias names
+# - we prefer to use ${var#...} substitution, rather than having
+#   to work around lack of support for that feature.
+# The following code attempts to find a shell with support for these features.
+# If the current shell passes the test, we're done.  Otherwise, test other
+# shells until we find one that passes.  If one is found, re-exec it.
+# If no acceptable shell is found, skip the current test.
+#
+# Use "9" to indicate success (rather than 0), in case some shell acts
+# like Solaris 10's /bin/sh but exits successfully instead of with status 2.
+
+gl_shell_test_script_='
+test $(echo y) = y || exit 1
+test -z "$EXEEXT" && exit 9
+shopt -s expand_aliases
+alias a-b="echo zoo"
+v=abx
+     test ${v%x} = ab \
+  && test ${v#a} = bx \
+  && test $(a-b) = zoo \
+  && exit 9
+'
+
+if test "x$1" = "x--no-reexec"; then
+  shift
+else
+  # 'eval'ing the above code makes Solaris 10's /bin/sh exit with $? set to 2.
+  # It does not evaluate any of the code after the "unexpected" `('.  Thus,
+  # we must run it in a subshell.
+  ( eval "$gl_shell_test_script_" ) > /dev/null 2>&1
+  if test $? = 9; then
+    : # The current shell is adequate.  No re-exec required.
+  else
+    # Search for a shell that meets our requirements.
+    for re_shell_ in "${CONFIG_SHELL:-no_shell}" /bin/sh bash dash zsh pdksh fail
+    do
+      test "$re_shell_" = no_shell && continue
+      test "$re_shell_" = fail && skip_ failed to find an adequate shell
+      "$re_shell_" -c "$gl_shell_test_script_" 2>/dev/null
+      if test $? = 9; then
+        # Found an acceptable shell.
+        exec "$re_shell_" "$0" --no-reexec "$@"
+        echo "$ME_: exec failed" 1>&2
+        exit 127
+      fi
+    done
+  fi
+fi
+
+test -n "$EXEEXT" && shopt -s expand_aliases
+
+# Enable glibc's malloc-perturbing option.
+# This is cheap and useful for exposing code that depends on the fact that
+# malloc-related functions often return memory that is mostly zeroed.
+# If you have the time and cycles, use valgrind to do an even better job.
+: ${MALLOC_PERTURB_=87}
+export MALLOC_PERTURB_
+
+# This is a stub function that is run upon trap (upon regular exit and
+# interrupt).  Override it with a per-test function, e.g., to unmount
+# a partition, or to undo any other global state changes.
+cleanup_() { :; }
+
+if ( diff --version < /dev/null 2>&1 | grep GNU ) > /dev/null 2>&1; then
+  compare() { diff -u "$@"; }
+elif ( cmp --version < /dev/null 2>&1 | grep GNU ) > /dev/null 2>&1; then
+  compare() { cmp -s "$@"; }
+else
+  compare() { cmp "$@"; }
+fi
+
+# An arbitrary prefix to help distinguish test directories.
+testdir_prefix_() { printf gt; }
+
+# Run the user-overridable cleanup_ function, remove the temporary
+# directory and exit with the incoming value of $?.
+remove_tmp_()
+{
+  __st=$?
+  cleanup_
+  # cd out of the directory we're about to remove
+  cd "$initial_cwd_" || cd / || cd /tmp
+  chmod -R u+rwx "$test_dir_"
+  # If removal fails and exit status was to be 0, then change it to 1.
+  rm -rf "$test_dir_" || { test $__st = 0 && __st=1; }
+  exit $__st
+}
+
+# Given a directory name, DIR, if every entry in it that matches *.exe
+# contains only the specified bytes (see the case stmt below), then print
+# a space-separated list of those names and return 0.  Otherwise, don't
+# print anything and return 1.  Naming constraints apply also to DIR.
+find_exe_basenames_()
+{
+  feb_dir_=$1
+  feb_fail_=0
+  feb_result_=
+  feb_sp_=
+  for feb_file_ in $feb_dir_/*.exe; do
+    case $feb_file_ in
+      *[!-a-zA-Z/0-9_.+]*) feb_fail_=1; break;;
+      *) # Remove leading file name components as well as the .exe suffix.
+         feb_file_=${feb_file_##*/}
+         feb_file_=${feb_file_%.exe}
+         feb_result_="$feb_result_$feb_sp_$feb_file_";;
+    esac
+    feb_sp_=' '
+  done
+  test $feb_fail_ = 0 && printf %s "$feb_result_"
+  return $feb_fail_
+}
+
+# Consider the files in directory, $1.
+# For each file name of the form PROG.exe, create an alias named
+# PROG that simply invokes PROG.exe, then return 0.  If any selected
+# file name or the directory name, $1, contains an unexpected character,
+# define no function and return 1.
+create_exe_shims_()
+{
+  case $EXEEXT in
+    '') return 0 ;;
+    .exe) ;;
+    *) echo "$0: unexpected \$EXEEXT value: $EXEEXT" 1>&2; return 1 ;;
+  esac
+
+  base_names_=`find_exe_basenames_ $1` \
+    || { echo "$0 (exe_shim): skipping directory: $1" 1>&2; return 1; }
+
+  if test -n "$base_names_"; then
+    for base_ in $base_names_; do
+      alias "$base_"="$base_$EXEEXT"
+    done
+  fi
+
+  return 0
+}
+
+# Use this function to prepend to PATH an absolute name for each
+# specified, possibly-$initial_cwd_-relative, directory.
+path_prepend_()
+{
+  while test $# != 0; do
+    path_dir_=$1
+    case $path_dir_ in
+      '') fail_ "invalid path dir: '$1'";;
+      /*) abs_path_dir_=$path_dir_;;
+      *) abs_path_dir_=`cd "$initial_cwd_/$path_dir_" && echo "$PWD"` \
+           || fail_ "invalid path dir: $path_dir_";;
+    esac
+    case $abs_path_dir_ in
+      *:*) fail_ "invalid path dir: '$abs_path_dir_'";;
+    esac
+    PATH="$abs_path_dir_:$PATH"
+
+    # Create an alias, FOO, for each FOO.exe in this directory.
+    create_exe_shims_ "$abs_path_dir_" \
+      || fail_ "something failed (above): $abs_path_dir_"
+    shift
+  done
+  export PATH
+}
+
+setup_()
+{
+  test "$VERBOSE" = yes && set -x
+
+  initial_cwd_=$PWD
+
+  pfx_=`testdir_prefix_`
+  test_dir_=`mktempd_ "$initial_cwd_" "$pfx_-$ME_.XXXX"` \
+    || fail_ "failed to create temporary directory in $initial_cwd_"
+  cd "$test_dir_"
+
+  # These trap statements ensure that the temporary directory, $test_dir_,
+  # is removed upon exit as well as upon receipt of any of the listed signals.
+  trap remove_tmp_ 0
+  for sig_ in 1 2 3 13 15; do
+    eval "trap 'Exit $(expr $sig_ + 128)' $sig_"
+  done
+}
+
+# Create a temporary directory, much like mktemp -d does.
+# Written by Jim Meyering.
+#
+# Usage: mktempd_ /tmp phoey.XXXXXXXXXX
+#
+# First, try to use the mktemp program.
+# Failing that, we'll roll our own mktemp-like function:
+#  - try to get random bytes from /dev/urandom
+#  - failing that, generate output from a combination of quickly-varying
+#      sources and gzip.  Ignore non-varying gzip header, and extract
+#      "random" bits from there.
+#  - given those bits, map to file-name bytes using tr, and try to create
+#      the desired directory.
+#  - make only $MAX_TRIES_ attempts
+
+# Helper function.  Print $N pseudo-random bytes from a-zA-Z0-9.
+rand_bytes_()
+{
+  n_=$1
+
+  # Maybe try openssl rand -base64 $n_prime_|tr '+/=\012' abcd first?
+  # But if they have openssl, they probably have mktemp, too.
+
+  chars_=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
+  dev_rand_=/dev/urandom
+  if test -r "$dev_rand_"; then
+    # Note: 256-length($chars_) == 194; 3 copies of $chars_ is 186 + 8 = 194.
+    dd ibs=$n_ count=1 if=$dev_rand_ 2>/dev/null \
+      | LC_ALL=C tr -c $chars_ 01234567$chars_$chars_$chars_
+    return
+  fi
+
+  n_plus_50_=`expr $n_ + 50`
+  cmds_='date; date +%N; free; who -a; w; ps auxww; ps ef; netstat -n'
+  data_=` (eval "$cmds_") 2>&1 | gzip `
+
+  # Ensure that $data_ has length at least 50+$n_
+  while :; do
+    len_=`echo "$data_"|wc -c`
+    test $n_plus_50_ -le $len_ && break;
+    data_=` (echo "$data_"; eval "$cmds_") 2>&1 | gzip `
+  done
+
+  echo "$data_" \
+    | dd bs=1 skip=50 count=$n_ 2>/dev/null \
+    | LC_ALL=C tr -c $chars_ 01234567$chars_$chars_$chars_
+}
+
+mktempd_()
+{
+  case $# in
+  2);;
+  *) fail_ "Usage: $ME DIR TEMPLATE";;
+  esac
+
+  destdir_=$1
+  template_=$2
+
+  MAX_TRIES_=4
+
+  # Disallow any trailing slash on specified destdir:
+  # it would subvert the post-mktemp "case"-based destdir test.
+  case $destdir_ in
+  /) ;;
+  */) fail_ "invalid destination dir: remove trailing slash(es)";;
+  esac
+
+  case $template_ in
+  *XXXX) ;;
+  *) fail_ "invalid template: $template_ (must have a suffix of at least 4 X's)";;
+  esac
+
+  fail=0
+
+  # First, try to use mktemp.
+  d=`unset TMPDIR; mktemp -d -t -p "$destdir_" "$template_" 2>/dev/null` \
+    || fail=1
+
+  # The resulting name must be in the specified directory.
+  case $d in "$destdir_"*);; *) fail=1;; esac
+
+  # It must have created the directory.
+  test -d "$d" || fail=1
+
+  # It must have 0700 permissions.  Handle sticky "S" bits.
+  perms=`ls -dgo "$d" 2>/dev/null|tr S -` || fail=1
+  case $perms in drwx------*) ;; *) fail=1;; esac
+
+  test $fail = 0 && {
+    echo "$d"
+    return
+  }
+
+  # If we reach this point, we'll have to create a directory manually.
+
+  # Get a copy of the template without its suffix of X's.
+  base_template_=`echo "$template_"|sed 's/XX*$//'`
+
+  # Calculate how many X's we've just removed.
+  template_length_=`echo "$template_" | wc -c`
+  nx_=`echo "$base_template_" | wc -c`
+  nx_=`expr $template_length_ - $nx_`
+
+  err_=
+  i_=1
+  while :; do
+    X_=`rand_bytes_ $nx_`
+    candidate_dir_="$destdir_/$base_template_$X_"
+    err_=`mkdir -m 0700 "$candidate_dir_" 2>&1` \
+      && { echo "$candidate_dir_"; return; }
+    test $MAX_TRIES_ -le $i_ && break;
+    i_=`expr $i_ + 1`
+  done
+  fail_ "$err_"
+}
+
+# If you want to override the testdir_prefix_ function,
+# or to add more utility functions, use this file.
+test -f "$srcdir/init.cfg" \
+  && . "$srcdir/init.cfg"
+
+setup_ "$@"
--- a/lib/gltests/intprops.h
+++ b/lib/gltests/intprops.h
@@ -1,6 +1,7 @@
 /* intprops.h -- properties of integer types
 
-   Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2009, 2010 Free Software
+   Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -17,40 +18,43 @@
 
 /* Written by Paul Eggert.  */
 
-#include <limits.h>
+#ifndef GL_INTPROPS_H
+# define GL_INTPROPS_H
+
+# include <limits.h>
 
 /* The extra casts in the following macros work around compiler bugs,
    e.g., in Cray C 5.0.3.0.  */
 
 /* True if the arithmetic type T is an integer type.  bool counts as
    an integer.  */
-#define TYPE_IS_INTEGER(t) ((t) 1.5 == 1)
+# define TYPE_IS_INTEGER(t) ((t) 1.5 == 1)
 
 /* True if negative values of the signed integer type T use two's
    complement, ones' complement, or signed magnitude representation,
    respectively.  Much GNU code assumes two's complement, but some
    people like to be portable to all possible C hosts.  */
-#define TYPE_TWOS_COMPLEMENT(t) ((t) ~ (t) 0 == (t) -1)
-#define TYPE_ONES_COMPLEMENT(t) ((t) ~ (t) 0 == 0)
-#define TYPE_SIGNED_MAGNITUDE(t) ((t) ~ (t) 0 < (t) -1)
+# define TYPE_TWOS_COMPLEMENT(t) ((t) ~ (t) 0 == (t) -1)
+# define TYPE_ONES_COMPLEMENT(t) ((t) ~ (t) 0 == 0)
+# define TYPE_SIGNED_MAGNITUDE(t) ((t) ~ (t) 0 < (t) -1)
 
 /* True if the arithmetic type T is signed.  */
-#define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
+# define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
 
 /* The maximum and minimum values for the integer type T.  These
    macros have undefined behavior if T is signed and has padding bits.
    If this is a problem for you, please let us know how to fix it for
    your host.  */
-#define TYPE_MINIMUM(t) \
+# define TYPE_MINIMUM(t) \
   ((t) (! TYPE_SIGNED (t) \
-	? (t) 0 \
-	: TYPE_SIGNED_MAGNITUDE (t) \
-	? ~ (t) 0 \
-	: ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1)))
-#define TYPE_MAXIMUM(t) \
+        ? (t) 0 \
+        : TYPE_SIGNED_MAGNITUDE (t) \
+        ? ~ (t) 0 \
+        : ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1)))
+# define TYPE_MAXIMUM(t) \
   ((t) (! TYPE_SIGNED (t) \
-	? (t) -1 \
-	: ~ (~ (t) 0 << (sizeof (t) * CHAR_BIT - 1))))
+        ? (t) -1 \
+        : ~ (~ (t) 0 << (sizeof (t) * CHAR_BIT - 1))))
 
 /* Return zero if T can be determined to be an unsigned type.
    Otherwise, return 1.
@@ -58,20 +62,22 @@
    tighter bound.  Otherwise, it overestimates the true bound by one byte
    when applied to unsigned types of size 2, 4, 16, ... bytes.
    The symbol signed_type_or_expr__ is private to this header file.  */
-#if __GNUC__ >= 2
-# define signed_type_or_expr__(t) TYPE_SIGNED (__typeof__ (t))
-#else
-# define signed_type_or_expr__(t) 1
-#endif
+# if __GNUC__ >= 2
+#  define signed_type_or_expr__(t) TYPE_SIGNED (__typeof__ (t))
+# else
+#  define signed_type_or_expr__(t) 1
+# endif
 
 /* Bound on length of the string representing an integer type or expression T.
    Subtract 1 for the sign bit if T is signed; log10 (2.0) < 146/485;
    add 1 for integer division truncation; add 1 more for a minus sign
    if needed.  */
-#define INT_STRLEN_BOUND(t) \
+# define INT_STRLEN_BOUND(t) \
   ((sizeof (t) * CHAR_BIT - signed_type_or_expr__ (t)) * 146 / 485 \
    + signed_type_or_expr__ (t) + 1)
 
 /* Bound on buffer size needed to represent an integer type or expression T,
    including the terminating null.  */
-#define INT_BUFSIZE_BOUND(t) (INT_STRLEN_BOUND (t) + 1)
+# define INT_BUFSIZE_BOUND(t) (INT_STRLEN_BOUND (t) + 1)
+
+#endif /* GL_INTPROPS_H */
--- /dev/null
+++ b/lib/gltests/macros.h
@@ -0,0 +1,64 @@
+/* Common macros used by gnulib tests.
+   Copyright (C) 2006-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+
+/* This file contains macros that are used by many gnulib tests.
+   Put here only frequently used macros, say, used by 10 tests or more.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* Define ASSERT_STREAM before including this file if ASSERT must
+   target a stream other than stderr.  */
+#ifndef ASSERT_STREAM
+# define ASSERT_STREAM stderr
+#endif
+
+/* ASSERT (condition);
+   verifies that the specified condition is fulfilled.  If not, a message
+   is printed to ASSERT_STREAM if defined (defaulting to stderr if
+   undefined) and the program is terminated with an error code.
+
+   This macro has the following properties:
+     - The programmer specifies the expected condition, not the failure
+       condition.  This simplifies thinking.
+     - The condition is tested always, regardless of compilation flags.
+       (Unlike the macro from <assert.h>.)
+     - On Unix platforms, the tester can debug the test program with a
+       debugger (provided core dumps are enabled: "ulimit -c unlimited").
+     - For the sake of platforms where no debugger is available (such as
+       some mingw systems), an error message is printed on the error
+       stream that includes the source location of the ASSERT invocation.
+ */
+#define ASSERT(expr) \
+  do                                                                         \
+    {                                                                        \
+      if (!(expr))                                                           \
+        {                                                                    \
+          fprintf (ASSERT_STREAM, "%s:%d: assertion failed\n",               \
+                   __FILE__, __LINE__);                                      \
+          fflush (ASSERT_STREAM);                                            \
+          abort ();                                                          \
+        }                                                                    \
+    }                                                                        \
+  while (0)
+
+/* SIZEOF (array)
+   returns the number of elements of an array.  It works for arrays that are
+   declared outside functions and for local variables of array type.  It does
+   *not* work for function parameters of array type, because they are actually
+   parameters of pointer type.  */
+#define SIZEOF(array) (sizeof (array) / sizeof (array[0]))
--- /dev/null
+++ b/lib/gltests/signature.h
@@ -0,0 +1,48 @@
+/* Macro for checking that a function declaration is compliant.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef SIGNATURE_CHECK
+
+/* Check that the function FN takes the specified arguments ARGS with
+   a return type of RET.  This header is designed to be included after
+   <config.h> and the one system header that is supposed to contain
+   the function being checked, but prior to any other system headers
+   that are necessary for the unit test.  Therefore, this file does
+   not include any system headers, nor reference anything outside of
+   the macro arguments.  For an example, if foo.h should provide:
+
+   extern int foo (char, float);
+
+   then the unit test named test-foo.c would start out with:
+
+   #include <config.h>
+   #include <foo.h>
+   #include "signature.h"
+   SIGNATURE_CHECK (foo, int, (char, float));
+   #include <other.h>
+   ...
+*/
+# define SIGNATURE_CHECK(fn, ret, args) \
+  SIGNATURE_CHECK1 (fn, ret, args, __LINE__)
+
+/* Necessary to allow multiple SIGNATURE_CHECK lines in a unit test.
+   Note that the checks must not occupy the same line.  */
+# define SIGNATURE_CHECK1(fn, ret, args, id) \
+  SIGNATURE_CHECK2 (fn, ret, args, id) /* macroexpand line */
+# define SIGNATURE_CHECK2(fn, ret, args, id) \
+  static ret (* _GL_UNUSED signature_check ## id) args = fn
+
+#endif /* SIGNATURE_CHECK */
--- a/lib/gltests/test-c-ctype.c
+++ b/lib/gltests/test-c-ctype.c
@@ -1,5 +1,5 @@
 /* Test of character handling in C locale.
-   Copyright (C) 2005, 2007-2008 Free Software Foundation, Inc.
+   Copyright (C) 2005, 2007-2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -21,20 +21,8 @@
 #include "c-ctype.h"
 
 #include <locale.h>
-#include <stdio.h>
-#include <stdlib.h>
 
-#define ASSERT(expr) \
-  do									     \
-    {									     \
-      if (!(expr))							     \
-        {								     \
-          fprintf (stderr, "%s:%d: assertion failed\n", __FILE__, __LINE__); \
-          fflush (stderr);						     \
-          abort ();							     \
-        }								     \
-    }									     \
-  while (0)
+#include "macros.h"
 
 static void
 test_all (void)
@@ -46,81 +34,81 @@ test_all (void)
       ASSERT (c_isascii (c) == (c >= 0 && c < 0x80));
 
       switch (c)
-	{
-	case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
-	case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
-	case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
-	case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
-	case 'Y': case 'Z':
-	case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
-	case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
-	case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
-	case 's': case 't': case 'u': case 'v': case 'w': case 'x':
-	case 'y': case 'z':
-	case '0': case '1': case '2': case '3': case '4': case '5':
-	case '6': case '7': case '8': case '9':
-	  ASSERT (c_isalnum (c) == 1);
-	  break;
-	default:
-	  ASSERT (c_isalnum (c) == 0);
-	  break;
-	}
+        {
+        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
+        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
+        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
+        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
+        case 'Y': case 'Z':
+        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
+        case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
+        case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
+        case 's': case 't': case 'u': case 'v': case 'w': case 'x':
+        case 'y': case 'z':
+        case '0': case '1': case '2': case '3': case '4': case '5':
+        case '6': case '7': case '8': case '9':
+          ASSERT (c_isalnum (c) == 1);
+          break;
+        default:
+          ASSERT (c_isalnum (c) == 0);
+          break;
+        }
 
       switch (c)
-	{
-	case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
-	case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
-	case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
-	case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
-	case 'Y': case 'Z':
-	case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
-	case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
-	case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
-	case 's': case 't': case 'u': case 'v': case 'w': case 'x':
-	case 'y': case 'z':
-	  ASSERT (c_isalpha (c) == 1);
-	  break;
-	default:
-	  ASSERT (c_isalpha (c) == 0);
-	  break;
-	}
+        {
+        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
+        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
+        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
+        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
+        case 'Y': case 'Z':
+        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
+        case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
+        case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
+        case 's': case 't': case 'u': case 'v': case 'w': case 'x':
+        case 'y': case 'z':
+          ASSERT (c_isalpha (c) == 1);
+          break;
+        default:
+          ASSERT (c_isalpha (c) == 0);
+          break;
+        }
 
       switch (c)
-	{
-	case '\t': case ' ':
-	  ASSERT (c_isblank (c) == 1);
-	  break;
-	default:
-	  ASSERT (c_isblank (c) == 0);
-	  break;
-	}
+        {
+        case '\t': case ' ':
+          ASSERT (c_isblank (c) == 1);
+          break;
+        default:
+          ASSERT (c_isblank (c) == 0);
+          break;
+        }
 
       ASSERT (c_iscntrl (c) == ((c >= 0 && c < 0x20) || c == 0x7f));
 
       switch (c)
-	{
-	case '0': case '1': case '2': case '3': case '4': case '5':
-	case '6': case '7': case '8': case '9':
-	  ASSERT (c_isdigit (c) == 1);
-	  break;
-	default:
-	  ASSERT (c_isdigit (c) == 0);
-	  break;
-	}
+        {
+        case '0': case '1': case '2': case '3': case '4': case '5':
+        case '6': case '7': case '8': case '9':
+          ASSERT (c_isdigit (c) == 1);
+          break;
+        default:
+          ASSERT (c_isdigit (c) == 0);
+          break;
+        }
 
       switch (c)
-	{
-	case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
-	case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
-	case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
-	case 's': case 't': case 'u': case 'v': case 'w': case 'x':
-	case 'y': case 'z':
-	  ASSERT (c_islower (c) == 1);
-	  break;
-	default:
-	  ASSERT (c_islower (c) == 0);
-	  break;
-	}
+        {
+        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
+        case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
+        case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
+        case 's': case 't': case 'u': case 'v': case 'w': case 'x':
+        case 'y': case 'z':
+          ASSERT (c_islower (c) == 1);
+          break;
+        default:
+          ASSERT (c_islower (c) == 0);
+          break;
+        }
 
       ASSERT (c_isgraph (c) == ((c >= 0x20 && c < 0x7f) && c != ' '));
 
@@ -129,257 +117,257 @@ test_all (void)
       ASSERT (c_ispunct (c) == (c_isgraph (c) && !c_isalnum (c)));
 
       switch (c)
-	{
-	case ' ': case '\t': case '\n': case '\v': case '\f': case '\r':
-	  ASSERT (c_isspace (c) == 1);
-	  break;
-	default:
-	  ASSERT (c_isspace (c) == 0);
-	  break;
-	}
+        {
+        case ' ': case '\t': case '\n': case '\v': case '\f': case '\r':
+          ASSERT (c_isspace (c) == 1);
+          break;
+        default:
+          ASSERT (c_isspace (c) == 0);
+          break;
+        }
 
       switch (c)
-	{
-	case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
-	case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
-	case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
-	case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
-	case 'Y': case 'Z':
-	  ASSERT (c_isupper (c) == 1);
-	  break;
-	default:
-	  ASSERT (c_isupper (c) == 0);
-	  break;
-	}
+        {
+        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
+        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
+        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
+        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
+        case 'Y': case 'Z':
+          ASSERT (c_isupper (c) == 1);
+          break;
+        default:
+          ASSERT (c_isupper (c) == 0);
+          break;
+        }
 
       switch (c)
-	{
-	case '0': case '1': case '2': case '3': case '4': case '5':
-	case '6': case '7': case '8': case '9':
-	case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
-	case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
-	  ASSERT (c_isxdigit (c) == 1);
-	  break;
-	default:
-	  ASSERT (c_isxdigit (c) == 0);
-	  break;
-	}
+        {
+        case '0': case '1': case '2': case '3': case '4': case '5':
+        case '6': case '7': case '8': case '9':
+        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
+        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
+          ASSERT (c_isxdigit (c) == 1);
+          break;
+        default:
+          ASSERT (c_isxdigit (c) == 0);
+          break;
+        }
 
       switch (c)
-	{
-	case 'A':
-	  ASSERT (c_tolower (c) == 'a');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'B':
-	  ASSERT (c_tolower (c) == 'b');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'C':
-	  ASSERT (c_tolower (c) == 'c');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'D':
-	  ASSERT (c_tolower (c) == 'd');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'E':
-	  ASSERT (c_tolower (c) == 'e');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'F':
-	  ASSERT (c_tolower (c) == 'f');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'G':
-	  ASSERT (c_tolower (c) == 'g');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'H':
-	  ASSERT (c_tolower (c) == 'h');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'I':
-	  ASSERT (c_tolower (c) == 'i');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'J':
-	  ASSERT (c_tolower (c) == 'j');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'K':
-	  ASSERT (c_tolower (c) == 'k');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'L':
-	  ASSERT (c_tolower (c) == 'l');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'M':
-	  ASSERT (c_tolower (c) == 'm');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'N':
-	  ASSERT (c_tolower (c) == 'n');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'O':
-	  ASSERT (c_tolower (c) == 'o');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'P':
-	  ASSERT (c_tolower (c) == 'p');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'Q':
-	  ASSERT (c_tolower (c) == 'q');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'R':
-	  ASSERT (c_tolower (c) == 'r');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'S':
-	  ASSERT (c_tolower (c) == 's');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'T':
-	  ASSERT (c_tolower (c) == 't');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'U':
-	  ASSERT (c_tolower (c) == 'u');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'V':
-	  ASSERT (c_tolower (c) == 'v');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'W':
-	  ASSERT (c_tolower (c) == 'w');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'X':
-	  ASSERT (c_tolower (c) == 'x');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'Y':
-	  ASSERT (c_tolower (c) == 'y');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'Z':
-	  ASSERT (c_tolower (c) == 'z');
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	case 'a':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'A');
-	  break;
-	case 'b':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'B');
-	  break;
-	case 'c':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'C');
-	  break;
-	case 'd':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'D');
-	  break;
-	case 'e':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'E');
-	  break;
-	case 'f':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'F');
-	  break;
-	case 'g':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'G');
-	  break;
-	case 'h':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'H');
-	  break;
-	case 'i':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'I');
-	  break;
-	case 'j':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'J');
-	  break;
-	case 'k':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'K');
-	  break;
-	case 'l':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'L');
-	  break;
-	case 'm':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'M');
-	  break;
-	case 'n':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'N');
-	  break;
-	case 'o':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'O');
-	  break;
-	case 'p':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'P');
-	  break;
-	case 'q':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'Q');
-	  break;
-	case 'r':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'R');
-	  break;
-	case 's':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'S');
-	  break;
-	case 't':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'T');
-	  break;
-	case 'u':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'U');
-	  break;
-	case 'v':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'V');
-	  break;
-	case 'w':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'W');
-	  break;
-	case 'x':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'X');
-	  break;
-	case 'y':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'Y');
-	  break;
-	case 'z':
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == 'Z');
-	  break;
-	default:
-	  ASSERT (c_tolower (c) == c);
-	  ASSERT (c_toupper (c) == c);
-	  break;
-	}
+        {
+        case 'A':
+          ASSERT (c_tolower (c) == 'a');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'B':
+          ASSERT (c_tolower (c) == 'b');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'C':
+          ASSERT (c_tolower (c) == 'c');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'D':
+          ASSERT (c_tolower (c) == 'd');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'E':
+          ASSERT (c_tolower (c) == 'e');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'F':
+          ASSERT (c_tolower (c) == 'f');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'G':
+          ASSERT (c_tolower (c) == 'g');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'H':
+          ASSERT (c_tolower (c) == 'h');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'I':
+          ASSERT (c_tolower (c) == 'i');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'J':
+          ASSERT (c_tolower (c) == 'j');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'K':
+          ASSERT (c_tolower (c) == 'k');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'L':
+          ASSERT (c_tolower (c) == 'l');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'M':
+          ASSERT (c_tolower (c) == 'm');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'N':
+          ASSERT (c_tolower (c) == 'n');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'O':
+          ASSERT (c_tolower (c) == 'o');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'P':
+          ASSERT (c_tolower (c) == 'p');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'Q':
+          ASSERT (c_tolower (c) == 'q');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'R':
+          ASSERT (c_tolower (c) == 'r');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'S':
+          ASSERT (c_tolower (c) == 's');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'T':
+          ASSERT (c_tolower (c) == 't');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'U':
+          ASSERT (c_tolower (c) == 'u');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'V':
+          ASSERT (c_tolower (c) == 'v');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'W':
+          ASSERT (c_tolower (c) == 'w');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'X':
+          ASSERT (c_tolower (c) == 'x');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'Y':
+          ASSERT (c_tolower (c) == 'y');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'Z':
+          ASSERT (c_tolower (c) == 'z');
+          ASSERT (c_toupper (c) == c);
+          break;
+        case 'a':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'A');
+          break;
+        case 'b':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'B');
+          break;
+        case 'c':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'C');
+          break;
+        case 'd':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'D');
+          break;
+        case 'e':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'E');
+          break;
+        case 'f':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'F');
+          break;
+        case 'g':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'G');
+          break;
+        case 'h':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'H');
+          break;
+        case 'i':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'I');
+          break;
+        case 'j':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'J');
+          break;
+        case 'k':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'K');
+          break;
+        case 'l':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'L');
+          break;
+        case 'm':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'M');
+          break;
+        case 'n':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'N');
+          break;
+        case 'o':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'O');
+          break;
+        case 'p':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'P');
+          break;
+        case 'q':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'Q');
+          break;
+        case 'r':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'R');
+          break;
+        case 's':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'S');
+          break;
+        case 't':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'T');
+          break;
+        case 'u':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'U');
+          break;
+        case 'v':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'V');
+          break;
+        case 'w':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'W');
+          break;
+        case 'x':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'X');
+          break;
+        case 'y':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'Y');
+          break;
+        case 'z':
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == 'Z');
+          break;
+        default:
+          ASSERT (c_tolower (c) == c);
+          ASSERT (c_toupper (c) == c);
+          break;
+        }
     }
 }
 
--- a/lib/gltests/test-c-strcasecmp.c
+++ b/lib/gltests/test-c-strcasecmp.c
@@ -1,5 +1,5 @@
 /* Test of case-insensitive string comparison function.
-   Copyright (C) 2007-2008 Free Software Foundation, Inc.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -21,21 +21,9 @@
 #include "c-strcase.h"
 
 #include <locale.h>
-#include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
 
-#define ASSERT(expr) \
-  do									     \
-    {									     \
-      if (!(expr))							     \
-        {								     \
-          fprintf (stderr, "%s:%d: assertion failed\n", __FILE__, __LINE__); \
-          fflush (stderr);						     \
-          abort ();							     \
-        }								     \
-    }									     \
-  while (0)
+#include "macros.h"
 
 int
 main (int argc, char *argv[])
@@ -44,7 +32,7 @@ main (int argc, char *argv[])
     {
       /* configure should already have checked that the locale is supported.  */
       if (setlocale (LC_ALL, "") == NULL)
-	return 1;
+        return 1;
     }
 
   ASSERT (c_strcasecmp ("paragraph", "Paragraph") == 0);
--- a/lib/gltests/test-c-strncasecmp.c
+++ b/lib/gltests/test-c-strncasecmp.c
@@ -1,5 +1,5 @@
 /* Test of case-insensitive string comparison function.
-   Copyright (C) 2007-2008 Free Software Foundation, Inc.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -21,21 +21,9 @@
 #include "c-strcase.h"
 
 #include <locale.h>
-#include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
 
-#define ASSERT(expr) \
-  do									     \
-    {									     \
-      if (!(expr))							     \
-        {								     \
-          fprintf (stderr, "%s:%d: assertion failed\n", __FILE__, __LINE__); \
-          fflush (stderr);						     \
-          abort ();							     \
-        }								     \
-    }									     \
-  while (0)
+#include "macros.h"
 
 int
 main (int argc, char *argv[])
@@ -44,7 +32,7 @@ main (int argc, char *argv[])
     {
       /* configure should already have checked that the locale is supported.  */
       if (setlocale (LC_ALL, "") == NULL)
-	return 1;
+        return 1;
     }
 
   ASSERT (c_strncasecmp ("paragraph", "Paragraph", 1000000) == 0);
--- /dev/null
+++ b/lib/gltests/test-iconv-h.c
@@ -0,0 +1,31 @@
+/* Test of <iconv.h> substitute.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#if HAVE_ICONV
+# include <iconv.h>
+
+# ifndef ICONV_CONST
+#  define ICONV_CONST /* empty */
+# endif
+#endif
+
+int
+main ()
+{
+  return 0;
+}
--- a/lib/gltests/test-iconv.c
+++ b/lib/gltests/test-iconv.c
@@ -1,5 +1,5 @@
 /* Test of character set conversion.
-   Copyright (C) 2007-2008 Free Software Foundation, Inc.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -20,24 +20,23 @@
 
 #if HAVE_ICONV
 # include <iconv.h>
+
+# ifndef ICONV_CONST
+#  define ICONV_CONST /* empty */
+# endif
+
+#include "signature.h"
+SIGNATURE_CHECK (iconv, size_t, (iconv_t, ICONV_CONST char **, size_t *,
+                                 char **, size_t *));
+SIGNATURE_CHECK (iconv_close, int, (iconv_t x));
+SIGNATURE_CHECK (iconv_open, iconv_t, (char const *, char const *));
+
 #endif
 
 #include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
 
-#define ASSERT(expr) \
-  do									     \
-    {									     \
-      if (!(expr))							     \
-        {								     \
-          fprintf (stderr, "%s:%d: assertion failed\n", __FILE__, __LINE__); \
-          fflush (stderr);						     \
-          abort ();							     \
-        }								     \
-    }									     \
-  while (0)
+#include "macros.h"
 
 int
 main ()
@@ -61,8 +60,8 @@ main ()
     char *outptr = buf;
     size_t outbytesleft = sizeof (buf);
     size_t res = iconv (cd_88591_to_utf8,
-			(ICONV_CONST char **) &inptr, &inbytesleft,
-			&outptr, &outbytesleft);
+                        (ICONV_CONST char **) &inptr, &inbytesleft,
+                        &outptr, &outbytesleft);
     ASSERT (res == 0 && inbytesleft == 0);
     ASSERT (outptr == buf + strlen (expected));
     ASSERT (memcmp (buf, expected, strlen (expected)) == 0);
@@ -77,8 +76,8 @@ main ()
     char *outptr = buf;
     size_t outbytesleft = 1;
     size_t res = iconv (cd_88591_to_utf8,
-			(ICONV_CONST char **) &inptr, &inbytesleft,
-			&outptr, &outbytesleft);
+                        (ICONV_CONST char **) &inptr, &inbytesleft,
+                        &outptr, &outbytesleft);
     ASSERT (res == (size_t)(-1) && errno == E2BIG);
     ASSERT (inbytesleft == 1);
     ASSERT (outbytesleft == 1);
@@ -96,8 +95,8 @@ main ()
     char *outptr = buf;
     size_t outbytesleft = sizeof (buf);
     size_t res = iconv (cd_utf8_to_88591,
-			(ICONV_CONST char **) &inptr, &inbytesleft,
-			&outptr, &outbytesleft);
+                        (ICONV_CONST char **) &inptr, &inbytesleft,
+                        &outptr, &outbytesleft);
     ASSERT (res == 0 && inbytesleft == 0);
     ASSERT (outptr == buf + strlen (expected));
     ASSERT (memcmp (buf, expected, strlen (expected)) == 0);
@@ -112,17 +111,17 @@ main ()
     char *outptr = buf;
     size_t outbytesleft = sizeof (buf);
     size_t res = iconv (cd_utf8_to_88591,
-			(ICONV_CONST char **) &inptr, &inbytesleft,
-			&outptr, &outbytesleft);
+                        (ICONV_CONST char **) &inptr, &inbytesleft,
+                        &outptr, &outbytesleft);
     if (res == (size_t)(-1))
       {
         ASSERT (errno == EILSEQ);
-	ASSERT (inbytesleft == strlen (input) && outptr == buf);
+        ASSERT (inbytesleft == strlen (input) && outptr == buf);
       }
     else
       {
-	ASSERT (res == 1);
-	ASSERT (inbytesleft == 0);
+        ASSERT (res == 1);
+        ASSERT (inbytesleft == 0);
       }
   }
 
@@ -135,8 +134,8 @@ main ()
     char *outptr = buf;
     size_t outbytesleft = sizeof (buf);
     size_t res = iconv (cd_utf8_to_88591,
-			(ICONV_CONST char **) &inptr, &inbytesleft,
-			&outptr, &outbytesleft);
+                        (ICONV_CONST char **) &inptr, &inbytesleft,
+                        &outptr, &outbytesleft);
     ASSERT (res == (size_t)(-1) && errno == EINVAL);
     ASSERT (inbytesleft == 1 && outptr == buf);
   }
--- a/lib/gltests/test-stdbool.c
+++ b/lib/gltests/test-stdbool.c
@@ -1,5 +1,5 @@
 /* Test of <stdbool.h> substitute.
-   Copyright (C) 2002-2007 Free Software Foundation, Inc.
+   Copyright (C) 2002-2007, 2009-2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -46,11 +46,12 @@ struct s { _Bool s: 1; _Bool t; } s;
 char a[true == 1 ? 1 : -1];
 char b[false == 0 ? 1 : -1];
 char c[__bool_true_false_are_defined == 1 ? 1 : -1];
-#if 0 /* Cannot be guaranteed with gnulib's <stdbool.h>.  */
+#if 0 /* Cannot be guaranteed with gnulib's <stdbool.h>, at least,
+not for all compilers.  */
 char d[(bool) 0.5 == true ? 1 : -1];
 bool e = &s;
-#endif
 char f[(_Bool) 0.0 == false ? 1 : -1];
+#endif
 char g[true];
 char h[sizeof (_Bool)];
 #if 0 /* See above.  */
--- /dev/null
+++ b/lib/gltests/test-stddef.c
@@ -0,0 +1,38 @@
+/* Test of <stddef.h> substitute.
+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake <ebb9@byu.net>, 2009.  */
+
+#include <config.h>
+
+#include <stddef.h>
+
+#include "verify.h"
+
+/* Check that appropriate types are defined.  */
+wchar_t a = 'c';
+ptrdiff_t b = 1;
+size_t c = 2;
+
+/* Check that NULL can be passed through varargs as a pointer type,
+   per POSIX 2008.  */
+verify (sizeof NULL == sizeof (void *));
+
+int
+main (void)
+{
+  return 0;
+}
--- a/lib/gltests/test-stdint.c
+++ b/lib/gltests/test-stdint.c
@@ -1,5 +1,5 @@
 /* Test of <stdint.h> substitute.
-   Copyright (C) 2006-2008 Free Software Foundation, Inc.
+   Copyright (C) 2006-2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -22,6 +22,7 @@
 #define DO_PEDANTIC 0
 
 #define __STDC_LIMIT_MACROS 1 /* to make it work also in C++ mode */
+#define __STDC_CONSTANT_MACROS 1 /* likewise */
 #include <stdint.h>
 
 #include "verify.h"
@@ -354,7 +355,7 @@ verify_same_types (UINTMAX_C (17), (uint
 
 
 int
-main ()
+main (void)
 {
   return 0;
 }
--- a/lib/gltests/test-striconv.c
+++ b/lib/gltests/test-striconv.c
@@ -1,5 +1,5 @@
 /* Test of character set conversion.
-   Copyright (C) 2007-2008 Free Software Foundation, Inc.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -25,21 +25,10 @@
 #endif
 
 #include <errno.h>
-#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
-#define ASSERT(expr) \
-  do									     \
-    {									     \
-      if (!(expr))							     \
-        {								     \
-          fprintf (stderr, "%s:%d: assertion failed\n", __FILE__, __LINE__); \
-          fflush (stderr);						     \
-          abort ();							     \
-        }								     \
-    }									     \
-  while (0)
+#include "macros.h"
 
 int
 main ()
@@ -62,7 +51,7 @@ main ()
     char *result = NULL;
     size_t length = 0;
     int retval = mem_cd_iconv (input, strlen (input), cd_88591_to_utf8,
-			       &result, &length);
+                               &result, &length);
     ASSERT (retval == 0);
     ASSERT (length == strlen (expected));
     ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);
@@ -76,7 +65,7 @@ main ()
     char *result = NULL;
     size_t length = 0;
     int retval = mem_cd_iconv (input, strlen (input), cd_utf8_to_88591,
-			       &result, &length);
+                               &result, &length);
     ASSERT (retval == 0);
     ASSERT (length == strlen (expected));
     ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);
@@ -89,7 +78,7 @@ main ()
     char *result = NULL;
     size_t length = 0;
     int retval = mem_cd_iconv (input, strlen (input), cd_utf8_to_88591,
-			       &result, &length);
+                               &result, &length);
     ASSERT (retval == -1 && errno == EILSEQ);
     ASSERT (result == NULL);
   }
@@ -100,7 +89,7 @@ main ()
     char *result = NULL;
     size_t length = 0;
     int retval = mem_cd_iconv (input, strlen (input), cd_utf8_to_88591,
-			       &result, &length);
+                               &result, &length);
     ASSERT (retval == 0);
     ASSERT (length == 0);
     free (result);
--- a/lib/gltests/test-string.c
+++ b/lib/gltests/test-string.c
@@ -1,5 +1,5 @@
 /* Test of <string.h> substitute.
-   Copyright (C) 2007 Free Software Foundation, Inc.
+   Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -20,8 +20,14 @@
 
 #include <string.h>
 
+#include "verify.h"
+
+/* Check that NULL can be passed through varargs as a pointer type,
+   per POSIX 2008.  */
+verify (sizeof NULL == sizeof (void *));
+
 int
-main ()
+main (void)
 {
   return 0;
 }
--- a/lib/gltests/test-strverscmp.c
+++ b/lib/gltests/test-strverscmp.c
@@ -1,5 +1,5 @@
 /* Test of strverscmp() function.
-   Copyright (C) 2008 Free Software Foundation, Inc.
+   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -21,23 +21,13 @@
 
 #include <string.h>
 
-#include <stdio.h>
-#include <stdlib.h>
+#include "signature.h"
+SIGNATURE_CHECK (strverscmp, int, (const char *, const char *));
 
-#define ASSERT(expr) \
-  do									     \
-    {									     \
-      if (!(expr))							     \
-        {								     \
-          fprintf (stderr, "%s:%d: assertion failed\n", __FILE__, __LINE__); \
-          fflush (stderr);						     \
-          abort ();							     \
-        }								     \
-    }									     \
-  while (0)
+#include "macros.h"
 
 int
-main (int argc, char **argv)
+main (void)
 {
   ASSERT (strverscmp ("", "") == 0);
   ASSERT (strverscmp ("a", "a") == 0);
--- /dev/null
+++ b/lib/gltests/test-verify.c
@@ -0,0 +1,69 @@
+/* Test the "verify" module.
+
+   Copyright (C) 2005, 2009, 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible.  */
+
+#include <config.h>
+
+#include "verify.h"
+
+#ifndef EXP_FAIL
+# define EXP_FAIL 0
+#endif
+
+int x;
+enum { a, b, c };
+
+#if EXP_FAIL == 1
+verify (x >= 0);                  /* should give ERROR: non-constant expression */
+#endif
+verify (c == 2);                  /* should be ok */
+#if EXP_FAIL == 2
+verify (1 + 1 == 3);              /* should give ERROR */
+#endif
+verify (1 == 1); verify (1 == 1); /* should be ok */
+
+enum
+{
+  item = verify_true (1 == 1) * 0 + 17 /* should be ok */
+};
+
+static int
+function (int n)
+{
+#if EXP_FAIL == 3
+  verify (n >= 0);                  /* should give ERROR: non-constant expression */
+#endif
+  verify (c == 2);                  /* should be ok */
+#if EXP_FAIL == 4
+  verify (1 + 1 == 3);              /* should give ERROR */
+#endif
+  verify (1 == 1); verify (1 == 1); /* should be ok */
+
+  if (n)
+    return ((void) verify_true (1 == 1), verify_true (1 == 1) + 7); /* should be ok */
+#if EXP_FAIL == 5
+  return (verify_true (1 == 2), 5); /* should give ERROR */
+#endif
+  return 0;
+}
+
+int
+main (void)
+{
+  return !(function (0) == 0 && function (1) == 8);
+}
--- /dev/null
+++ b/lib/gltests/test-verify.sh
@@ -0,0 +1,24 @@
+#!/bin/sh
+. "${srcdir=.}/init.sh"
+
+# We are not interested in triggering bugs in the compilers and tools
+# (such as gcc 4.3.1 on openSUSE 11.0).
+unset MALLOC_PERTURB_
+
+# Rather than figure out how to invoke the compiler with the right
+# include path ourselves, we let make do it:
+(cd "$initial_cwd_" && rm -f test-verify.o \
+    && $MAKE test-verify.o >/dev/null 2>&1) \
+  || skip_ "cannot compile error-free"
+
+# Now, prove that we encounter all expected compilation failures:
+: >out
+: >err
+for i in 1 2 3 4 5; do
+  (cd "$initial_cwd_"
+   rm -f test-verify.o
+   $MAKE CFLAGS=-DEXP_FAIL=$i test-verify.o) >>out 2>>err \
+  && { warn_ "compiler didn't detect verification failure $i"; fail=1; }
+done
+
+Exit $fail
--- a/lib/gltests/test-wchar.c
+++ b/lib/gltests/test-wchar.c
@@ -1,5 +1,5 @@
 /* Test of <wchar.h> substitute.
-   Copyright (C) 2007-2008 Free Software Foundation, Inc.
+   Copyright (C) 2007-2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -20,12 +20,18 @@
 
 #include <wchar.h>
 
+#include "verify.h"
+
 /* Check that the types wchar_t and wint_t are defined.  */
 wchar_t a = 'c';
 wint_t b = 'x';
 
+/* Check that NULL can be passed through varargs as a pointer type,
+   per POSIX 2008.  */
+verify (sizeof NULL == sizeof (void *));
+
 int
-main ()
+main (void)
 {
   return 0;
 }
--- /dev/null
+++ b/lib/gltests/unistr/test-u8-check.c
@@ -0,0 +1,188 @@
+/* Test of u8_check() function.
+   Copyright (C) 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2010.  */
+
+#include <config.h>
+
+#include "unistr.h"
+
+#include "macros.h"
+
+int
+main ()
+{
+  /* Test empty string.  */
+  {
+    static const uint8_t input[] = "";
+    ASSERT (u8_check (input, 0) == NULL);
+  }
+
+  /* Test valid non-empty string.  */
+  {
+    static const uint8_t input[] = /* "Данило Шеган" */
+      "\320\224\320\260\320\275\320\270\320\273\320\276 \320\250\320\265\320\263\320\260\320\275";
+    ASSERT (u8_check (input, sizeof (input) - 1) == NULL);
+  }
+
+  /* Test out-of-range character with 4 bytes: U+110000.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\364\220\200\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  /* Test out-of-range character with 5 bytes: U+200000.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\370\210\200\200\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  /* Test out-of-range character with 6 bytes: U+4000000.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\374\204\200\200\200\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  /* Test invalid lead byte.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\376\200\200\200\200\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+  {
+    static const uint8_t input[] = "\320\224\320\260\377\200\200\200\200\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  /* Test overlong 2-byte character.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\301\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  /* Test overlong 3-byte character.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\340\200\277";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  /* Test overlong 4-byte character.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\360\200\277\277";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  /* Test invalid bytes in 2-byte character.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\302\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == NULL);
+  }
+  {
+    static const uint8_t input[] = "\320\224\320\260\302\100";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+  {
+    static const uint8_t input[] = "\320\224\320\260\302\300";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  /* Test invalid bytes in 3-byte character.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\342\200\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == NULL);
+  }
+  {
+    static const uint8_t input[] = "\320\224\320\260\342\100\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+  {
+    static const uint8_t input[] = "\320\224\320\260\342\300\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+  {
+    static const uint8_t input[] = "\320\224\320\260\342\200\100";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+  {
+    static const uint8_t input[] = "\320\224\320\260\342\200\300";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  /* Test invalid bytes in 4-byte character.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\362\200\200\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == NULL);
+  }
+  {
+    static const uint8_t input[] = "\320\224\320\260\362\100\200\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+  {
+    static const uint8_t input[] = "\320\224\320\260\362\300\200\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+  {
+    static const uint8_t input[] = "\320\224\320\260\362\200\100\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+  {
+    static const uint8_t input[] = "\320\224\320\260\362\200\300\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+  {
+    static const uint8_t input[] = "\320\224\320\260\362\200\200\100";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+  {
+    static const uint8_t input[] = "\320\224\320\260\362\200\200\300";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  /* Test truncated/incomplete 2-byte character.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\302";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  /* Test truncated/incomplete 3-byte character.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\342\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  /* Test truncated/incomplete 4-byte character.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\362\200\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  /* Test missing lead byte.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\200\200\200\200\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  /* Test surrogate codepoints.  */
+  {
+    static const uint8_t input[] = "\320\224\320\260\355\240\200\355\260\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+  {
+    static const uint8_t input[] = "\320\224\320\260\355\260\200";
+    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);
+  }
+
+  return 0;
+}
--- a/lib/gltests/verify.h
+++ b/lib/gltests/verify.h
@@ -1,6 +1,6 @@
 /* Compile-time assert-like macros.
 
-   Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   Copyright (C) 2005-2006, 2009-2010 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -69,13 +69,14 @@
      if the entity names are not disambiguated.  A workaround is to
      attach the current line number to the entity name:
 
-       #define GL_CONCAT0(x, y) x##y
-       #define GL_CONCAT(x, y) GL_CONCAT0 (x, y)
-       extern struct {...} * GL_CONCAT(dummy,__LINE__);
+       #define _GL_CONCAT0(x, y) x##y
+       #define _GL_CONCAT(x, y) _GL_CONCAT0 (x, y)
+       extern struct {...} * _GL_CONCAT (dummy, __LINE__);
 
      But this has the problem that two invocations of verify from
      within the same macro would collide, since the __LINE__ value
-     would be the same for both invocations.
+     would be the same for both invocations.  (The GCC __COUNTER__
+     macro solves this problem, but is not portable.)
 
      A solution is to use the sizeof operator.  It yields a number,
      getting rid of the identity of the type.  Declarations like
@@ -103,20 +104,41 @@
 
        extern int (*dummy (void)) [sizeof (struct {...})];
 
+   * GCC warns about duplicate declarations of the dummy function if
+     -Wredundant_decls is used.  GCC 4.3 and later have a builtin
+     __COUNTER__ macro that can let us generate unique identifiers for
+     each dummy function, to suppress this warning.
+
    * This implementation exploits the fact that GCC does not warn about
      the last declaration mentioned above.  If a future version of GCC
      introduces a warning for this, the problem could be worked around
-     by using code specialized to GCC, e.g.,:
+     by using code specialized to GCC, just as __COUNTER__ is already
+     being used if available.
 
        #if 4 <= __GNUC__
-       # define verify(R) \
-	   extern int (* verify_function__ (void)) \
-		      [__builtin_constant_p (R) && (R) ? 1 : -1]
+       # define verify(R) [another version to keep GCC happy]
        #endif
 
    * In C++, any struct definition inside sizeof is invalid.
      Use a template type to work around the problem.  */
 
+/* Concatenate two preprocessor tokens.  */
+# define _GL_CONCAT(x, y) _GL_CONCAT0 (x, y)
+# define _GL_CONCAT0(x, y) x##y
+
+/* _GL_COUNTER is an integer, preferably one that changes each time we
+   use it.  Use __COUNTER__ if it works, falling back on __LINE__
+   otherwise.  __LINE__ isn't perfect, but it's better than a
+   constant.  */
+# if defined __COUNTER__ && __COUNTER__ != __COUNTER__
+#  define _GL_COUNTER __COUNTER__
+# else
+#  define _GL_COUNTER __LINE__
+# endif
+
+/* Generate a symbol with the given prefix, making it unique if
+   possible.  */
+# define _GL_GENSYM(prefix) _GL_CONCAT (prefix, _GL_COUNTER)
 
 /* Verify requirement R at compile-time, as an integer constant expression.
    Return 1.  */
@@ -135,6 +157,7 @@ template <int w>
 /* Verify requirement R at compile-time, as a declaration without a
    trailing ';'.  */
 
-# define verify(R) extern int (* verify_function__ (void)) [verify_true (R)]
+# define verify(R) \
+    extern int (* _GL_GENSYM (verify_function) (void)) [verify_true (R)]
 
 #endif
--- a/maint.mk
+++ b/maint.mk
@@ -2,7 +2,7 @@
 # This Makefile fragment tries to be general-purpose enough to be
 # used by many projects via the gnulib maintainer-makefile module.
 
-## Copyright (C) 2001-2009 Free Software Foundation, Inc.
+## Copyright (C) 2001-2010 Free Software Foundation, Inc.
 ##
 ## This program is free software: you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
@@ -27,24 +27,48 @@ build_aux ?= $(srcdir)/build-aux
 # Do not save the original name or timestamp in the .tar.gz file.
 # Use --rsyncable if available.
 gzip_rsyncable := \
-  $(shell gzip --help 2>/dev/null|grep rsyncable >/dev/null && echo --rsyncable)
+  $(shell gzip --help 2>/dev/null|grep rsyncable >/dev/null \
+    && printf %s --rsyncable)
 GZIP_ENV = '--no-name --best $(gzip_rsyncable)'
 
-# cfg.mk must define the gpg_key_ID used by this package.
 GIT = git
 VC = $(GIT)
 VC-tag = git tag -s -m '$(VERSION)' -u '$(gpg_key_ID)'
 
 VC_LIST = $(build_aux)/vc-list-files -C $(srcdir)
 
+# You can override this variable in cfg.mk to set your own regexp
+# matching files to ignore.
+VC_LIST_ALWAYS_EXCLUDE_REGEX ?= ^$$
+
+# This is to preprocess robustly the output of $(VC_LIST), so that even
+# when $(srcdir) is a pathological name like "....", the leading sed command
+# removes only the intended prefix.
+_dot_escaped_srcdir = $(subst .,\.,$(srcdir))
+
+# Post-process $(VC_LIST) output, prepending $(srcdir)/, but only
+# when $(srcdir) is not ".".
+ifeq ($(srcdir),.)
+_prepend_srcdir_prefix =
+else
+_prepend_srcdir_prefix = | sed 's|^|$(srcdir)/|'
+endif
+
+# In order to be able to consistently filter "."-relative names,
+# (i.e., with no $(srcdir) prefix), this definition is careful to
+# remove any $(srcdir) prefix, and to restore what it removes.
 VC_LIST_EXCEPT = \
-  $(VC_LIST) | if test -f $(srcdir)/.x-$@; then grep -vEf $(srcdir)/.x-$@; else grep -v ChangeLog; fi
+  $(VC_LIST) | sed 's|^$(_dot_escaped_srcdir)/||' \
+	| if test -f $(srcdir)/.x-$@; then grep -vEf $(srcdir)/.x-$@; \
+	  else grep -Ev -e "$${VC_LIST_EXCEPT_DEFAULT-ChangeLog}"; fi \
+	| grep -Ev -e '$(VC_LIST_ALWAYS_EXCLUDE_REGEX)' \
+	$(_prepend_srcdir_prefix)
 
 ifeq ($(origin prev_version_file), undefined)
   prev_version_file = $(srcdir)/.prev-version
 endif
 
-PREV_VERSION := $(shell cat $(prev_version_file))
+PREV_VERSION := $(shell cat $(prev_version_file) 2>/dev/null)
 VERSION_REGEXP = $(subst .,\.,$(VERSION))
 PREV_VERSION_REGEXP = $(subst .,\.,$(PREV_VERSION))
 
@@ -62,6 +86,31 @@ my_distdir = $(PACKAGE)-$(VERSION)
 # Old releases are stored here.
 release_archive_dir ?= ../release
 
+# Override gnu_rel_host and url_dir_list in cfg.mk if these are not right.
+# Use alpha.gnu.org for alpha and beta releases.
+# Use ftp.gnu.org for stable releases.
+gnu_ftp_host-alpha = alpha.gnu.org
+gnu_ftp_host-beta = alpha.gnu.org
+gnu_ftp_host-stable = ftp.gnu.org
+gnu_rel_host ?= $(gnu_ftp_host-$(RELEASE_TYPE))
+
+ifeq ($(gnu_rel_host),ftp.gnu.org)
+url_dir_list ?= http://ftpmirror.gnu.org/$(PACKAGE)
+else
+url_dir_list ?= ftp://$(gnu_rel_host)/gnu/$(PACKAGE)
+endif
+
+# Override this in cfg.mk if you are using a different format in your
+# NEWS file.
+today = $(shell date +%Y-%m-%d)
+
+# Select which lines of NEWS are searched for $(news-check-regexp).
+# This is a sed line number spec.  The default says that we search
+# lines 1..10 of NEWS for $(news-check-regexp).
+# If you want to search only line 3 or only lines 20-22, use "3" or "20,22".
+news-check-lines-spec ?= 1,10
+news-check-regexp ?= '^\*.* $(VERSION_REGEXP) \($(today)\)'
+
 # Prevent programs like 'sort' from considering distinct strings to be equal.
 # Doing it here saves us from having to set LC_ALL elsewhere in this file.
 export LC_ALL = C
@@ -70,9 +119,11 @@ export LC_ALL = C
 ## Sanity checks.  ##
 ## --------------- ##
 
+_cfg_mk := $(shell test -f $(srcdir)/cfg.mk && echo '$(srcdir)/cfg.mk')
+
 # Collect the names of rules starting with `sc_'.
-syntax-check-rules := $(shell sed -n 's/^\(sc_[a-zA-Z0-9_-]*\):.*/\1/p' \
-			$(srcdir)/$(ME) $(srcdir)/cfg.mk)
+syntax-check-rules := $(sort $(shell sed -n 's/^\(sc_[a-zA-Z0-9_-]*\):.*/\1/p' \
+			$(srcdir)/$(ME) $(_cfg_mk)))
 .PHONY: $(syntax-check-rules)
 
 local-checks-available = \
@@ -81,36 +132,128 @@ local-checks-available = \
 
 # Arrange to print the name of each syntax-checking rule just before running it.
 $(syntax-check-rules): %: %.m
-$(patsubst %, %.m, $(syntax-check-rules)):
+sc_m_rules_ = $(patsubst %, %.m, $(syntax-check-rules))
+.PHONY: $(sc_m_rules_)
+$(sc_m_rules_):
 	@echo $(patsubst sc_%.m, %, $@)
+	@date +%s.%N > .sc-start-$(basename $@)
 
-local-check := $(filter-out $(local-checks-to-skip), $(local-checks-available))
+# Compute and print the elapsed time for each syntax-check rule.
+sc_z_rules_ = $(patsubst %, %.z, $(syntax-check-rules))
+.PHONY: $(sc_z_rules_)
+$(sc_z_rules_): %.z: %
+	@end=$$(date +%s.%N);						\
+	start=$$(cat .sc-start-$*);					\
+	rm -f .sc-start-$*;						\
+	awk -v s=$$start -v e=$$end					\
+	  'END {printf "%.2f $(patsubst sc_%,%,$*)\n", e - s}' < /dev/null
+
+# The patsubst here is to replace each sc_% rule with its sc_%.z wrapper
+# that computes and prints elapsed time.
+local-check :=								\
+  $(patsubst sc_%, sc_%.z,						\
+    $(filter-out $(local-checks-to-skip), $(local-checks-available)))
 
 syntax-check: $(local-check)
-#	@grep -nE '#  *include <(limits|std(def|arg|bool))\.h>'		\
-#	    $$(find -type f -name '*.[chly]') &&			\
-#	  { echo '$(ME): found conditional include' 1>&2;		\
-#	    exit 1; } || :
-
-#	grep -nE '^#  *include <(string|stdlib)\.h>'			\
-#	    $(srcdir)/{lib,src}/*.[chy] &&				\
-#	  { echo '$(ME): FIXME' 1>&2;					\
-#	    exit 1; } || :
-# FIXME: don't allow `#include .strings\.h' anywhere
 
-# By default, _prohibit_regexp does not ignore case.
+# _sc_search_regexp
+#
+# This macro searches for a given construct in the selected files and
+# then takes some action.
+#
+# Parameters (shell variables):
+#
+#  prohibit | require
+#
+#     Regular expression (ERE) denoting either a forbidden construct
+#     or a required construct.  Those arguments are exclusive.
+#
+#  in_vc_files | in_files
+#
+#     grep-E-style regexp denoting the files to check.  If no files
+#     are specified the default are all the files that are under
+#     version control.
+#
+#  containing | non_containing
+#
+#     Select the files (non) containing strings matching this regexp.
+#     If both arguments are specified then CONTAINING takes
+#     precedence.
+#
+#  with_grep_options
+#
+#     Extra options for grep.
+#
+#  ignore_case
+#
+#     Ignore case.
+#
+#  halt
+#
+#     Message to display before to halting execution.
+
+# By default, _sc_search_regexp does not ignore case.
 export ignore_case =
-_ignore_case = $$(test -n "$$ignore_case" && echo -i || :)
+_ignore_case = $$(test -n "$$ignore_case" && printf %s -i || :)
 
-# There are many rules below that prohibit constructs in this package.
-# If the offending construct can be matched with a grep-E-style regexp,
-# use this macro.  The shell variables "re" and "msg" must be defined.
-define _prohibit_regexp
-  dummy=; : so we do not need a semicolon before each use;		\
-  test "x$$re" != x || { echo '$(ME): re not defined' 1>&2; exit 1; };	\
-  test "x$$msg" != x || { echo '$(ME): msg not defined' 1>&2; exit 1; };\
-  grep $(_ignore_case) -nE "$$re" $$($(VC_LIST_EXCEPT)) &&		\
-    { echo '$(ME): '"$$msg" 1>&2; exit 1; } || :
+define _sc_say_and_exit
+   dummy=; : so we do not need a semicolon before each use;		\
+   { printf '%s\n' "$(ME): $$msg" 1>&2; exit 1; };
+endef
+
+# _sc_search_regexp used to be named _prohibit_regexp.  However,
+# upgrading to the new definition and leaving the old name undefined
+# would usually convert each custom rule using $(_prohibit_regexp)
+# (usually defined in cfg.mk) into a no-op.  This definition ensures
+# that people know right away if they're still using the old name.
+# FIXME: remove in 2012.
+_prohibit_regexp = \
+  $(error '*** you need to s/_prohibit_regexp/_sc_search_regexp/, and adapt')
+
+define _sc_search_regexp
+   dummy=; : so we do not need a semicolon before each use;		\
+									\
+   : Check arguments;							\
+   test -n "$$prohibit" && test -n "$$require"				\
+     && { msg='Cannot specify both prohibit and require'		\
+          $(_sc_say_and_exit) } || :;					\
+   test -z "$$prohibit" && test -z "$$require"				\
+     && { msg='Should specify either prohibit or require'		\
+          $(_sc_say_and_exit) } || :;					\
+   test -n "$$in_vc_files" && test -n "$$in_files"			\
+     && { msg='Cannot specify both in_vc_files and in_files'		\
+          $(_sc_say_and_exit) } || :;					\
+   test "x$$halt" != x							\
+     || { msg='halt not defined' $(_sc_say_and_exit) };			\
+									\
+   : Filter by file name;						\
+   if test -n "$$in_files"; then					\
+     files=$$(find $(srcdir) | grep -E "$$in_files");			\
+   else									\
+     files=$$($(VC_LIST_EXCEPT));					\
+     if test -n "$$in_vc_files"; then					\
+       files=$$(echo "$$files" | grep -E "$$in_vc_files");		\
+     fi;								\
+   fi;									\
+									\
+   : Filter by content;							\
+   test -n "$$files" && test -n "$$containing"				\
+     && { files=$$(grep -l "$$containing" $$files); } || :;		\
+   test -n "$$files" && test -n "$$non_containing"			\
+     && { files=$$(grep -vl "$$non_containing" $$files); } || :;	\
+									\
+   : Check for the construct;						\
+   if test -n "$$files"; then						\
+     if test -n "$$prohibit"; then					\
+       grep $$with_grep_options $(_ignore_case) -nE "$$prohibit" $$files \
+         && { msg="$$halt" $(_sc_say_and_exit) } || :;			\
+     else								\
+       grep $$with_grep_options $(_ignore_case) -LE "$$require" $$files \
+           | grep .							\
+         && { msg="$$halt" $(_sc_say_and_exit) } || :;			\
+     fi									\
+   else :;								\
+   fi || :;
 endef
 
 sc_avoid_if_before_free:
@@ -121,29 +264,31 @@ sc_avoid_if_before_free:
 	    exit 1; } || :
 
 sc_cast_of_argument_to_free:
-	@re='\<free *\( *\(' msg='don'\''t cast free argument'		\
-	  $(_prohibit_regexp)
+	@prohibit='\<free *\( *\(' halt='don'\''t cast free argument'	\
+	  $(_sc_search_regexp)
 
 sc_cast_of_x_alloc_return_value:
-	@re='\*\) *x(m|c|re)alloc\>'					\
-	msg='don'\''t cast x*alloc return value'			\
-	  $(_prohibit_regexp)
+	@prohibit='\*\) *x(m|c|re)alloc\>'				\
+	halt='don'\''t cast x*alloc return value'			\
+	  $(_sc_search_regexp)
 
 sc_cast_of_alloca_return_value:
-	@re='\*\) *alloca\>' msg='don'\''t cast alloca return value'	\
-	  $(_prohibit_regexp)
+	@prohibit='\*\) *alloca\>'					\
+	halt='don'\''t cast alloca return value'			\
+	  $(_sc_search_regexp)
 
 sc_space_tab:
-	@re='[ ]	' msg='found SPACE-TAB sequence; remove the SPACE' \
-	  $(_prohibit_regexp)
+	@prohibit='[ ]	'						\
+	halt='found SPACE-TAB sequence; remove the SPACE'		\
+	  $(_sc_search_regexp)
 
 # Don't use *scanf or the old ato* functions in `real' code.
 # They provide no error checking mechanism.
 # Instead, use strto* functions.
 sc_prohibit_atoi_atof:
-	@re='\<([fs]?scanf|ato([filq]|ll)) *\('				\
-	msg='do not use *scan''f, ato''f, ato''i, ato''l, ato''ll or ato''q' \
-	  $(_prohibit_regexp)
+	@prohibit='\<([fs]?scanf|ato([filq]|ll)) *\('				\
+	halt='do not use *scan''f, ato''f, ato''i, ato''l, ato''ll or ato''q'	\
+	  $(_sc_search_regexp)
 
 # Use STREQ rather than comparing strcmp == 0, or != 0.
 sc_prohibit_strcmp:
@@ -153,24 +298,40 @@ sc_prohibit_strcmp:
 	  { echo '$(ME): use STREQ in place of the above uses of str''cmp' \
 		1>&2; exit 1; } || :
 
+# Pass EXIT_*, not number, to usage, exit, and error (when exiting)
+# Convert all uses automatically, via these two commands:
+# git grep -l '\<exit *(1)' \
+#  | grep -vEf .x-sc_prohibit_magic_number_exit \
+#  | xargs --no-run-if-empty \
+#      perl -pi -e 's/(^|[^.])\b(exit ?)\(1\)/$1$2(EXIT_FAILURE)/'
+# git grep -l '\<exit *(0)' \
+#  | grep -vEf .x-sc_prohibit_magic_number_exit \
+#  | xargs --no-run-if-empty \
+#      perl -pi -e 's/(^|[^.])\b(exit ?)\(0\)/$1$2(EXIT_SUCCESS)/'
+sc_prohibit_magic_number_exit:
+	@prohibit='(^|[^.])\<(usage|exit) ?\([0-9]|\<error ?\([1-9][0-9]*,'	\
+	halt='use EXIT_* values rather than magic number'			\
+	  $(_sc_search_regexp)
+
 # Using EXIT_SUCCESS as the first argument to error is misleading,
 # since when that parameter is 0, error does not exit.  Use `0' instead.
 sc_error_exit_success:
-	@grep -nE 'error \(EXIT_SUCCESS,'				\
-	    $$($(VC_LIST_EXCEPT) | grep -E '\.[chly]$$') &&		\
-	  { echo '$(ME): found error (EXIT_SUCCESS' 1>&2; exit 1; } || :
+	@prohibit='error *\(EXIT_SUCCESS,'				\
+	in_vc_files='\.[chly]$$'					\
+	halt='found error (EXIT_SUCCESS'				\
+	 $(_sc_search_regexp)
 
 # `FATAL:' should be fully upper-cased in error messages
 # `WARNING:' should be fully upper-cased, or fully lower-cased
 sc_error_message_warn_fatal:
-	@grep -nEA2 '[^rp]error \(' $$($(VC_LIST_EXCEPT))		\
+	@grep -nEA2 '[^rp]error *\(' $$($(VC_LIST_EXCEPT))		\
 	    | grep -E '"Warning|"Fatal|"fatal' &&			\
 	  { echo '$(ME): use FATAL, WARNING or warning'	1>&2;		\
 	    exit 1; } || :
 
 # Error messages should not start with a capital letter
 sc_error_message_uppercase:
-	@grep -nEA2 '[^rp]error \(' $$($(VC_LIST_EXCEPT))		\
+	@grep -nEA2 '[^rp]error *\(' $$($(VC_LIST_EXCEPT))		\
 	    | grep -E '"[A-Z]'						\
 	    | grep -vE '"FATAL|"WARNING|"Java|"C#|PRIuMAX' &&		\
 	  { echo '$(ME): found capitalized error message' 1>&2;		\
@@ -178,35 +339,32 @@ sc_error_message_uppercase:
 
 # Error messages should not end with a period
 sc_error_message_period:
-	@grep -nEA2 '[^rp]error \(' $$($(VC_LIST_EXCEPT))		\
+	@grep -nEA2 '[^rp]error *\(' $$($(VC_LIST_EXCEPT))		\
 	    | grep -E '[^."]\."' &&					\
 	  { echo '$(ME): found error message ending in period' 1>&2;	\
 	    exit 1; } || :
 
 sc_file_system:
-	@re=file''system ignore_case=1					\
-	msg='found use of "file''system"; spell it "file system"'	\
-	  $(_prohibit_regexp)
+	@prohibit=file''system						\
+	ignore_case=1							\
+	halt='found use of "file''system"; spell it "file system"'	\
+	  $(_sc_search_regexp)
 
 # Don't use cpp tests of this symbol.  All code assumes config.h is included.
 sc_prohibit_have_config_h:
-	@grep -n '^# *if.*HAVE''_CONFIG_H' $$($(VC_LIST_EXCEPT)) &&	\
-	  { echo '$(ME): found use of HAVE''_CONFIG_H; remove'		\
-		1>&2; exit 1; } || :
+	@prohibit='^# *if.*HAVE''_CONFIG_H'				\
+	halt='found use of HAVE''_CONFIG_H; remove'			\
+	  $(_sc_search_regexp)
 
 # Nearly all .c files must include <config.h>.  However, we also permit this
 # via inclusion of a package-specific header, if cfg.mk specified one.
 # config_h_header must be suitable for grep -E.
 config_h_header ?= <config\.h>
 sc_require_config_h:
-	@if $(VC_LIST_EXCEPT) | grep -l '\.c$$' > /dev/null; then	\
-	  grep -EL '^# *include $(config_h_header)'			\
-		$$($(VC_LIST_EXCEPT) | grep '\.c$$')			\
-	      | grep . &&						\
-	  { echo '$(ME): the above files do not include <config.h>'	\
-		1>&2; exit 1; } || :;					\
-	else :;								\
-	fi
+	@require='^# *include $(config_h_header)'			\
+	in_vc_files='\.c$$'						\
+	halt='the above files do not include <config.h>'		\
+	  $(_sc_search_regexp)
 
 # You must include <config.h> before including any other header file.
 # This can possibly be via a package-specific header, if given by cfg.mk.
@@ -225,14 +383,16 @@ sc_require_config_h_first:
 	fi
 
 sc_prohibit_HAVE_MBRTOWC:
-	@re='\bHAVE_MBRTOWC\b' msg="do not use $$re; it is always defined" \
-	  $(_prohibit_regexp)
+	@prohibit='\bHAVE_MBRTOWC\b'					\
+	halt="do not use $$prohibit; it is always defined"		\
+	  $(_sc_search_regexp)
 
 # To use this "command" macro, you must first define two shell variables:
 # h: the header, enclosed in <> or ""
 # re: a regular expression that matches IFF something provided by $h is used.
-define _header_without_use
-  h_esc=`echo "$$h"|sed 's/\./\\./g'`;					\
+define _sc_header_without_use
+  dummy=; : so we do not need a semicolon before each use;		\
+  h_esc=`echo "$$h"|sed 's/\./\\\\./g'`;				\
   if $(VC_LIST_EXCEPT) | grep -l '\.c$$' > /dev/null; then		\
     files=$$(grep -l '^# *include '"$$h_esc"				\
 	     $$($(VC_LIST_EXCEPT) | grep '\.c$$')) &&			\
@@ -245,55 +405,114 @@ endef
 
 # Prohibit the inclusion of assert.h without an actual use of assert.
 sc_prohibit_assert_without_use:
-	@h='<assert.h>' re='\<assert *\(' $(_header_without_use)
+	@h='<assert.h>' re='\<assert *\(' $(_sc_header_without_use)
+
+# Prohibit the inclusion of close-stream.h without an actual use.
+sc_prohibit_close_stream_without_use:
+	@h='"close-stream.h"' re='\<close_stream *\(' $(_sc_header_without_use)
 
 # Prohibit the inclusion of getopt.h without an actual use.
 sc_prohibit_getopt_without_use:
-	@h='<getopt.h>' re='\<getopt(_long)? *\(' $(_header_without_use)
+	@h='<getopt.h>' re='\<getopt(_long)? *\(' $(_sc_header_without_use)
 
 # Don't include quotearg.h unless you use one of its functions.
 sc_prohibit_quotearg_without_use:
-	@h='"quotearg.h"' re='\<quotearg(_[^ ]+)? *\(' $(_header_without_use)
+	@h='"quotearg.h"' re='\<quotearg(_[^ ]+)? *\(' $(_sc_header_without_use)
 
 # Don't include quote.h unless you use one of its functions.
 sc_prohibit_quote_without_use:
-	@h='"quote.h"' re='\<quote(_n)? *\(' $(_header_without_use)
+	@h='"quote.h"' re='\<quote(_n)? *\(' $(_sc_header_without_use)
 
 # Don't include this header unless you use one of its functions.
 sc_prohibit_long_options_without_use:
 	@h='"long-options.h"' re='\<parse_long_options *\(' \
-	  $(_header_without_use)
+	  $(_sc_header_without_use)
 
 # Don't include this header unless you use one of its functions.
 sc_prohibit_inttostr_without_use:
 	@h='"inttostr.h"' re='\<(off|[iu]max|uint)tostr *\(' \
-	  $(_header_without_use)
+	  $(_sc_header_without_use)
+
+# Don't include this header unless you use one of its functions.
+sc_prohibit_ignore_value_without_use:
+	@h='"ignore-value.h"' re='\<ignore_(value|ptr) *\(' \
+	  $(_sc_header_without_use)
 
 # Don't include this header unless you use one of its functions.
 sc_prohibit_error_without_use:
 	@h='"error.h"' \
 	re='\<error(_at_line|_print_progname|_one_per_line|_message_count)? *\('\
-	  $(_header_without_use)
+	  $(_sc_header_without_use)
+
+# Don't include xalloc.h unless you use one of its functions.
+# Consider these symbols:
+# perl -lne '/^# *define (\w+)\(/ and print $1' lib/xalloc.h|grep -v '^__';
+# perl -lne '/^(?:extern )?(?:void|char) \*?(\w+) *\(/ and print $1' lib/xalloc.h
+# Divide into two sets on case, and filter each through this:
+# | sort | perl -MRegexp::Assemble -le \
+#  'print Regexp::Assemble->new(file => "/dev/stdin")->as_string'|sed 's/\?://g'
+# Note this was produced by the above:
+# _xa1 = \
+#x(((2n?)?re|c(har)?|n(re|m)|z)alloc|alloc_(oversized|die)|m(alloc|emdup)|strdup)
+# But we can do better, in at least two ways:
+# 1) take advantage of two "dup"-suffixed strings:
+# x(((2n?)?re|c(har)?|n(re|m)|[mz])alloc|alloc_(oversized|die)|(mem|str)dup)
+# 2) notice that "c(har)?|[mz]" is equivalent to the shorter and more readable
+# "char|[cmz]"
+# x(((2n?)?re|char|n(re|m)|[cmz])alloc|alloc_(oversized|die)|(mem|str)dup)
+_xa1 = x(((2n?)?re|char|n(re|m)|[cmz])alloc|alloc_(oversized|die)|(mem|str)dup)
+_xa2 = X([CZ]|N?M)ALLOC
+sc_prohibit_xalloc_without_use:
+	@h='"xalloc.h"' \
+	re='\<($(_xa1)|$(_xa2)) *\('\
+	  $(_sc_header_without_use)
+
+# Extract function names:
+# perl -lne '/^(?:extern )?(?:void|char) \*?(\w+) *\(/ and print $1' lib/hash.h
+_hash_re = \
+clear|delete|free|get_(first|next)|insert|lookup|print_statistics|reset_tuning
+_hash_fn = \<($(_hash_re)) *\(
+_hash_struct = (struct )?\<[Hh]ash_(table|tuning)\>
+sc_prohibit_hash_without_use:
+	@h='"hash.h"' \
+	re='$(_hash_fn)|$(_hash_struct)'\
+	  $(_sc_header_without_use)
+
+sc_prohibit_hash_pjw_without_use:
+	@h='"hash-pjw.h"' \
+	re='\<hash_pjw *\(' \
+	  $(_sc_header_without_use)
 
 sc_prohibit_safe_read_without_use:
 	@h='"safe-read.h"' re='(\<SAFE_READ_ERROR\>|\<safe_read *\()' \
-	  $(_header_without_use)
+	  $(_sc_header_without_use)
 
 sc_prohibit_argmatch_without_use:
 	@h='"argmatch.h"' \
 	re='(\<(ARRAY_CARDINALITY|X?ARGMATCH(|_TO_ARGUMENT|_VERIFY))\>|\<argmatch(_exit_fn|_(in)?valid) *\()' \
-	  $(_header_without_use)
+	  $(_sc_header_without_use)
+
+sc_prohibit_canonicalize_without_use:
+	@h='"canonicalize.h"' \
+	re='CAN_(EXISTING|ALL_BUT_LAST|MISSING)|canonicalize_(mode_t|filename_mode)' \
+	  $(_sc_header_without_use)
 
 sc_prohibit_root_dev_ino_without_use:
 	@h='"root-dev-ino.h"' \
 	re='(\<ROOT_DEV_INO_(CHECK|WARN)\>|\<get_root_dev_ino *\()' \
-	  $(_header_without_use)
+	  $(_sc_header_without_use)
+
+sc_prohibit_openat_without_use:
+	@h='"openat.h"' \
+	re='\<(openat_(permissive|needs_fchdir|(save|restore)_fail)|l?(stat|ch(own|mod))at|(euid)?accessat)\>' \
+	  $(_sc_header_without_use)
 
 # Prohibit the inclusion of c-ctype.h without an actual use.
 ctype_re = isalnum|isalpha|isascii|isblank|iscntrl|isdigit|isgraph|islower\
 |isprint|ispunct|isspace|isupper|isxdigit|tolower|toupper
 sc_prohibit_c_ctype_without_use:
-	@h='[<"]c-ctype.h[">]' re='\<c_($(ctype_re)) *\(' $(_header_without_use)
+	@h='[<"]c-ctype.h[">]' re='\<c_($(ctype_re)) *\(' \
+	  $(_sc_header_without_use)
 
 _empty =
 _sp = $(_empty) $(_empty)
@@ -330,78 +549,95 @@ _sig_syms_re = $(subst $(_sp),|,$(strip
 sc_prohibit_signal_without_use:
 	@h='<signal.h>'							\
 	re='\<($(_sig_function_re)) *\(|\<($(_sig_syms_re))\>'		\
-	  $(_header_without_use)
+	  $(_sc_header_without_use)
+
+# Prohibit the inclusion of strings.h without a sensible use.
+# Using the likes of bcmp, bcopy, bzero, index or rindex is not sensible.
+sc_prohibit_strings_without_use:
+	@h='<strings.h>'						\
+	re='\<(strn?casecmp|ffs(ll)?)\>'				\
+	  $(_sc_header_without_use)
+
+# Get the list of symbol names with this:
+# perl -lne '/^# *define (\w+)\(/ and print $1' lib/intprops.h|grep -v '^s'|fmt
+_intprops_names =							\
+  TYPE_IS_INTEGER TYPE_TWOS_COMPLEMENT TYPE_ONES_COMPLEMENT		\
+  TYPE_SIGNED_MAGNITUDE TYPE_SIGNED TYPE_MINIMUM TYPE_MAXIMUM		\
+  INT_STRLEN_BOUND INT_BUFSIZE_BOUND
+_intprops_syms_re = $(subst $(_sp),|,$(strip $(_intprops_names)))
+# Prohibit the inclusion of intprops.h without an actual use.
+sc_prohibit_intprops_without_use:
+	@h='"intprops.h"'						\
+	re='\<($(_intprops_syms_re)) *\('				\
+	  $(_sc_header_without_use)
 
 sc_obsolete_symbols:
-	@re='\<(HAVE''_FCNTL_H|O''_NDELAY)\>'				\
-	msg='do not use HAVE''_FCNTL_H or O'_NDELAY			\
-	  $(_prohibit_regexp)
+	@prohibit='\<(HAVE''_FCNTL_H|O''_NDELAY)\>'			\
+	halt='do not use HAVE''_FCNTL_H or O'_NDELAY			\
+	  $(_sc_search_regexp)
 
 # FIXME: warn about definitions of EXIT_FAILURE, EXIT_SUCCESS, STREQ
 
 # Each nonempty ChangeLog line must start with a year number, or a TAB.
 sc_changelog:
-	@if $(VC_LIST_EXCEPT) | grep -l '^ChangeLog$$' >/dev/null; then	\
-	  grep -n '^[^12	]'					\
-	    $$($(VC_LIST_EXCEPT) | grep '^ChangeLog$$') &&		\
-	  { echo '$(ME): found unexpected prefix in a ChangeLog' 1>&2;	\
-	    exit 1; } || :;						\
-	fi
+	@prohibit='^[^12	]'					\
+	in_vc_files='^ChangeLog$$'					\
+	halt='found unexpected prefix in a ChangeLog'			\
+	  $(_sc_search_regexp)
 
 # Ensure that each .c file containing a "main" function also
 # calls set_program_name.
 sc_program_name:
-	@if $(VC_LIST_EXCEPT) | grep -l '\.c$$' > /dev/null; then	\
-	  files=$$(grep -l '^main *(' $$($(VC_LIST_EXCEPT) | grep '\.c$$')); \
-	  grep -LE 'set_program_name *\(m?argv\[0\]\);' $$files		\
-	      | grep . &&						\
-	  { echo '$(ME): the above files do not call set_program_name'	\
-		1>&2; exit 1; } || :;					\
-	else :;								\
-	fi
+	@require='set_program_name *\(m?argv\[0\]\);'			\
+	in_vc_files='\.c$$'						\
+	containing='^main *('						\
+	halt='the above files do not call set_program_name'		\
+	  $(_sc_search_regexp)
 
 # Require that the final line of each test-lib.sh-using test be this one:
 # Exit $fail
 # Note: this test requires GNU grep's --label= option.
+Exit_witness_file ?= tests/test-lib.sh
+Exit_base := $(notdir $(Exit_witness_file))
 sc_require_test_exit_idiom:
-	@if test -f $(srcdir)/tests/test-lib.sh; then			\
+	@if test -f $(srcdir)/$(Exit_witness_file); then		\
 	  die=0;							\
-	  for i in $$(grep -l -F /../test-lib.sh $$($(VC_LIST) tests)); do \
-	    tail -n1 $$i | grep '^Exit \$$fail$$' > /dev/null		\
+	  for i in $$(grep -l -F 'srcdir/$(Exit_base)'			\
+		$$($(VC_LIST) tests)); do				\
+	    tail -n1 $$i | grep '^Exit .' > /dev/null			\
 	      && : || { die=1; echo $$i; }				\
 	  done;								\
 	  test $$die = 1 &&						\
 	    { echo 1>&2 '$(ME): the final line in each of the above is not:'; \
-	      echo 1>&2 'Exit $$fail';					\
+	      echo 1>&2 'Exit something';				\
 	      exit 1; } || :;						\
 	fi
 
 sc_the_the:
-	@re='\<the ''the\>'						\
-	ignore_case=1 msg='found use of "the ''the";'			\
-	  $(_prohibit_regexp)
+	@prohibit='\<the ''the\>'					\
+	ignore_case=1							\
+	halt='found use of "the ''the";'				\
+	  $(_sc_search_regexp)
 
 sc_trailing_blank:
-	@re='[	 ]$$'							\
-	msg='found trailing blank(s)'					\
-	  $(_prohibit_regexp)
+	@prohibit='[	 ]$$'						\
+	halt='found trailing blank(s)'					\
+	  $(_sc_search_regexp)
 
 # Match lines like the following, but where there is only one space
 # between the options and the description:
 #   -D, --all-repeated[=delimit-method]  print all duplicate lines\n
 longopt_re = --[a-z][0-9A-Za-z-]*(\[?=[0-9A-Za-z-]*\]?)?
 sc_two_space_separator_in_usage:
-	@grep -nE '^   *(-[A-Za-z],)? $(longopt_re) [^ ].*\\$$'		\
-	    $$($(VC_LIST_EXCEPT)) &&					\
-	  { echo "$(ME): help2man requires at least two spaces between"; \
-	    echo "$(ME): an option and its description";		\
-		1>&2; exit 1; } || :
+	@prohibit='^   *(-[A-Za-z],)? $(longopt_re) [^ ].*\\$$'		\
+	halt='help2man requires at least two spaces between an option and its description'\
+	  $(_sc_search_regexp)
 
 # Look for diagnostics that aren't marked for translation.
 # This won't find any for which error's format string is on a separate line.
 sc_unmarked_diagnostics:
 	@grep -nE							\
-	    '\<error \([^"]*"[^"]*[a-z]{3}' $$($(VC_LIST_EXCEPT))	\
+	    '\<error *\([^"]*"[^"]*[a-z]{3}' $$($(VC_LIST_EXCEPT))	\
 	  | grep -v '_''(' &&						\
 	  { echo '$(ME): found unmarked diagnostic(s)' 1>&2;		\
 	    exit 1; } || :
@@ -409,45 +645,182 @@ sc_unmarked_diagnostics:
 # Avoid useless parentheses like those in this example:
 # #if defined (SYMBOL) || defined (SYM2)
 sc_useless_cpp_parens:
-	@grep -n '^# *if .*defined *(' $$($(VC_LIST_EXCEPT)) &&		\
-	  { echo '$(ME): found useless parentheses in cpp directive'	\
-		1>&2; exit 1; } || :
+	@prohibit='^# *if .*defined *\('				\
+	halt='found useless parentheses in cpp directive'		\
+	  $(_sc_search_regexp)
+
+# List headers for which HAVE_HEADER_H is always true, assuming you are
+# using the appropriate gnulib module.  CAUTION: for each "unnecessary"
+# #if HAVE_HEADER_H that you remove, be sure that your project explicitly
+# requires the gnulib module that guarantees the usability of that header.
+gl_assured_headers_ = \
+  cd $(gnulib_dir)/lib && echo *.in.h|sed 's/\.in\.h//g'
+
+# Convert the list of names to upper case, and replace each space with "|".
+az_ = abcdefghijklmnopqrstuvwxyz
+AZ_ = ABCDEFGHIJKLMNOPQRSTUVWXYZ
+gl_header_upper_case_or_ =						\
+  $$($(gl_assured_headers_)						\
+    | tr $(az_)/.- $(AZ_)___						\
+    | tr -s ' ' '|'							\
+    )
+sc_prohibit_always_true_header_tests:
+	@or=$(gl_header_upper_case_or_);				\
+	re="HAVE_($$or)_H";						\
+	prohibit='\<'"$$re"'\>'						\
+	halt='do not test the above HAVE_<header>_H symbol(s);\n'\
+'  with the corresponding gnulib module, they are always true'		\
+	  $(_sc_search_regexp)
+
+# ==================================================================
+gl_other_headers_ ?= \
+  intprops.h	\
+  openat.h	\
+  stat-macros.h
+
+# Perl -lne code to extract "significant" cpp-defined symbols from a
+# gnulib header file, eliminating a few common false-positives.
+gl_extract_significant_defines_ = \
+  /^\# *define ([^_ (][^ (]*)(\s*\(|\s+\w+)/\
+    && $$2 !~ /(?:rpl_|_used_without_)/\
+    && $$1 !~ /^(?:NSIG|ATTRIBUTE_NORETURN)$$/\
+    and print $$1
+
+# Create a list of regular expressions matching the names
+# of macros that are guaranteed to be defined by parts of gnulib.
+define def_sym_regex
+	gen_h=$(gl_generated_headers_);					\
+	(cd $(gnulib_dir)/lib;						\
+	  for f in *.in.h $(gl_other_headers_); do			\
+	    perl -lne '$(gl_extract_significant_defines_)' $$f;		\
+	  done;								\
+	) | sort -u							\
+	  | grep -Ev '^ATTRIBUTE_NORETURN'				\
+	  | sed 's/^/^ *# *(define|undef)  */;s/$$/\\>/'
+endef
+
+# Don't define macros that we already get from gnulib header files.
+sc_prohibit_always-defined_macros:
+	@if test -d $(gnulib_dir); then					\
+	  case $$(echo all: | grep -l -f - Makefile) in Makefile);; *)	\
+	    echo '$(ME): skipping $@: you lack GNU grep' 1>&2; exit 0;;	\
+	  esac;								\
+	  $(def_sym_regex) | grep -E -f - $$($(VC_LIST_EXCEPT))		\
+	    && { echo '$(ME): define the above via some gnulib .h file'	\
+		  1>&2;  exit 1; } || :;				\
+	fi
+# ==================================================================
+
+# Prohibit checked in backup files.
+sc_prohibit_backup_files:
+	@$(VC_LIST) | grep '~$$' &&				\
+	  { echo '$(ME): found version controlled backup file' 1>&2;	\
+	    exit 1; } || :
 
 # Require the latest GPL.
 sc_GPL_version:
-	@re='either ''version [^3]' msg='GPL vN, N!=3'			\
-	  $(_prohibit_regexp)
+	@prohibit='either ''version [^3]'				\
+	halt='GPL vN, N!=3'						\
+	  $(_sc_search_regexp)
+
+# Require the latest GFDL.  Two regexp, since some .texi files end up
+# line wrapping between 'Free Documentation License,' and 'Version'.
+_GFDL_regexp = (Free ''Documentation.*Version 1\.[^3]|Version 1\.[^3] or any)
+sc_GFDL_version:
+	@prohibit='$(_GFDL_regexp)'					\
+	halt='GFDL vN, N!=3'						\
+	  $(_sc_search_regexp)
+
+# Don't use Texinfo @acronym{} as it is not a good idea.
+texinfo_suffix_re_ ?= \.(txi|texi(nfo)?)$$
+sc_texinfo_acronym:
+	@prohibit='@acronym\{'						\
+	in_vc_files='$(texinfo_suffix_re_)'				\
+	halt='found use of Texinfo @acronym{}'				\
+	  $(_sc_search_regexp)
 
 cvs_keywords = \
   Author|Date|Header|Id|Name|Locker|Log|RCSfile|Revision|Source|State
 
 sc_prohibit_cvs_keyword:
-	@re='\$$($(cvs_keywords))\$$'					\
-	    msg='do not use CVS keyword expansion'			\
-	  $(_prohibit_regexp)
+	@prohibit='\$$($(cvs_keywords))\$$'				\
+	halt='do not use CVS keyword expansion'				\
+	  $(_sc_search_regexp)
+
+# This Perl code is slightly obfuscated.  Not only is each "$" doubled
+# because it's in a Makefile, but the $$c's are comments;  we cannot
+# use "#" due to the way the script ends up concatenated onto one line.
+# It would be much more concise, and would produce better output (including
+# counts) if written as:
+#   perl -ln -0777 -e '/\n(\n+)$/ and print "$ARGV: ".length $1' ...
+# but that would be far less efficient, reading the entire contents
+# of each file, rather than just the last two bytes of each.
+#
+# This is a perl script that is expected to be the single-quoted argument
+# to a command-line "-le".  The remaining arguments are file names.
+# Print the name of each file that ends in two or more newline bytes.
+# Exit nonzero if at least one such file is found, otherwise, exit 0.
+# Warn about, but otherwise ignore open failure.  Ignore seek/read failure.
+#
+# Use this if you want to remove trailing empty lines from selected files:
+#   perl -pi -0777 -e 's/\n\n+$/\n/' files...
+#
+detect_empty_lines_at_EOF_ =						\
+  foreach my $$f (@ARGV)						\
+    {									\
+      open F, "<", $$f or (warn "failed to open $$f: $$!\n"), next;	\
+      my $$p = sysseek (F, -2, 2);					\
+      my $$c = "seek failure probably means file has < 2 bytes; ignore"; \
+      my $$last_two_bytes;						\
+      defined $$p and $$p = sysread F, $$last_two_bytes, 2;		\
+      close F;								\
+      $$c = "ignore read failure";					\
+      $$p && $$last_two_bytes eq "\n\n" and (print $$f), $$fail=1;	\
+    }									\
+  END { exit defined $$fail }
+sc_prohibit_empty_lines_at_EOF:
+	@perl -le '$(detect_empty_lines_at_EOF_)' $$($(VC_LIST_EXCEPT))	\
+          || { echo '$(ME): the above files end with empty line(s)'     \
+		1>&2; exit 1; } || :;					\
 
 # Make sure we don't use st_blocks.  Use ST_NBLOCKS instead.
 # This is a bit of a kludge, since it prevents use of the string
 # even in comments, but for now it does the job with no false positives.
 sc_prohibit_stat_st_blocks:
-	@re='[.>]st_blocks' msg='do not use st_blocks; use ST_NBLOCKS'	\
-	  $(_prohibit_regexp)
+	@prohibit='[.>]st_blocks'					\
+	halt='do not use st_blocks; use ST_NBLOCKS'			\
+	  $(_sc_search_regexp)
 
 # Make sure we don't define any S_IS* macros in src/*.c files.
 # They're already defined via gnulib's sys/stat.h replacement.
 sc_prohibit_S_IS_definition:
-	@re='^ *# *define  *S_IS'					\
-	msg='do not define S_IS* macros; include <sys/stat.h>'		\
-	  $(_prohibit_regexp)
-
-# Each program that uses proper_name_utf8 must link with
-# one of the ICONV libraries.
+	@prohibit='^ *# *define  *S_IS'					\
+	halt='do not define S_IS* macros; include <sys/stat.h>'		\
+	  $(_sc_search_regexp)
+
+_ptm1 = use "test C1 && test C2", not "test C1 -''a C2"
+_ptm2 = use "test C1 || test C2", not "test C1 -''o C2"
+# Using test's -a and -o operators is not portable.
+# We prefer test over [, since the latter is spelled [[ in configure.ac.
+sc_prohibit_test_minus_ao:
+	@prohibit='(\<test| \[+) .+ -[ao] '				\
+	halt='$(_ptm1); $(_ptm2)'					\
+	  $(_sc_search_regexp)
+
+# Each program that uses proper_name_utf8 must link with one of the
+# ICONV libraries.  Otherwise, some ICONV library must appear in LDADD.
+# The perl -0777 invocation below extracts the possibly-multi-line
+# definition of LDADD from the appropriate Makefile.am and exits 0
+# when it contains "ICONV".
 sc_proper_name_utf8_requires_ICONV:
 	@progs=$$(grep -l 'proper_name_utf8 ''("' $$($(VC_LIST_EXCEPT)));\
 	if test "x$$progs" != x; then					\
 	  fail=0;							\
 	  for p in $$progs; do						\
 	    dir=$$(dirname "$$p");					\
+	    perl -0777							\
+	      -ne 'exit !(/^LDADD =(.+?[^\\]\n)/ms && $$1 =~ /ICONV/)'	\
+	      $$dir/Makefile.am && continue;				\
 	    base=$$(basename "$$p" .c);					\
 	    grep "$${base}_LDADD.*ICONV)" $$dir/Makefile.am > /dev/null	\
 	      || { fail=1; echo 1>&2 "$(ME): $$p uses proper_name_utf8"; }; \
@@ -460,9 +833,9 @@ sc_proper_name_utf8_requires_ICONV:
 # Warn about "c0nst struct Foo const foo[]",
 # but not about "char const *const foo" or "#define const const".
 sc_redundant_const:
-	@re='\bconst\b[[:space:][:alnum:]]{2,}\bconst\b'		\
-	msg='redundant "const" in declarations'				\
-	  $(_prohibit_regexp)
+	@prohibit='\bconst\b[[:space:][:alnum:]]{2,}\bconst\b'		\
+	halt='redundant "const" in declarations'			\
+	  $(_sc_search_regexp)
 
 sc_const_long_option:
 	@grep '^ *static.*struct option ' $$($(VC_LIST_EXCEPT))		\
@@ -473,7 +846,8 @@ sc_const_long_option:
 NEWS_hash =								\
   $$(sed -n '/^\*.* $(PREV_VERSION_REGEXP) ([0-9-]*)/,$$p'		\
        $(srcdir)/NEWS							\
-     | grep -v '^Copyright .*Free Software'				\
+     | perl -0777 -pe							\
+	's/^Copyright.+?Free\sSoftware\sFoundation,\sInc\.\n//ms'	\
      | md5sum -								\
      | sed 's/ .*//')
 
@@ -487,7 +861,7 @@ sc_immutable_NEWS:
 # Update the hash stored above.  Do this after each release and
 # for any corrections to old entries.
 update-NEWS-hash: NEWS
-	perl -pi -e 's/^(old_NEWS_hash = ).*/$${1}'"$(NEWS_hash)/" \
+	perl -pi -e 's/^(old_NEWS_hash[ \t]+:?=[ \t]+).*/$${1}'"$(NEWS_hash)/" \
 	  $(srcdir)/cfg.mk
 
 # Ensure that we use only the standard $(VAR) notation,
@@ -495,33 +869,36 @@ update-NEWS-hash: NEWS
 # to emit a definition for each substituted variable.
 # We use perl rather than "grep -nE ..." to exempt a single
 # use of an @...@-delimited variable name in src/Makefile.am.
-sc_makefile_check:
-	@perl -ne '/\@[A-Z_0-9]+\@/ && !/^cu_install_program =/'	\
+# Allow the package to add exceptions via a hook in cfg.mk;
+# for example, @PRAGMA_SYSTEM_HEADER@ can be permitted by
+# setting this to ' && !/PRAGMA_SYSTEM_HEADER/'.
+_makefile_at_at_check_exceptions ?=
+sc_makefile_at_at_check:
+	@perl -ne '/\@[A-Z_0-9]+\@/'$(_makefile_at_at_check_exceptions)	\
 	  -e 'and (print "$$ARGV:$$.: $$_"), $$m=1; END {exit !$$m}'	\
 	    $$($(VC_LIST_EXCEPT) | grep -E '(^|/)Makefile\.am$$')	\
 	  && { echo '$(ME): use $$(...), not @...@' 1>&2; exit 1; } || :
 
-news-date-check: NEWS
-	today=`date +%Y-%m-%d`;						\
-	if head $(srcdir)/NEWS | grep '^\*.* $(VERSION_REGEXP) ('$$today')' \
-	    >/dev/null; then						\
+news-check: NEWS
+	if sed -n $(news-check-lines-spec)p $(srcdir)/NEWS		\
+	    | grep -E $(news-check-regexp) >/dev/null; then		\
 	  :;								\
 	else								\
-	  echo "version or today's date is not in NEWS" 1>&2;		\
+	  echo 'NEWS: $$(news-check-regexp) failed to match' 1>&2;	\
 	  exit 1;							\
 	fi
 
 sc_makefile_TAB_only_indentation:
-	@grep -nE '^	[ ]{8}'						\
-	    $$($(VC_LIST_EXCEPT) | grep -E 'akefile|\.mk$$')		\
-	  && { echo '$(ME): found TAB-8-space indentation' 1>&2;	\
-	       exit 1; } || :
+	@prohibit='^	[ ]{8}'						\
+	in_vc_files='akefile|\.mk$$'					\
+	halt='found TAB-8-space indentation'				\
+	  $(_sc_search_regexp)
 
 sc_m4_quote_check:
-	@grep -nE '(AC_DEFINE(_UNQUOTED)?|AC_DEFUN)\([^[]'		\
-	    $$($(VC_LIST_EXCEPT) | grep -E '(^configure\.ac|\.m4)$$')	\
-	  && { echo '$(ME): quote the first arg to AC_DEF*' 1>&2;	\
-	       exit 1; } || :
+	@prohibit='(AC_DEFINE(_UNQUOTED)?|AC_DEFUN)\([^[]'		\
+	in_vc_files='(^configure\.ac|\.m4)$$'				\
+	halt='quote the first arg to AC_DEF*'				\
+	  $(_sc_search_regexp)
 
 fix_po_file_diag = \
 'you have changed the set of files with translatable diagnostics;\n\
@@ -537,6 +914,7 @@ sc_po_check:
 	  for file in $$($(VC_LIST_EXCEPT)) lib/*.[ch]; do		\
 	    test -r $$file || continue;					\
 	    case $$file in						\
+	      *.m4|*.mk) continue ;;					\
 	      *.?|*.??) ;;						\
 	      *) continue;;						\
 	    esac;							\
@@ -559,9 +937,10 @@ sc_po_check:
 # path separator of `:', but rather the automake-provided `$(PATH_SEPARATOR)'.
 msg = '$(ME): Do not use `:'\'' above; use $$(PATH_SEPARATOR) instead'
 sc_makefile_path_separator_check:
-	@grep -nE 'PATH[=].*:'						\
-	    $$($(VC_LIST_EXCEPT) | grep -E 'akefile|\.mk$$')		\
-	  && { echo $(msg) 1>&2; exit 1; } || :
+	@prohibit='PATH[=].*:'						\
+	in_vc_files='akefile|\.mk$$'					\
+	halt=$(msg)							\
+	  $(_sc_search_regexp)
 
 # Check that `make alpha' will not fail at the end of the process.
 writable-files:
@@ -581,25 +960,63 @@ texi = doc/$(PACKAGE).texi
 # Make sure that the copyright date in $(v_etc_file) is up to date.
 # Do the same for the $(sample-test) and the main doc/.texi file.
 sc_copyright_check:
-	@if test -f $(v_etc_file); then					\
-	  grep 'enum { COPYRIGHT_YEAR = '$$(date +%Y)' };' $(v_etc_file) \
-	    >/dev/null							\
-	  || { echo 'out of date copyright in $(v_etc_file); update it' 1>&2; \
-	       exit 1; };						\
-	fi
-	@if test -f $(sample-test); then				\
-	  grep '# Copyright (C) '$$(date +%Y)' Free' $(sample-test)	\
-	    >/dev/null							\
-	  || { echo 'out of date copyright in $(sample-test); update it' 1>&2; \
-	       exit 1; };						\
-	fi
-	@if test -f $(texi); then					\
-	  grep 'Copyright @copyright{} .*'$$(date +%Y)' Free' $(texi)	\
-	    >/dev/null							\
-	  || { echo 'out of date copyright in $(texi); update it' 1>&2;	\
-	       exit 1; };						\
+	@require='enum { COPYRIGHT_YEAR = '$$(date +%Y)' };'		\
+	in_files=$(v_etc_file)						\
+	halt='out of date copyright in $(v_etc_file); update it'	\
+	  $(_sc_search_regexp)
+	@require='# Copyright \(C\) '$$(date +%Y)' Free'		\
+	in_vc_files=$(sample-test)					\
+	halt='out of date copyright in $(sample-test); update it'	\
+	  $(_sc_search_regexp)
+	@require='Copyright @copyright\{\} .*'$$(date +%Y)' Free'	\
+	in_vc_files=$(texi)						\
+	halt='out of date copyright in $(texi); update it'		\
+	  $(_sc_search_regexp)
+
+# If tests/help-version exists and seems to be new enough, assume that its
+# use of init.sh and path_prepend_ is correct, and ensure that every other
+# use of init.sh is identical.
+# This is useful because help-version cross-checks prog --version
+# with $(VERSION), which verifies that its path_prepend_ invocation
+# sets PATH correctly.  This is an inexpensive way to ensure that
+# the other init.sh-using tests also get it right.
+_hv_file ?= $(srcdir)/tests/help-version
+_hv_regex_weak ?= ^ *\. .*/init\.sh"
+_hv_regex_strong ?= ^ *\. "\$${srcdir=\.}/init\.sh"
+sc_cross_check_PATH_usage_in_tests:
+	@if test -f $(_hv_file); then					\
+	  grep -l 'VERSION mismatch' $(_hv_file) >/dev/null		\
+	    || { echo "$@: skipped: no such file: $(_hv_file)" 1>&2;	\
+		 exit 0; };						\
+	  grep -lE '$(_hv_regex_strong)' $(_hv_file) >/dev/null		\
+	    || { echo "$@: $(_hv_file) lacks conforming use of init.sh" 1>&2; \
+		 exit 1; };						\
+	  good=$$(grep -E '$(_hv_regex_strong)' $(_hv_file));		\
+	  grep -LFx "$$good"						\
+		$$(grep -lE '$(_hv_regex_weak)' $$($(VC_LIST_EXCEPT)))	\
+	      | grep . &&						\
+	    { echo "$(ME): the above files use path_prepend_ inconsistently" \
+		1>&2; exit 1; } || :;					\
 	fi
 
+# #if HAVE_... will evaluate to false for any non numeric string.
+# That would be flagged by using -Wundef, however gnulib currently
+# tests many undefined macros, and so we can't enable that option.
+# So at least preclude common boolean strings as macro values.
+sc_Wundef_boolean:
+	@prohibit='^#define.*(yes|no|true|false)$$'			\
+	in_files='$(CONFIG_INCLUDE)'					\
+	halt='Use 0 or 1 for macro values'				\
+	  $(_sc_search_regexp)
+
+sc_vulnerable_makefile_CVE-2009-4029:
+	@prohibit='perm -777 -exec chmod a\+rwx|chmod 777 \$$\(distdir\)' \
+	in_files=$$(find $(srcdir) -name Makefile.in)			\
+	halt='the above files are vulnerable; beware of running\n'\
+'"make dist*" rules, and upgrade to fixed automake\n'\
+'see http://bugzilla.redhat.com/542609 for details'			\
+	  $(_sc_search_regexp)
+
 vc-diff-check:
 	(unset CDPATH; cd $(srcdir) && $(VC) diff) > vc-diffs || :
 	if test -s vc-diffs; then				\
@@ -610,46 +1027,35 @@ vc-diff-check:
 	  rm vc-diffs;						\
 	fi
 
-cvs-check: vc-diff-check
-
-ALL_RECURSIVE_TARGETS += maintainer-distcheck
-maintainer-distcheck:
-	$(MAKE) distcheck
-	$(MAKE) taint-distcheck
-	$(MAKE) my-distcheck
-
-
-# Don't make a distribution if checks fail.
-# Also, make sure the NEWS file is up-to-date.
-ALL_RECURSIVE_TARGETS += vc-dist
-vc-dist: $(local-check) cvs-check maintainer-distcheck
-	XZ_OPT=-9ev $(MAKE) dist
-
-# Use this to make sure we don't run these programs when building
-# from a virgin tgz file, below.
-null_AM_MAKEFLAGS = \
-  ACLOCAL=false \
-  AUTOCONF=false \
-  AUTOMAKE=false \
-  AUTOHEADER=false \
-  MAKEINFO=false
-
-built_programs = $$(cd src && MAKEFLAGS= $(MAKE) -s built_programs.list)
-
 rel-files = $(DIST_ARCHIVES)
 
 gnulib_dir ?= $(srcdir)/gnulib
 gnulib-version = $$(cd $(gnulib_dir) && git describe)
 bootstrap-tools ?= autoconf,automake,gnulib
 
+# If it's not already specified, derive the GPG key ID from
+# the signed tag we've just applied to mark this release.
+gpg_key_ID ?= \
+  $$(git cat-file tag v$(VERSION) > .ann-sig \
+     && gpgv .ann-sig - < /dev/null 2>&1 \
+	  | sed -n '/.*key ID \([0-9A-F]*\)/s//\1/p'; rm -f .ann-sig)
+
+translation_project_ ?= coordinator@translationproject.org
+announcement_Cc_ ?= $(translation_project_), $(PACKAGE_BUGREPORT)
+announcement_mail_headers_ ?=						\
+To: info-gnu@gnu.org							\
+Cc: $(announcement_Cc_)							\
+Mail-Followup-To: $(PACKAGE_BUGREPORT)
+
 announcement: NEWS ChangeLog $(rel-files)
 	@$(build_aux)/announce-gen					\
+	    --mail-headers='$(announcement_mail_headers_)'		\
 	    --release-type=$(RELEASE_TYPE)				\
 	    --package=$(PACKAGE)					\
 	    --prev=$(PREV_VERSION)					\
 	    --curr=$(VERSION)						\
 	    --gpg-key-id=$(gpg_key_ID)					\
-	    --news=NEWS							\
+	    --news=$(srcdir)/NEWS					\
 	    --bootstrap-tools=$(bootstrap-tools)			\
 	    --gnulib-version=$(gnulib-version)				\
 	    --no-print-checksums					\
@@ -662,13 +1068,14 @@ announcement: NEWS ChangeLog $(rel-files
 ftp-gnu = ftp://ftp.gnu.org/gnu
 www-gnu = http://www.gnu.org
 
+upload_dest_dir_ ?= $(PACKAGE)
 emit_upload_commands:
 	@echo =====================================
 	@echo =====================================
 	@echo "$(build_aux)/gnupload $(GNUPLOADFLAGS) \\"
-	@echo "    --to $(gnu_rel_host):$(PACKAGE) \\"
+	@echo "    --to $(gnu_rel_host):$(upload_dest_dir_) \\"
 	@echo "  $(rel-files)"
-	@echo '# send the /tmp/announcement e-mail'
+	@echo '# send the ~/announce-$(my_distdir) e-mail'
 	@echo =====================================
 	@echo =====================================
 
@@ -693,33 +1100,50 @@ no-submodule-changes:
 	  : ;								\
 	fi
 
-.PHONY: alpha beta major
-ALL_RECURSIVE_TARGETS += alpha beta major
-alpha beta major: $(local-check) writable-files no-submodule-changes
-	test $@ = major						\
-	  && { echo $(VERSION) | grep -E '^[0-9]+(\.[0-9]+)+$$'	\
+.PHONY: alpha beta stable
+ALL_RECURSIVE_TARGETS += alpha beta stable
+alpha beta stable: $(local-check) writable-files no-submodule-changes
+	test $@ = stable						\
+	  && { echo $(VERSION) | grep -E '^[0-9]+(\.[0-9]+)+$$'		\
 	       || { echo "invalid version string: $(VERSION)" 1>&2; exit 1;};}\
 	  || :
-	$(MAKE) vc-dist
-	$(MAKE) news-date-check
-	$(MAKE) -s announcement RELEASE_TYPE=$@ > /tmp/announce-$(my_distdir)
+	$(MAKE) vc-diff-check
+	$(MAKE) news-check
+	$(MAKE) distcheck
+	$(MAKE) dist XZ_OPT=-9ev
+	$(MAKE) $(release-prep-hook) RELEASE_TYPE=$@
+	$(MAKE) -s emit_upload_commands RELEASE_TYPE=$@
+
+# Override this in cfg.mk if you follow different procedures.
+release-prep-hook ?= release-prep
+
+.PHONY: release-prep
+release-prep:
+	case $$RELEASE_TYPE in alpha|beta|stable) ;; \
+	  *) echo "invalid RELEASE_TYPE: $$RELEASE_TYPE" 1>&2; exit 1;; esac
+	$(MAKE) -s announcement > ~/announce-$(my_distdir)
 	if test -d $(release_archive_dir); then			\
 	  ln $(rel-files) $(release_archive_dir);		\
 	  chmod a-w $(rel-files);				\
 	fi
-	$(MAKE) -s emit_upload_commands RELEASE_TYPE=$@
 	echo $(VERSION) > $(prev_version_file)
 	$(MAKE) update-NEWS-hash
 	perl -pi -e '$$. == 3 and print "$(noteworthy)\n\n\n"' NEWS
 	$(emit-commit-log) > .ci-msg
 	$(VC) commit -F .ci-msg -a
+	rm .ci-msg
+
+# Override this with e.g., -s $(srcdir)/some_other_name.texi
+# if the default $(PACKAGE)-derived name doesn't apply.
+gendocs_options_ ?=
 
 .PHONY: web-manual
 web-manual:
 	@test -z "$(manual_title)" \
 	  && { echo define manual_title in cfg.mk 1>&2; exit 1; } || :
 	@cd '$(srcdir)/doc'; \
-	  $(SHELL) ../build-aux/gendocs.sh -o '$(abs_builddir)/doc/manual' \
+	  $(SHELL) ../build-aux/gendocs.sh $(gendocs_options_) \
+	     -o '$(abs_builddir)/doc/manual' \
 	     --email $(PACKAGE_BUGREPORT) $(PACKAGE) \
 	    "$(PACKAGE_NAME) - $(manual_title)"
 	@echo " *** Upload the doc/manual directory to web-cvs."
@@ -761,7 +1185,26 @@ refresh-po:
 	echo 'en@quot' >> $(PODIR)/LINGUAS && \
 	ls $(PODIR)/*.po | sed 's/\.po//' | sed 's,$(PODIR)/,,' | sort >> $(PODIR)/LINGUAS
 
+ # Running indent once is not idempotent, but running it twice is.
 INDENT_SOURCES ?= $(C_SOURCES)
 .PHONY: indent
 indent:
 	indent $(INDENT_SOURCES)
+	indent $(INDENT_SOURCES)
+
+# If you want to set UPDATE_COPYRIGHT_* environment variables,
+# put the assignments in this variable.
+update-copyright-env ?=
+
+# Run this rule once per year (usually early in January)
+# to update all FSF copyright year lists in your project.
+# If you have an additional project-specific rule,
+# add it in cfg.mk along with a line 'update-copyright: prereq'.
+# By default, exclude all variants of COPYING; you can also
+# add exemptions (such as ChangeLog..* for rotated change logs)
+# in the file .x-update-copyright.
+.PHONY: update-copyright
+update-copyright:
+	grep -l -w Copyright                                             \
+	  $$(export VC_LIST_EXCEPT_DEFAULT=COPYING && $(VC_LIST_EXCEPT)) \
+	  | $(update-copyright-env) xargs $(build_aux)/$@
